\documentclass[a4paper,12pt,twoside]{article}

\nonstopmode
\newcommand{\timestamp}{28/06/2019}

\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage{pslatex}  % pour une meilleure portabilit√© des polices...
\usepackage{hyperref} % pour avoir la structure du document dans acroread
\usepackage[english]{babel}
\usepackage{a4}
\usepackage{graphicx}
\usepackage{listings}
\usepackage[usenames,dvipsnames]{color}
\usepackage[all]{xy}
\usepackage{ltablex}
\usepackage{alltt}
\usepackage{ulem}
\usepackage{cite}
\usepackage{varioref,multicol,multirow,xspace,rotating,moreverb}
\usepackage{makeidx}
\usepackage{enumitem}
\usepackage{tabto}
\usepackage{dirtree}

\widowpenalty=400
\clubpenalty=400
\setlength{\parskip}{1ex plus 1ex minus 1ex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% SETTINGS

\hyphenation{Raven-SPARK}

\lstset{numbers=none,
	numberstyle=\tiny,
	stepnumber=1,
	numbersep=8pt,
	numberfirstline=true,
	frame=leftline,
	language=Bash,
	tabsize=2,
	breaklines=true,
	xleftmargin=1cm,
	emph={label},
	basicstyle=\small\ttfamily
}

% used to add some spacing before a new item (description)
\let\olditem=\item
\def\myitem[#1]{\vspace{10pt}\olditem[#1]}
%\let\oldbegin\begin
%\def\begin{\let\item\olditem\oldbegin}

% always start the description text in a new line
\setlist[description]{%
	style=nextline,
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% COMMANDS

\newenvironment{shellcommand}{
	\begin{list}{ % item
			\bfseries\texttt \$
		}{ % body
			\ttfamily
			\setlength{\topsep}{-0.3ex}
			\setlength{\labelwidth}{1in}
			\setlength{\leftmargin}{0.7in}
			\setlength{\labelsep}{0.5ex}
			\setlength{\rightmargin}{0.5in}
			\setlength{\itemsep}{1ex}
			\setlength{\parsep}{0ex}
			\setlength{\listparindent}{0.5in}
		}
	}{
	\end{list}
}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\tbd}[1]{\fbox{{\smallpencil #1 }}}
\renewcommand{\emph}[1]{\textit{#1}}
\newcommand{\seeref}[1]{see section \ref{#1} p.\pageref{#1}}
\newcommand{\file}[1]{'{\path{#1}}'}
\newcommand{\des}[1]{\tabto{4.5cm}\scriptsize\textit{: #1}}
%\newcommand{\cmd}[1]{\tabto{1cm}$\arrowvert$\hspace{0.5cm}\texttt{\$ #1}}
\newcommand{\cmd}[1]{\tabto{1cm}\hspace{0.5cm}\texttt{\textbf{\$} #1}}

\setitemize[0]{font=\bfseries, label=$\bullet$ }

% let section start on a new page
\let\stdsection\section
\renewcommand\section{\newpage\stdsection}
\newcommand{\ddash}{-{}-}
\setlength{\parindent}{0in}

\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% TITRE

\input{version}

\title{{\Huge S C B I} \\
	{\large  A Build Driver \version} \\
	\hfill \\
	User's Guide}
\author{Pascal Obry}
\date{\today}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% TOC

\begin{document}

\maketitle

%\include{version}

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% SECTION

\section{Introduction}

SCBI stands for Setup Config Build Install.

The goal is to automate the build procedures from sources. The main features are:

\begin{itemize}
	\item Allow recursive build of dependencies
	\item Building from a VCS (currently supported \emph{Git}, \emph{Subversion} and \emph{Mercurial})
	\item Supports build variants
	\item Supports for cross compilation
	\item Building a specific branch or tag (Git only)
	\item Building from a tarball
	\item Building from a user's checkout for easy debug with controlled environment
	\item Support for build plans (modules with specific variant and/or version)
\end{itemize}

The driver and plug-in modules are all written in \code{bash} scripts.

For developer of new plug-in modules in SCBI, all setup, source copy and installation are transparent actions, developers just need to fill functions to configure, build and install (generally just calling \code{configure} from \code{autotool} or \code{cmake} and \code{make}).

Those functions are very close to what would have been typed when building manually from the command line. The goal is to reduce as much as possible the gap between a standard manual build and the commands used on plug-in modules.

When properly setup, building any software should be as easy as:

\cmd{scbi \ddash{}plan=ver mysoft}

We'll see how to achieve that in this document.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% SECTION

\section{Using}

\subsection{Module reference}
\label{modref}
\index{module reference}

A module is described in an SCBI plug-in script (one plug-in in one file). It can be referenced in different places (in other plug-ins, build plan, etc...) with the following format which is called a \emph{module reference}:

\code{[for\_module=]name[/variant][:version]}
\label{dev}

\begin{description}[style=nextline]
	\item[for\_module] The name of the module depending on this module reference. This is optional and can be used to select a specific variant or version when the module \code{name} is used a a dependency on \code{for\_module}.

	\item[name] The name of the module. This is the main reference for the module. The corresponding module script must be named identically and located in \code{\$SCBI\_DEFS}.

	\item[variant] \label{variant}This is a name to identify a build variant for the module. For example an application can be built with different configuration and or dependencies.

	\begin{description}[font=\texttt]
		\item[<ID>] The variant name. This will trigger specific hook routines from the module scripts.

		\item[native] \index{variant!native}A variant name that can be defined to use the distribution package. This name \code{native} is mandatory in this case and requited when using the \code{auto} mode (see below). When a \code{native} variant is referenced the \code{build-depends} hook is not used (\seeref{native variant}).

		\item[auto] \index{variant!auto}A specific variant name which checks the dependencies of the defined \code{native} variant and use it if all dependencies are available (not necessary installed). The \code{auto} variant should not be defined in a plug-in script but only used in references. The \code{native} and \code{auto} variant can be used together to build a package or use the native one depending on the availability of the dependencies on the running OS. If used together with other variants, the \code{auto} variant must be the first one, that is just after the slash. For example:

		\code{module/auto.fast:v1.3}

		Finally, the \code{auto} variant can only be defined in a build plan or on the command line.
	\end{description}

	\item[version] The version to build. This version string can be either:

	\begin{description}[font=\texttt]
		\item[<ID>] A reference to a VCS version (branch or a Git SHA-1 for example), or a tar version when starting with \#.
		\item[dev] \index{version!dev}To take the source from a user's checkout.
		\item[skip] \index{version!skip}To specify that the module must be ignored.
		\item[force] \index{version!force}To enable an otherwise skip module (possibly set to skip in a build plan).
	\end{description}

	The version can be set to \code{force} on the command line to tell that the module should not be skipped. On the command line it is always possible to force a build of a module to a specific variant or version. But if one need to build the default variant or version it is required to pass the \code{force} as version.

	That is, the following command will never overwrite a build plan as it is a default reference to a module:

	\cmd{scbi --plan=xyz mod}

	But this will do:

	\cmd{scbi --plan=xyz mod:force}
\end{description}

The following are examples of module references:

\begin{description}[style=nextline]
	\item[lcms2] Build \code{lcms2} from repository main (master/trunk) branch.

	\item[lcms2/fast] Build \code{lcms2} \emph{fast} variant from repository main (master/trunk) branch.

	\item[gimp=lcms2/slow] When a direct dependency of project \code{gimp}, build \code{lcms2} \emph{slow} variant from repository main (master/trunk) branch.

	\item[lcms2:v2.0] Build \code{lcms2} from repository using branch (or tag) \emph{2.0}.

	\item[lcms2/fast:v2.0] Build \code{lcms2} \emph{fast} variable from repository using branch (or tag) \emph{2.0}.

	\item[lcms2:bfaf7b82ed] Build \code{lcms2} from repository using sources from SHA-1 \emph{bfaf7b82ed} (Git only).

	\item[lcms2:\#v1.0] Build \code{lcms2} using sources from tar version \emph{1.0}.

	\item[lcms2:dev] Build \code{lcms2} using sources from user's repository checkout found in \code{\$SCBI\_GIT\_REPO} (assuming \code{lcms2} is using Git). For a discussion about user's check-out \seeref{userco}.

	\item[lcms2:skip] Skip \code{lcms2} from the build. This is especially useful when set on a build plan or the command line to specify that the module is to be ignored.
\end{description}

\subsection{Environment}
\label{build-env}
\index{environment}

An environment is a set of shell variables used to control the build environment. SCBI come with defaults that can be used as-is, but one can fine tune the build environment using the following variables.

\subsubsection{Description}

\begin{description}[before=\let\item\myitem]
	\item[SCBI\_DEFAULT\_ENV] The scbi default environment file to use.

	\item[SCBI\_VERSION] The scbi driver version string.
	\\This version is \version.

	\item[SCBI\_PLUGINS] The directories where the SCBI plug-ins are located. \\Default is \file{$HOME/.config/scbi}.

	\item[SCBI\_PLAN] The name of the build-plan to use if any.

	\item[SCBI\_ROOT] The default root directory to use by SCBI. \\Default is \file{$HOME/dev}.

	\item[SCBI\_BDIR] The default directory for the build directory.  This is also called the sandbox directory. \\Default is \file{$SCBI_ROOT/builds}.

	\item[SCBI\_MODULES\_DIR{[<module-name>]}] An associative array giving the install directory for a given module name. Directories have \code{\$SCBI\_BDIR} has prefix and point to the install directory for the module's variant. This associative array can be used in hooks \code{config}, \code{build} and \code{install}.

	\item[SCBI\_PREFIX] The default global install directory. Each module after being installed into the sandbox are copied into this global installation directory. \\Default is \file{$SCBI_BDIR/install}. Each module can disable global installation (\seeref{global-install}).

	\item[SCBI\_GIT\_REPO] The directories where the user's Git checkouts are to be found. \\Default is \file{$SCBI_ROOT/repositories/git}.

	\item[SCBI\_SVN\_REPO] The directories where the user's Subversion checkouts are to be found. \\Default is \file{$SCBI_ROOT/repositories/svn}.

	\item[SCBI\_HG\_REPO] The directories where the user's Mercurial checkouts are to be found. \\Default is \file{$SCBI_ROOT/repositories/hg}.

	\item[SCBI\_TAR] The directories where the tarball are located. \\Default is \file{$SCBI_ROOT/.tar}.

	\item[SCBI\_LOGS] The directories where the logs are located. \\Default is \file{$SCBI_ROOT/.logs}.

	\item[SCBI\_PATCH] The directories where the patches are located. \\Default is \file{$SCBI_ROOT/.patches}.

	\item[SCBI\_HOST] The host triplet identifying the running environment.

	\item[SCBI\_TARGET] The target triplet for the builds. \\Default is \code{\$SCBI\_HOST}.

	\item[SCBI\_JOBS] The number of simultaneous jobs to use to build. This variable is to be used in module scripts. \\Default set to actual number of cores. This can be overwritten using \code{--jobs} option.
	\label{njobs}
	\item[SCBI\_HALF\_JOBS] Half the simultaneous jobs to use to build. This variable is to be used in module scripts. \\Default set to actual number of cores divided by 2. This can be overwritten using \code{\ddash{}jobs} option.\label{half-njobs}
\end{description}

\subsubsection{Environment files}
\label{envfile}
\index{environment!file}

The environment can be set in the following files searched in this exact order:

\begin{description}
	\item[\code{\$PWD/.scbi-env}] The local environment found in the current working directory.

	\item[\code{\$PWD/../.scbi-env}] The local environment found in the parent of the working directory. This environment can then be shared for a set of repositories.

	\item[\code{\$HOME/.scbi-env}] The local environment found in the HOME. This environment can then be shared by all builds.

	\item[\code{\$SCBI\_DEFS/.env}] The default global environment used for all builds.
\end{description}

Also note that instead of the default \file{.env} (or \file{.scbi-env} for local environment files) a specific environment file can be specified with the \code{\ddash{}env=<name>} command line option. (\seeref{cmdline}).

Example, to use environment \file{.env-next} to build \code{lcms2}:

\cmd{scbi \ddash{}env=next lcms2}

Or using an environment variable:

\cmd{export SCBI\_DEFAULT\_ENV=next}

\cmd{scbi lcms2}

\subsection{Build plans}
\label{build-plan}
\index{build plan}

A build-plan is a file listing for each module a specific version to build. It is equivalent to list all versions on the command line:

\cmd{scbi lcms2:v2 aws:v1}

But it is preferable to use a build plan to ensure a reproducible build and have all information properly recorded into a version control for example.

A build-plan is a file named \file{.plan-<name>} and listing the versions (\seeref{modref} about module references) for each software:

File \file{.plan-next}:
\begin{lstlisting}
 lcms2:v2
 aws:v1
\end{lstlisting}

Some specific actions are supported with the following syntax:

\begin{description}
	\item[\code{\#}] To start a comment line.

	\item[\code{@load <name>}] To load another build-plan as a base for the new plan. Every descriptions after this will overwrite the loaded build plan.

	This is a simple way to derive a build plan from another one.

	File \file{.plan-next}:

	\begin{lstlisting}
		# the next line will load build plan standard
		@load standard
		lcms2:v2
		aws:v1
	\end{lstlisting}

	\item[\code{@on <discriminants> <module-reference>}] To set a module reference only if the running OS is matching the discriminants. The discriminants are separated with coma and can be the OS name (3 letters OS acronym supported), the OS version, the full OS name (debian, fedora, etc.) and the architecture. Use option \ddash{}stat to see all supported OS and the list of discriminants for the running machine. If all discriminant are matching the module reference will overwrite previous definitions.

	\begin{lstlisting}
	#  Skip lcms2 on Debian-9
	@on deb,9 lcms2:skip
	#  Use v2 of lcms2 on Fedora
	@on fed   lcms2:v2
	\end{lstlisting}

	\item[\code{[ <barrier> ... ] /variant:version}] To create a group. The barrier if present must evaluate to true or the group is ignored.

	A group can be used in a build plan to group together all modules with the same version and/or variant. To define a group:

	\begin{description}
		\item[ {[} <barrier>] Start with a square bracket and an optional barrier. The barrier is a condition starting with \code{=} or \code{/=} and the name of a \code{variant} which will be searched on the specified module's plan variants or a set of OS discriminants.

		\code{\ddash{}plan=name/variant1.variant2}

		The group will be evaluated only if the barrier evaluate to true otherwise it will be skipped. If the barrier is not specified the group will always be evaluated (i.e. the barrier is by default TRUE).

		\item[ {]} /variant:version ] Ends with \code{/variant:version} which is the variant and version to apply to all modules in the group. Both \code{variant} and \code{version} are optional.
	\end{description}

	Without a barrier, will always be open:

	\begin{lstlisting}
		lcms2:v2
		[
			moduleA
			moduleB
		] /speed:v3
	\end{lstlisting}

	With a barrier based on a variant (will be open if the build plan is for example \code{\ddash{}plan=name/variant1.variant2}):

	\begin{lstlisting}
		lcms2:v2
		[ = variant1
			moduleA
			moduleB
		] /speed:v3
	\end{lstlisting}

	With a barrier based on discriminants (will be open on Debian 10):

	\begin{lstlisting}
		lcms2:v2
		[ = deb,10
			moduleA
			moduleB
		] /speed:v3
	\end{lstlisting}
\end{description}

And finally, to build one just need to pass the build plan as option:

\cmd{scbi \ddash{}plan=next lcms2 aws}

Note that if a module is set as \code{skip} on the build plan, to build the default version one need to force it on the command line:

\cmd{scbi \ddash{}plan=next lcms2:force aws}

A set of variants separated with a dot can be specified with the build plan. In the following example we set the \code{mpi} variant of the build plan \code{next}. This will activate all groups having the following barrier "\code{= mpi}".

\cmd{scbi \ddash{}plan=next/mpi lcms2:force aws}

It is possible to list the final build plan (that is all modules with their corresponding version) using \code{\ddash{}list-plan} option. See \ref{cmdline}.

A build-plan can be set in the following files searched in this exact order:

\begin{description}
	\item[\code{\$PWD/.scbi-plan-<name>}] A local build plan found in the current working directory.

	\item[\code{\$SCBI\_DEFS/.plan-<name>}] A global build-plan.
\end{description}

\subsection{Standalone source archive}
\label{standalone}
\index{source archive}

Using the \code{\ddash{}standalone} option it is possible to build a fully self contained source archive. This archive embed all necessary sources and scripts to rebuild the software without the need to get access to repositories or source tar files.

On the root of the archive a build script is provided, so starting a build from such standalone source archive boil done to:

\begin{description}
	\item[Uncompress] \cmd{tar xf sa-archive.tgz}
	\item[Enter the directory] \cmd{cd sa-archive}
	\item[Start the build] \cmd{./build}
\end{description}

By default the archive is created into \code{/tmp}, but it is possible to change the location setting the \code{SCBI\_TMP} environment variable. This may be needed as such archive can be very large.

The file \code{build-deps} is generated into the root directory and contains the \code{apt} command with all external (OS) dependencies needed to build the software.

\subsection{Command line}

\subsubsection{Description}

The SCBI command line:

\cmd{scbi [options] module-ref1 [module-ref2 ... module-refn]}

For a description of the module reference, \seeref{modref}.

It is possible to list the module currently supported by running \code{scbi} with \code{\ddash{}help} or \code{\ddash{}stat} option or with \code{[TAB]} key if completion support is activated (\seeref{completion}).

\subsubsection{Options}
\label{cmdline}

The following options are supported:

\begin{description}[font=\texttt]
	\item[-h | \ddash{}help] List options and usage information.

	\item[-v | \ddash{}version] Display version information of the SCBI driver and versions from plug-ins distributions coming from other sources\footnote{Note that for this to be supported the plug-ins distribution must have generated and installed a file name \file{.scbi*version.txt} next to the plug-ins.}.

	\item[\ddash{}prefix=<dir>] The installation directory to use instead of the default \file{$SCBI_PREFIX}.

	\item[\ddash{}build-dir=<dir>] The root build directory to use instead of the default \file{$SCBI_BDIR}.

	\item[-e | \ddash{}env=<name>] Use environment file \code{.env-<name>} instead of the default \code{.env}. (\seeref{build-env})

	\item[\ddash{}plan=<name>{[}/variant{]}] Use build plan file \code{.plan-<name>}. (\seeref{build-plan}) with an optional \code{variant}.

	\item[\ddash{}enable-<name>] Enable feature \emph{name}, (\seeref{enable-feature}).

	\item[-t | \ddash{}target=<name>] Specify the target to build for, the default is same as the host. This is needed for cross-compilation only.

	\item[-S | \ddash{}no-setup] Skip the setup step.

	\item[-W | \ddash{}no-wrapup] Skip the wrapup step.

	\item[-I | \ddash{}no-install] Skip the install step.

	\item[-u | \ddash{}update] Update the repositories before building.

	\item[-s | \ddash{}setup] Do the setup step (default)

	\item[-c | \ddash{}config] Do the config step (default)

	\item[-b | \ddash{}build]  Do the build step (default)

	\item[-i | \ddash{}install] Do the install step (default)

	\item[\ddash{}clean-install] Clean installation directory

	\item[-w | \ddash{}wrapup] Do the wrapup step (default).

	\item[\ddash{}tar] Check for tar only if explicitly specified in the module reference.

	\item[\ddash{}tests{[:only]}] Do a standard build cycle and run the testsuite if any. If suboption \code{only} is specified on run the testsuite.

	\item[-d | \ddash{}deps{[:warning]}] Check all dependencies and build them if necessary. Do not fail when a missing external depenencies is found when sub-option warning is set.

	\item[-a | \ddash{}archive] Build binary archive when build is successful.

        \item[\ddash{}standalone] Create a standalone source archive

	\item[-l | \ddash{}log:{[}yes|no|on-failure{]}] Control the log level to display. The default is \code{on-failure} which displays the command log only in case of failure.

	\item[-f | \ddash{}force] Do not check if build id is matching, force a rebuild.

	\item[-p | \ddash{}purge{[:only]}] Remove module build directory, then if \code{only} is not specified build the module. The simple \code{-p} option corresponds on \code{--purge}.

	\item[\ddash{}shell:{[}dev|sandbox|sb{]}] Start a shell (\code{\$SHELL}) with the environment variables set. This is meant to be used to build or test in the very same environment used by SCBI while building the given module on the command line.

	\begin{description}[font=\texttt]
		\item[sandbox] Specifying \code{sandbox} or \code{sb} move the shell working directory into the module's build directory sandbox. This mode is meant to debug (or test some other options) the build of the given module. Not only the environment is setup from all dependencies but also the build environment of the specified module is setup. That is, in this mode the environment is exactly the one SCBI sees when starting the configuration, build or install steps.

		\item[dev] Specifying \code{dev} move the shell working directory into the module user's checkout. Alternatively one can specify the module's version \code{dev} instead.

		\item[no sub-option] The shell stays in the current working directory and setup the environment for the module to be used by another one. That is the given module is a dependency (and all dependents modules recursively) for the work to be done.
	\end{description}

	\item[\ddash{}run:"command args..."] Run the given command with the module's environment variables set. This is meant to be used to run a command which is depending on some libraries or binaries that are in the sandbox.

	\item[\ddash{}list-depends:{[}direct|full{]}] Recursively list module's dependencies. Either list all dependencies recursively (the default) or only the direct dependencies of the given module.

	\item[\ddash{}list-externals:{[}only{]}] Recursively list externals and modules dependencies. If sub-option \code{only} is specified it only displays the externals.

	\item[\ddash{}list-no-version] Do not display modules or externals versions.

	\item[\ddash{}list-filter:{[}all|run|dev{]} ] Restrict the listing of dependencies or externals to either \code{all} (default) dependencies, the \code{dev} dependencies needed to build the software or the \code{run} dependencies needed to execute the software. Those last dependencies may be computed automatically from the \code{dev} dependencies listed in plugin modules.

	\item[\ddash{}list-plan] List the final build plan that will be used. This is after loading main plan, inheriting from other plan \code{@load} and resolving the command line modules specification.

	\item[\ddash{}module-version] Display module's version given in the command line or in the build plan.

	\item[\ddash{}dry-run] Only list modules to be handled.

	\item[\ddash{}stat:{[}full{]}] Display some statistics about of current setup. With sub-option full also gives stats about module's build time.

	\item[-n | \ddash{}no-patch] Do not apply patches.

	\item[-j | \ddash{}jobs=<n>] Max compilation jobs, set variable \code{SCBI\_JOBS} which can be used in module scripts. (\seeref{njobs}).

	\item[\ddash{}safe] Build in safe mode. If a module needs to be built the previous build directory is removed. This ensures that the old configuration and/or build artifacts won't interact in any way with new build.

	\item[\ddash{}plugins=<directory>] Specify a non default location for the modules and plug-ins directory. This overrides the \code{SCBI\_DEFS} environment.

	\item[\ddash{}store KEY <VALUE>] Set or retrieve private information based on KEY, VALUE pair. (\seeref{private store})

\end{description}

A completion support for bash is provided. If activated many options will give hints about possible values like listing plans for \code{\ddash{}plan=} option or listing the supported modules.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% SECTION

\section{Creating new plug-ins}

To create a new plug-in for SCBI you need to create a single \code{bash} script (one per module) into \code{\$SCBI\_DEFS} and named as the plug-in.

The plug-in script describes, using different hooks, the steps for building. One for configuring, one for building and one for installing. These are the mains steps generally used to build all software.

The different steps are described by a simple \code{bash} code snippet. And some hooks are just descriptions to retrieve artifacts (like VCS sources or tar file).

In the following section all the supported hooks are described. Then the calling order conducted by SCBI is described.

\subsection{Hooks}

The hooks must be prefixed by the name of the plug-in. Each of them are optional.

\subsubsection{Description}

\begin{description}[font=\large\texttt]

	\item[<module>-vcs] \index{hook!vcs}Describe the module source VCS.
	\begin{description}[font=\textit,style=standard]
		\item[parameter] \tabto{2cm} NONE
		\item[return] \tabto{2cm} array
		\begin{enumerate}
			\item proxy : name of a proxy, or \emph{default} to use default system one. (\seeref{proxy}).
			\item options : comma separated list of options, possible values are \emph{none}, \emph{no-recursive}
			\item protocol : \emph{git}, \emph{svn}, \emph{hg}
			\item URL : repository location with protocol
			\item DIR (optional): name of the directory if the repository is hosting multiple projects. This is mostly needed for Subversion non standard repository layout. If \code{URL} is pointing to the tree when \code{trunk}, \code{branches} and \code{tags} directories are found, then SCBI will check for the actual sources in \code{<root>/trunk/\$DIR} or \code{<root>/branches/<VER>/\$DIR} for example.
		\end{enumerate}
	\end{description}

	Example:
	\begin{lstlisting}
	function lcms2-vcs()
	{
		echo default
		echo none
		echo git
		echo http://github.com/mm2/Little-CMS
	}
	\end{lstlisting}

	It is possible specify a specific \code{vcs} hook in an environment file by two means:

	\begin{description}[style=standard]
		\item[\code{SCBI\_<module>\_VCS\_VARIANT}] \hfill \\
		If environment variable \code{SCBI\_<module>\_VCS\_VARIANT} is set then the hook \\ \code{<module>-\$\{SCBI\_<module>\_VCS\_VARIANT\}-vcs} is looked for before the generic \code{<module>-vcs}. This is specific to module name \code{<module>}.

		\item[\code{SCBI\_VCS\_VARIANT}] Same as above for the all modules.
	\end{description}

	And finally the function \code{scbi-rewrite-vcs} can be defined. This function takes the five values returned by the \code{vcs} hook and must return the five values in the same order but possibly rewritten.

	\item[<module>-tar] \index{hook!tar}Describe the tar filename and location of the tar containing the module sources.
	\begin{description}[font=\textit,style=standard]
		\item[parameter] \tabto{2cm} \code{\$VERSION}
		\item[return] \tabto{2cm} array
		\begin{enumerate}
		\item proxy : name of a proxy, or \emph{default} to use default system one. (\seeref{proxy}).
		\item options : comma separated list of options to be used on the command line for the tool used (see protocol below). Use \emph{none} if no option are needed.
		\item protocol: \emph{scp}, \emph{cp}, \emph{wget}, \emph{curl}, \emph{none}.
		\item URL: location where the tarball can be downloaded.
		\item filename : name of the archive with a possible \$VERSION in the pattern.
		\end{enumerate}
	\end{description}

	Example:
	\begin{lstlisting}
	function cmake-tar()
	{
		local VERSION=$1

		echo default
		echo --no-check-certificate
		echo wget
		echo http://some.server.fr/sources
		echo cmake-$VERSION.tar.gz
	}
	\end{lstlisting}

	It is possible specify a specific \code{tar} hook in an environment file by two means:

	\begin{description}[style=standard]
		\item[\code{SCBI\_<module>\_TAR\_VARIANT}] \hfill \\
		If environment variable \code{SCBI\_<module>\_TAR\_VARIANT} is set then the hook \\ \code{<module>-\$\{SCBI\_<module>\_TAR\_VARIANT\}-tar} is looked for before the generic \code{<module>-tar}. This is specific to module name \code{<module>}.

		\item[\code{SCBI\_TAR\_VARIANT}] Same as above for the all modules.
	\end{description}

	And finally the function \code{scbi-rewrite-tar} can be defined. This function takes the four values returned by the \code{tar} hook and must return the four values in the same order but possibly rewritten.

	\item[<module>-patches] \index{hook!patches}Returns the patch files to apply. REF is the actual module version making it possible to apply a patch selectively.

	\begin{description}[font=\textit,style=standard]
		\item[parameter] \tabto{2cm} \code{\$PREFIX \$TARGET \$VARIANT \$KIND \$REF}
		\item[return] \tabto{2cm} array
		\begin{enumerate}
			\item echo <patch-file-1>
			\item echo <patch-file-2>
			\item {[}{[} \$REF =\textasciitilde "7.8" {]}{]} \&\& echo <patch-for-7.8>
			\item ...
		\end{enumerate}
	\end{description}

	\item[<module>-version] \index{hook!version}Returns the current version of the installed module.
	\begin{description}[font=\textit,style=standard]
		\item[parameter] \tabto{2cm} \code{\$PREFIX \$TARGET \$VARIANT}
		\item[return] \tabto{2cm} version or \code{\$VERSION\_OK} or \code{\$VERSION\_ERROR}
		\begin{enumerate}
			\item the version as a string corresponding to the current installed version. Can be \$VERSION\_OK or \$VERSION\_ERROR if the actual version cannot be determined.
		\end{enumerate}
	\end{description}

	\item[<module>-{[}common|<variant>{]}-build-depends] \index{hook!build-depends}Lists all modules required to build the actual module. These are generally some tools like \code{cmake}, \code{swig} or \code{gcc} which are only needed to build but not needed at runtime. A dependent module can be specified as a full module-reference (\seeref{modref}) so with variant and/or version even if this is a generally a bad idea. To keep the module generic it is better to use the simple module name here and have a build-plan to specify a specific version and/or variant.

	\begin{description}[font=\textit,style=standard]
		\item[parameter] \tabto{2cm} \code{\$PREFIX \$TARGET \$VARIANT}
		\item[return] \tabto{2cm} array
		\begin{enumerate}
			\item echo <module1>
			\item echo <module2>
			\item ...
		\end{enumerate}
	\end{description}

	Example:
	\begin{lstlisting}
	function aws-build-depends()
	{
		echo gnat
	}
	\end{lstlisting}

	\item[<module>-{[}common|<variant>{]}-depends] \index{hook!depends}Lists all modules required to build the actual module and to use/execute it. These are either other modules handled by SCBI or distribution packages. A dependent module can be specified as a full module-reference (\seeref{modref}) so with variant and/or version even if this is a generally a bad idea. To keep the module generic it is better to use the simple module name here and have a build-plan to specify a specific version and/or variant.

	\begin{description}[font=\textit,style=standard]
		\item[parameter] \tabto{2cm} \code{\$PREFIX \$TARGET \$VARIANT}
		\item[return] \tabto{2cm} array
		\begin{enumerate}
			\item echo <module1>
			\item echo <module2>
			\item ...
		\end{enumerate}
	\end{description}

	Example:
	\begin{lstlisting}
	function aws-depends()
	{
		echo xmlada
		echo asis
	}
	\end{lstlisting}

	\item[<module>-{[}common|<variant>{]}-env] \index{hook!env}Set the environment to use this module as a dependency. This is the exported environment. The know how to set the environment using the helper routines \seeref{set-env}.
	\begin{description}[font=\textit,style=standard]
		\item[parameter] \tabto{2cm} \code{\$PREFIX \$TARGET \$VARIANT}
		\begin{enumerate}
			\item \code{add-to-var} <name> <value>
			\item ...
		\end{enumerate}
		\item[return] \tabto{2cm} NONE
	\end{description}

	Example:
	\begin{lstlisting}
	function libgegl-env()
	{
		local PREFIX=$1
		local TARGET=$2

		add-to-var PKG_CONFIG_PATH $PREFIX/lib/pkgconfig
		add-to-var PATH            $PREFIX/bin
	}
	\end{lstlisting}

	\item[<module>-{[}common|<variant>{]}-build-env] \index{hook!build-env}Set the environment needed to build this module.
	Those settings are not exported and only visible and used for the module.
	\begin{description}[font=\textit,style=standard]
		\item[parameter] \tabto{2cm} \code{\$PREFIX \$TARGET \$VARIANT}
		\begin{enumerate}
			\item export <name>=<value>
			\item ...
		\end{enumerate}
		\item[return] \tabto{2cm} NONE
	\end{description}

	\item[<module>-setup] \index{hook!setup}To put in place the sources just before configuration step. This is generally not needed as the sources are setup by \code{scbi} using the information provided by the tar or vcs hook. This may be needed in some complex case or if the sources are generated based on the running environment.
	\begin{description}[font=\textit,style=standard]
		\item[parameter] \tabto{2cm} \code{\$PREFIX \$TARGET \$VARIANT}
		\item[return] \tabto{2cm} NONE
	\end{description}

	\item[<module>-out-of-tree] \index{hook!out-of-tree}Whether to build out of the source tree or not.
	\begin{description}[font=\textit,style=standard]
		\item[parameter] \tabto{2cm} \code{\$PREFIX \$TARGET \$VARIANT}
		\item[return] \tabto{2cm} \code{true | false}
	\end{description}

	Example:
	\begin{lstlisting}
	function lcms2-out-of-tree()
	{
		echo false
	}
	\end{lstlisting}

	\item[<module>-config] \index{hook!config}To configure the sources before starting the build. This is generally a call to GNU \code{configure} or \code{cmake}. The source tree is always accessible as \code{../src}.
	\begin{description}[font=\textit,style=standard]
		\item[parameter] \tabto{2cm} \code{\$PREFIX \$TARGET \$VARIANT}
		\begin{enumerate}
			\item ./configure \ddash{}prefix=\$PREFIX ../src
		\end{enumerate}
		\item[return] \tabto{2cm} NONE
	\end{description}

	\item[<module>-{[}common|<variant>{]}-config-options] \index{hook!config-options}Returns a list of options for the configuration step. The config (see above) hook is then supposed to be using the \code{get-config-options} routine to get the options to pass to the configuration tools like \code{cmake} or \code{configure} (\seeref{get config options}).
	\begin{description}[font=\textit,style=standard]
		\item[parameter] \tabto{2cm} \code{\$PREFIX \$TARGET [\$VARIANT]}
		\item[return] \tabto{2cm} array
		\begin{enumerate}
			\item echo <option1>
			\item echo <option2>
			\item ...
		\end{enumerate}
	\end{description}

	\item[<module>-build] \index{hook!build}The command to build the application. This is most of the case a simple call to \code{make}.
	\begin{description}[font=\textit,style=standard]
		\item[parameter] \tabto{2cm} \code{\$PREFIX \$TARGET \$VARIANT}
		\begin{enumerate}
			\item make
		\end{enumerate}
		\item[return] \tabto{2cm} NONE
	\end{description}

	Example:
	\begin{lstlisting}
	function lcms2-build()
	{
		local PREFIX=$1
		local TARGET=$2

		make -J$SCBI_JOBS
	}
	\end{lstlisting}

	\item[<module>-install] \index{hook!install}The command to install the application. This is most of the case a simple call to \code{make} with target \code{install}.
	\begin{description}[font=\textit,style=standard]
		\item[parameter] \tabto{2cm} \code{\$PREFIX \$TARGET \$VARIANT}
		\begin{enumerate}
			\item make install
		\end{enumerate}
		\item[return] \tabto{2cm} NONE
	\end{description}

	\item[<module>-wrapup] \index{hook!wrapup}This is to do whatever is needed after the installation step.
	\begin{description}[font=\textit,style=standard]
		\item[parameter] \tabto{2cm} \code{\$PREFIX \$TARGET \$VARIANT}
		\item[return] \tabto{2cm} NONE
	\end{description}

	\item[<module>-prefix] \index{hook!prefix}The directory for the installation of the module. The returned value can be set to NONE to skip the installation step. If this hook is not defined the module will be installed into \code{\$SCBI\_PREFIX}.
	\label{global-install}
	\begin{description}[font=\textit,style=standard]
		\item[parameter] \tabto{2cm} \code{\$PREFIX \$TARGET \$VARIANT}
		\item[return] \tabto{2cm} string
		\begin{enumerate}
			\item echo <install\_dir>
			\\ or
			\item echo NONE
		\end{enumerate}
	\end{description}

	\item[<module>-tests] \index{hook!tests}Set of commands to run the tests.
	\begin{description}[font=\textit,style=standard]
		\item[parameter] \tabto{2cm} \code{\$PREFIX \$TARGET \$VARIANT}
		\item[return] \tabto{2cm} NONE
	\end{description}

\end{description}

\subsubsection{Calling order}
\index{hook!calling order}

Some of the hooks are called by the main SCBI driver when needed as they are returning information of some artifacts. Those hooks do not have specific calling order:

\begin{itemize}
	\item vcs
	\item tar
	\item version
	\item out-of-tree
	\item prefix
	\item env
	\item build-env
	\item depends
	\item build-depends
\end{itemize}

For all other hooks there is a specific calling order which is:

\begin{enumerate}
	\item setup
	\item config
	\item build
	\item install
	\item wrapup
\end{enumerate}

It must be noted that for those steps we have generic internal version and \code{pre}, \code{post} corresponding steps:

\begin{description}[font=\texttt,style=nextline]
	\item[module-pre-<step>] \index{hook!pre-}The generic pre step handled internally by scbi driver. Must not be redefined.
	\item[<module>-pre-<step>] The pre step action done before the main step.
	\item[<module>-<step>] The default step.
	\item[module-<step>] The generic step handled internally. Must not be redefined.
	\item[<module>-post-<step>] \index{hook!post-}The post step action.
	\item[module-post-<step>] The generic post step handled internally. Must not be redefined.
\end{description}

For example, the generic internal setup step (\code{module-setup}) is used by the scbi driver to setup the sources (creating the build environment and populating the proper sources to compile) using the \code{vcs}, \code{version}, \code{tar} and \code{out-of-tree} hooks.

The \code{depends}, \code{build-depends}, \code{env}, \code{build-env} and \code{config-options} can have a \code{common} variant which is cumulative with the corresponding variant hooks or with the default hook. If a variant hook is present then the default hook is not called (we stop at the first \code{<variant>} call below:

\begin{enumerate}
	\item <module>-common-cross-<step>
	\item <module>-<variant>-cross-<step>
	\item <module>-cross-<step>
	\item <module>-common-<step>
	\item <module>-<variant>-<step>
	\item <module>-<step>
\end{enumerate}

The \code{cross} hooks are used when the target is different than the host.
\index{hook!cross}

For all other hooks there is no \code{common} variant. Again if a variant hook is present the default hook is not called (we stop at the first \code{<variant>} call below:

\begin{enumerate}
	\item <module>-<variant>-cross-<step>
	\item <module>-cross-<step>
	\item <module>-<variant>-<step>
	\item <module>-<step>
\end{enumerate}

\subsection{Meta-module}
\label{meta-module}
\index{meta-module}

A meta-module is a module listing a set of modules to build. This can be used to aggregate some related modules that are generally built together but not depending on each others.

Other modules can depend on a meta-module.

A module defining the hook \code{<module>-modules} becomes a meta-module.

\begin{description}[style=nextline]
	\item[<module>-modules] \index{hook!modules}Lists the aggregated modules.
		\begin{description}[font=\textit,style=standard]
			\item[parameter] \tabto{2cm} \code{\$PREFIX \$TARGET [\$VARIANT]}
			\item[return] \tabto{2cm} array
				\begin{enumerate}
					\item echo <module1>
					\item echo <module2>
		\end{enumerate}
	\end{description}
\end{description}

And can list a build-plan to use for building all listed modules:

\begin{description}
	\item[<module>-plan] \index{hook!plan}Returns the build-plan to use.
	\begin{description}[font=\textit,style=standard]
		\item[parameter] \tabto{2cm} NONE
		\item[return] \tabto{2cm} string
		\begin{enumerate}
			\item echo <plan-name>
		\end{enumerate}
	\end{description}
\end{description}

Example:

\begin{lstlisting}
 function gnatcoll-plan()
 {
		echo stable
 }

 function gnatcoll-modules()
 {
		echo gnatcoll-core gnatcoll-bindings gnatcoll-db
 }
\end{lstlisting}

A module listed in a meta-module can itself be a meta-module. A meta-module can define only a limited set of hooks, that is:

\begin{itemize}[font=\texttt]
	\item {[variant]-setup}
	\item {[variant]-build-depends}
	\item {[variant]-plan}
	\item {[variant]-modules}
	\item {[variant]-prefix}
	\item {[variant]-wrapup}
\end{itemize}

\subsection{Setting environment}
\label{set-env}
\index{variable!add}
\index{variable!set}
\index{variable!prepend}
\index{variable!append}
\index{helpers!define-var}
\index{helpers!add-to-var}
\index{helpers!prepend-to-var}
\index{helpers!append-to-var}
\index{helpers!set-var}

The five helper routines are to be used to set environment variables in \code{env} and \code{build-env} hook. They permit a fine control about the way the variables are set and avoid duplicate values.

\begin{description}[style=nextline]
	\item[define-var {[PREPEND|APPEND|ADD|SET]} <VARIABLE> <VALUE>] Prepend, append, add or set a variable depending on the first action parameter. Note that a single character action is supported as alias.
	\begin{description}
		\item[PREPEND | P] Prepend \code{<VALUE>} in \code{<VARIABLE>}, remove previous value if it exists. This ensures that the value is found after the current ones if needed.
		\item[APPEND | A] Append \code{<VALUE>} in \code{<VARIABLE>}, remove previous value if it exists. This ensures that the value is found before the current ones.
		\item[ADD] Add \code{<VALUE>} in \code{<VARIABLE>} if it is not already present. The place of the value in the variable is not important, it may be at the start, middle or end.
		\item[SET | S] Set \code{<VARIABLE>} to \code{<VALUE>} removing all previous values. After this call we always have a single value set.
	\end{description}

	\item[prepend-to-var <VARIABLE> <VALUE>] short hand for \code{define-variable PREPEND <VARIABLE> <VALUE>}.
	\item[append-to-var <VARIABLE> <VALUE>] short hand for \code{define-variable APPEND <VARIABLE> <VALUE>}.
	\item[add-to-var <VARIABLE> <VALUE>] short hand for \code{define-variable ADD <VARIABLE> <VALUE>}.
	\item[set-var <VARIABLE> <VALUE>] short hand for \code{define-variable SET <VARIABLE> <VALUE>}.
\end{description}

Example:

\begin{lstlisting}
	function mymodule-build-env()
	{
		set-var MYMODULE_USE_CLANG no
	}

	function mymodule-env()
	{
		add-to-var      CMAKE_PREFIX_PATH /some/path
		preprend-to-var PATH              /priority/dir/bin
	}
\end{lstlisting}

\subsection{Setting a proxy}
\label{proxy}
\index{proxy}

When a Web protocol is used to retrieve a tar archive with the sources or a VCS it may be necessary to pass through a proxy. In the tar and vcs hook description the name of a proxy can be given. This name corresponds to a bash function named \code{proxy-<name>} that is used to set the proxy.

\begin{description}[style=nextline]
	\item[proxy-<name>] Set a proxy.
	\begin{description}[font=\textit,style=standard]
		\item[parameter] \tabto{2cm} NONE
		\item[return] \tabto{2cm} NONE
		\begin{enumerate}
			\item export https\_proxy=...
		\end{enumerate}
	\end{description}
\end{description}

A typical setting is:

\begin{lstlisting}
 function proxy-enterprise()
 {
    export http_proxy=http:/myproxy.org:3128
    export https_proxy=http:/myproxy.org:3128
    export ftp_proxy=http:/myproxy.org:3128
    export no_proxy=localhost,.net
 }
\end{lstlisting}

This routine can be set into the environment file (\seeref{build-env}) or in the meta-module (\seeref{meta-module})description depending on use cases.

Also, note that this setting will be available only during the download of the archive file or the VCS and won't be polluting other module download not requiring a proxy.

\subsection{Feature}
\label{enable-feature}
\index{feature}\index{helpers!is-enabled}\index{is-enabled}

It is possible to enable a feature that can be checked in the plug-ins using the command line \code{\ddash{}enable-<name>}. This option activate the feature named \code{name}. This is a convenience function and it is up to the user to decide about the semantic of the enabled feature. For SCBI driver this is only a flag set or not.

In the module plug-ins the feature can be checked with \code{is-enabled} function:

\code{is-enabled <name> [then-value] [else-value]}

This function set the return code to 0 (true) if activated and returns \code{yes} by default or \code{then-value} if set. If the feature is not activated the function set the return code to 1 (as for errors) and returns the empty string by default or \code{else-value} if set.

Some example, for a single feature check:

\begin{lstlisting}
 if [[ $(is-enabled installer) ]]; then
\end{lstlisting}

For checking two features:

\begin{lstlisting}
 if [[ "$(is-enabled appli)" = "yes" ]] \
       || [[ "$(is-enabled installer)" = "yes" ]];
 then
\end{lstlisting}

Or setting a specific compiler option, example of a \code{config-options} hook:

\begin{lstlisting}
 echo -DCMAKE_CXX_FLAGS="-march=$(is-enabled safe-arch x86_64 native)"
\end{lstlisting}

\subsection{Build kind}
\index{helpers!get-build-type} \index{build kind}

One of the most generic build variant that must be handled is the \code{Release} vs \code{Debug} one. To support this more easily without requiring to create a specific variant hook there is a simple support using the function \code{get-build-type}:

\cmd{get-build-type <config> <default>}

The \code{<config>} represents the configuration tool (CMAKE or CONFIGURE for example). But it can be whatever string.

This function will return the build-kind for the calling module and system type (\code{cmake} or \code{configure}) and if not specified the default value is returned.

The actual build kind for the given module can be set using some environment variables in the following order:

\begin{description}[style=nextline]
	\item [SCBI\_<module>\_BUILD\_TYPE] Build kind for this specific module.
	\item [SCBI\_<CONFIG>\_BUILD\_TYPE] Build kind for the builder kind.
\end{description}

And then this can be used in the \code{config} hook simply with:

\begin{lstlisting}
  function lcms2-config()
  {
    local PREFIX=$1
    local TARGET=$1

    local BUILD_TYPE=$(get-build-type CMAKE Release)

    cmake -DCMAKE_INSTALL_PREFIX=$PREFIX \
          -DCMAKE_BUILD_TYPE=$BUILD_TYPE \
          ../src
  }
\end{lstlisting}

With the above example, if no variables are set in the environment to set the build type the default \code{Release} will be used. To force a \code{Debug} build one can set in the environment file or in the current shell:

\begin{lstlisting}
 export SCBI_CMAKE_BUILD_TYPE=Debug
\end{lstlisting}

Which will force a \code{Debug} build for all modules using \code{cmake}, or:

\begin{lstlisting}
 export SCBI_lcms2_BUILD_TYPE=Debug
\end{lstlisting}

With will force a \code{Debug} build for the \code{lcms2} module only. In both cases, the corresponding module must have been coded to use the \code{get-build-type} routine as seen above. Note that the \code{export} must use \emph{underscores} instead of dashes in module name as dashes are forbidden in variable name.

\subsection{Checking installed tools}
\index{helpers!check-tool}\index{check-tool}

It may be needed to check for the existence of a tool installed on the machine. It may not be a direct dependency but a tool needed for a specific need. For example the need to have \code{makeself} installed to create a self installer.

Two helper routines are provided for this:

\begin{description}
	\item[check-tool] Take the name of a tool as parameter, returns status code different than 0 if not found.

	\begin{description}[font=\textit,style=standard]
		\item[parameter] \tabto{2cm} tool-name
		\item[return] \tabto{2cm} NONE
	\end{description}

	Example:
	\begin{lstlisting}
	check-tool makeself
	if [ $? != 0 ]; then
	   echo Required tool makeself missing
	   exit 1
	fi
	\end{lstlisting}

	\item[check-tools] Take a list of tools as parameter, returns status code different that 0 if not found.

	\begin{description}[font=\textit,style=standard]
		\item[parameter] \tabto{2cm} tool-name1 [tool-name2...]
		\item[return] \tabto{2cm} NONE
	\end{description}

	Example:
	\begin{lstlisting}
	check-tool wget rsync
	if [ $? != 0 ]; then
		echo Required tools wget and/or rsync missing
		exit 1
	fi
	\end{lstlisting}
\end{description}

\subsection{Inheritance}
\label{inheritance}
\index{inheritance}\index{inherit-plugin}\index{helpers!inherit-plugin}

It is possible to create a plug-in module by inheriting from the definition
of another module. To do this the first line on the module should be:

\begin{lstlisting}
	inherit-plugin <name>
\end{lstlisting}

The \code{<name>} above is the name of an existing module from which we want
to inherit all the current hooks.

After this line it is possible to redefine any hook as it would be done
without inheritance. This may be handy if a module need to redefine only
the \code{vcs} or \code{proxy} hook for a specific context.

\subsection{Native variant}
\label{native variant}
\index{native variant}\index{variant!native}
\index{with-variant}\index{helpers!with-variant}

For a plug-in it is sometimes needed to have a native variant to use the OS libraries instead of building from sources. It is possible to do so by creating the variant hooks manually. All hooks must be nop action except the \code{depends} hooks which may list the OS libraries and possible the \code{env} hook which may need to define some environment variables.

The support routine \code{with-variant} can be used to automate this action:

\begin{lstlisting}
with-variant native [<packages>|NONE] \
	--env 'cmd1 'cmd2'
\end{lstlisting}

The first parameter is the variant name. The followings are the OS package names or \code{NONE}. An optional environment section can be opened with \code{\ddash{}env}. The value \code{NONE} will create an empty \code{depends} hook and can be used if the actual OS dependency has been installed manually on the machine. A possible reason is that the library has not been packaged by the OS maintainers.

For example:

\begin{lstlisting}
with-variant native pckA pckB \
	--env 'set-var ROOT_DIR /usr'
\end{lstlisting}

The command above will automatically create the following hooks when called from \file{natv} module script:

\begin{lstlisting}
function natv-native-build-env ()
{
	true
}

function natv-native-env ()
{
	set-var ROOT_DIR /usr
}

function natv-native-build-depends ()
{
	true
}

function natv-native-depends ()
{
	echo pckA
	echo pckB
}

function natv-native-config ()
{
	true
}

function natv-native-build ()
{
	true
}

function natv-native-install ()
{
	true
}

function natv-native-prefix ()
{
	echo NONE
}
\end{lstlisting}

\subsection{Calling variant hooks}
\label{call variant hooks}
\index{call-variant-hooks}\index{helpers!call-variant-hooks}

The support routine \code{call-variant-hook} can be used to call a set of hook in a module based on the variants.

\begin{lstlisting}
call-variant-hooks hname $PREFIX $TARGET $VARIANT
\end{lstlisting}

Will call all hooks in the current plug-in (<plugin>) named:

\begin{lstlisting}
   <plugin>-<variant>-hname
\end{lstlisting}

Where \code{<variant>} is all possible values found in \code{\$VARIANT}.

\subsection{Getting configuration options}
\label{get config options}
\index{get-config-options}\index{helpers!get-config-options}

It is often needed to set configuration options based on the variant we want to build. This is for example to activate an external module.

\begin{lstlisting}
	get-config-options $PREFIX $TARGET $VARIANT
\end{lstlisting}

Will call all hooks in the current plug-in (<plugin>) named:

\begin{lstlisting}
	<plugin>-common-config-options
	<plugin>-<variant>-config-options
\end{lstlisting}

The \code{common} hook is designed to contain all the common options to be used regardless of the selected variant.

For example:

\begin{lstlisting}
function mod-mpi-config-options()
{
	echo -DMPI=ON
}

function mod-openmp-config-options()
{
	echo -DOpenMP=ON
}

function mod-common-config-options()
{
	echo -DPREFIX=/my/path
}

function mod-config()
{
	local PREFIX=$1
	local TARGET=$2
	local VARIANT=$3

	local OPTIONS="$(get-config-options /usr lin $VARIANT)"

	cmake $OPTIONS ../src
}
\end{lstlisting}

If the current module reference is \code{mod/mpi} the \code{cmake} command will be:

\begin{lstlisting}
	cmake -DPREFIX=/my/path -DMPI=ON ../src
\end{lstlisting}

And if the module reference is \code{mod/mpi.openmp} the \code{cmake} command will be:

\begin{lstlisting}
	cmake -DPREFIX=/my/path -DMPI=ON -DOpenMP=ON ../src
\end{lstlisting}

\subsubsection{Configuration options with spaces}
\label{config options spaces}

If an option has spaces in it, the split will not be correct. This is a common problem and the solution is not trivial.

\code{echo -DLINK\_LIBRARIES="-lmpi\_cxx -lmpi"}

Then the \code{OPTIONS} string as described above won't work because of the way the shell will split the option on spaces by default. And so the actual options passed to \code{cmake} will be:

\begin{itemize}
	\item -DLINK\_LIBRARIES="-lmpi\_cxx
	\item -lmpi
\end{itemize}

The solution is to use an array and modifying the field separator temporarily:

\begin{lstlisting}
function mod-config()
{
	local PREFIX=$1
	local TARGET=$2
	local VARIANT=$3

	IFS=$'\n'

	local OPTIONS=($(get-config-options /usr lin $VARIANT))

	cmake ${OPTIONS[*]} ../src

	unset IFS
}
\end{lstlisting}

\subsection{OS dependencies}
\label{OS dependencies}
\index{os dependencies}

The hook \code{depends} list dependencies to other plug-ins or external libraries/tools. As the name of the external dependency packages may be different depending on the Linux distribution and version it is possible to use an OS independent naming.

\begin{lstlisting}
	os@-<name>
\end{lstlisting}

The \code{os@-<name>} is then search against a table to find the corresponding OS package name.

A distribution acronym is represented by a 3 letters name (deb, ubt, rhl for example). See output of the \code{--stat} option for the currently supported distributions.

An alias table is searched into the following places and in this specific order:

\begin{enumerate}
	\item \code{.pkgs-<distrib>} into \$SCBI\_DEFS (default \file{~/.config/scbi})
	\item \code{.scbi-pkgs-<distrib>} into \$SCBI\_BDIR (build directory)
	\item \code{.scbi-pkgs-<distrib>} into \$PWD (current directory)
\end{enumerate}

In complement to the files searched based on distribution acronym, the major and minor version of the OS is also used.

For example on Debian 10.6 the searched files will be, and in that order:

\begin{enumerate}
	\item \code{.pkgs-deb}
	\item \code{.pkgs-deb-10}
	\item \code{.pkgs-deb-10-6}
\end{enumerate}

So \code{.pkgs-deb-10} can add new dependencies or override some dependencies that are set in \code{.pkgs-deb}.

\subsection{SCBI Private Store}
\label{private store}
\label{store}
\index{private store}

It is sometimes needed to use some private information (like software keys) to activate a module. Such information cannot be stored directly into a plug-in which could be made public. To cope with this specific case SCBI comes with support for storing pair of information into an external private store.

The option to set or retrieve a value is \ddash{}store.

\begin{itemize}
	\item On the command line:\\
	To set a key:

	\cmd{scbi --store LICKEY 89AXCDPPP6BGG}

	To get value associated with a key:

	\cmd{scbi --store LICKEY}

	\item Inside a plug-in script:\\
	To set a key:

	\hspace{1.5cm}\texttt{scbi-store-set-key LICKEY 89AXCDPPP6BGG}

	To get value associated with a key:

	\hspace{1.5cm}\texttt{scbi-store-get-key LICKEY}
\end{itemize}

All keys are stored into the file \file{$SCBI_PLUGINS/.store} (if using the default environment \file{$HOME/.config/scbi/.store}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% SECTION

\section{Completion support}
\label{completion}
\index{completion}

A script is provided to support bash completion for scbi. The script is \file{bash_completion.d/scbi} and must be copied into \file{/etc/bash_completion.d/} OS directory.

Note that for this to work, the bash completion package must be installed, on Debian based distributions this is achieved with:

\cmd{apt install bash-completion}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% SECTION

\section{Use Cases}

\subsection{User's checkout}
\label{userco}
\index{user's checkout}

This is certainly the most important use case. A complex software is built with SCBI, but a bug (due to configuration, build or dependencies) is found in one module. We need to debug this module and fix it, so the complete cycle would be:

\begin{itemize}
	\item Check-out the module
	\item Compile manually in debug mode
	\item Debug the application
	\item Fix the code
	\item Commit the changes
	\item Push, integrate the new changes (possibly in a new branch)
\end{itemize}

SCBI does support this scenario directly by allowing a user's checkout to be used instead of the sources in the sandbox. It is highly discouraged to modify the sources in the sandbox which should stay untouched by users. Beware, depending on the SCBI options, the modifications in the source may be overwritten, so lost.

The recommended steps are (we assume the current VCS for the module is Git):

\begin{description}[style=nextline]
	\item[Checkout the module] The user need to manually checkout the module. This can be done in any directory usually used to do development:

	\begin{shellcommand}
	\item cd \$HOME/dev
	\item git clone http://github.com/mm2/Little-CMS
	\end{shellcommand}

	\item[Setup SCBI enviroment] The variable SCBI\_GIT\_REPO must be modified to point to the directory containing the user's Git checkouts. This is done by creating a new environment file, for example \file{.env-debug} (\seeref{envfile}):

	\begin{shellcommand}
	\item export SCBI\_GIT\_REPO=\$HOME/dev
	\end{shellcommand}

	If the default value is used this step is not needed.

	\item[Create a build plan] The build plan will list all modules that must be compiled using a user's checkout. For example \file{.plan-debug}:

	\begin{lstlisting}
	lcms2:dev
	\end{lstlisting}

	Remember, \code{dev} is the special version referencing a user's checkout. (\seeref{dev}).

	\item[Modify the module's sources] As a standard development step we modify the sources in the local checkout to fix the issue:

	\begin{shellcommand}
	\item cd \$HOME/dev/Little-CMS
	\item emacs somefile.c
	\end{shellcommand}

\end{description}

When this is setup, building the new software (\code{Little-CMS} in this example) with a development check-out, one can just do:

\cmd{scbi \ddash{}env=debug \ddash{}plan=debug \ddash{}deps lcms2}

We can further simplify by adding the build-plan reference in the environment file \file{.env-debug}:

\begin{lstlisting}
	export SCBI_GIT_REPO=$HOME/dev
	SCBI_PLAN=debug
\end{lstlisting}

And then the new equivalent command line is:

\cmd{scbi \ddash{}env=debug \ddash{}deps lcms2}

If a single software with no dependencies are to be debugged it is possible to just call SCBI with a dev reference for the module. In this case there is no need to create an environment file nor a build-plan and we can simply call:

\cmd{scbi lcms2:dev}

Mercurial and Subversion VCS are also supported, the variables for each are:

\begin{description}[style=standard]
	\item[Git] \tabto{3cm} SCBI\_GIT\_REPO\index{user's checkout!SCBI\_GIT\_REPO}
	\item[Mercurial] \tabto{3cm} SCBI\_HG\_REPO\index{user's checkout!SCBI\_HG\_REPO}
	\item[Subversion] \tabto{3cm} SCBI\_SVN\_REPO\index{user's checkout!SCBI\_SVN\_REPO}
\end{description}

\subsection{Analyzing build failures}
\label{debugging}

When a build fails it may be needed to look at the full logs and the actual commands executed for the failing step (configure, build, install...).

\subsubsection{Replay one specific step}

It is possible to replay a single command and display the full log to analyze what went wrong:

\begin{description}
	\item[configuration] \tabto{3cm}  \cmd{scbi \ddash{}config \ddash{}log:yes lcms2}
	\item[build] \tabto{3cm} \cmd{scbi \ddash{}build \ddash{}log:yes lcms2}
\end{description}

The files to be edited are in the sandbox module's directory:

\file{$SCBI_BDIR/lcms2/build/src}

Then one of the configuration commands above can be restarted. \emph{When the fix is found it must be applied in the module's repository outside of the sandbox or it will be lost.}

Again, note that restarting an SCBI command without specifying a specific step (like \ddash{config} or \ddash{build}) will reset all sources from the reference repository in the sandbox.

\subsubsection{Look at the sandbox status}

The SCBI driver does record all needed information in the sandbox directory \file{<module>/build/.log/}.

The files created in this directory are:

\begin{description}[font=\file,style=standard]
	\item[env.cmd] \tabto{3cm} The environment set to configure, build or install the module.
	\item[config.cmd] \tabto{3cm} The commands executed to configure.
	\item[config.log] \tabto{3cm} The full log issued during the configuration.
	\item[build.cmd] \tabto{3cm} The commands executed to build.
	\item[build.log] \tabto{3cm} The full log issued during the build.
	\item[install.cmd] \tabto{3cm} The commands executed to install.
	\item[install.log] \tabto{3cm} The full log issued during the installation.
\end{description}

It is possible to replay the configure, build or install step just by sourcing the corresponding \code{.cmd} file.

As an example, the build command file for \code{cmake} looks like this:

\begin{lstlisting}
# cmake-build
(
	cd <...>/cmake/build/build
	source /some/path/.scbi-runtime
	[ -f ../.log/env.cmd ] && source ../.log/env.cmd

	function cmake-build()
	{
		local PREFIX=$1
		local TARGET=$2
		make -j24
	}

	cmake-build <...>/cmake/build/install x86_64-linux-gnu
)
\end{lstlisting}

Note that this script is executed in a sub-shell and so won't pollute the working bash shell environment.

Note also that the sources in the sandbox can be overwritten at any time. So the sources should not be edited directly on the sandbox. When the issue is found the recommended solution is to use a user's checkout, \seeref{userco}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% SECTION

\section{The Sandbox}

We describe in this section the sandbox structure. Yet, it is generally not needed to go inside this hierarchy of directories except for debugging a new module being written (\seeref{debugging}).

\vspace{1cm}

\dirtree{%
	.1 \textbf{[\$SCBI\_BDIR]}.
	.2 .vcs.
	.3 \textbf{[<module>]} \des{sources checkout}.
	.2 .patches.
	.2 .tar.
	.3 <module>-<version>-src.tar.gz.
	.2 \textbf{[.logs]} \des{global log directory with history}.
	.3 \textbf{[YYYY-MM-DD]}.
	.4 *.log.
	.2 \textbf{[<module>]}.
	.3 build $\rightarrow$ \des{symlink to current/latest target build dir}.
	.3 build-id-<variant> \des{build id to check for changes}.
	.3 src $\rightarrow$ \des{symlink to sources (vcs or tarball)}.
	.3 tar $\rightarrow$ \des{symlink to extracted tarball}.
	.3 tarsrc \des{extract of tarball}.
	.3 source-id \des{version of the source (tar or vcs)}.
	.3 install-<target>-id \des{version of the module installed globally}.
	.3 vcs $\rightarrow$ \des{symlink to repository (.vcs or user's checkout)}.
	.3 \textbf{[<target>-<variant>]}.
	.4 .log \des{commands \& output for each steps}.
	.4 \textbf{[build]} \des{build directory}.
	.4 build-id \des{sha1 to identify the build}.
	.4 \textbf{[install]} \des{installation directory}.
	.4 manifest \des{list of all files in install above}.
	.4 src \des{rsync of ../src}.
}

\section{Complete example}

Many scripts come with \code{scbi}, they are all good examples to learn about different features.

As a complete example here, let's build latest GIMP version. The plug-in module script is called \file{gimp} (placed into \file{$SCBI_PLUGINS/.config/scbi}) and all hook functions in this script are prefixed by \code{gimp-}.

Note that this was compiling at the time this doc was written, but some dependencies on the OS may required the script to be updated.

\begin{itemize}
	\item We describe the VCS, sources are handled in Git:

	\begin{lstlisting}
	function gimp-vcs()
	{
		echo default
		echo none
		echo git
		echo https://github.com/GNOME/gimp
	}
	\end{lstlisting}

	\item We won't build GIMP out-of-tree, that is the build will be done in the source directory:

	\begin{lstlisting}
	function gimp-out-of-tree()
	{
		echo false
	}
	\end{lstlisting}

	\item We list all dependencies, most of them are standard Debian packages except \code{libmypaint}, \code{libmypaint-brushes} and \code{libegl}.

	\begin{lstlisting}
	function gimp-depends()
	{
		local PREFIX=$1
		local TARGET=$2
		local VARIANT=$3

		echo gtk-doc-tools
		echo libbabl-dev
		echo libgegl-dev
		echo libgexiv2-dev
		echo libpoppler-glib-dev
		echo python-gtk2-dev
		echo python-cairo-dev
		echo mypaint
		echo libmng-dev
		echo libxpm-dev

		echo libmypaint
		echo mypaint-brushes
		echo libgegl
	}
	\end{lstlisting}

	\item We configure GIMP, note that the environment for the three dependent modules are set in the corresponding plug-in module:

	\begin{lstlisting}
	function gimp-config()
	{
		local PREFIX=$1
		local TARGET=$2
		local VARIANT=$3

		./autogen.sh --prefix=$PREFIX
	}
	\end{lstlisting}

	\item We build GIMP:

	\begin{lstlisting}
	function gimp-build()
	{
		local PREFIX=$1
		local TARGET=$2
		local VARIANT=$3

		make -j$SCBI_JOBS
	}
	\end{lstlisting}

	\item We install it, this is the installation into the sandbox install directory for this module:

	\begin{lstlisting}
	function gimp-install()
	{
		local PREFIX=$1
		local TARGET=$2
		local VARIANT=$3

		make install
	}
	\end{lstlisting}

	\item The global installation is set to point to \file{/opt/gimp}:

	\begin{lstlisting}
	function gimp-prefix()
	{
		echo /opt/gimp
	}
	\end{lstlisting}

\end{itemize}

As seen above, \code{gimp} module depends on three other modules and we do need some configuration from those dependencies during the configuration. The exported environment for the three dependencies are:

\begin{itemize}
	\item Hook \code{libmypaint-env}:

	\begin{lstlisting}
	function libmypaint-env()
	{
		local PREFIX=$1
		local TARGET=$2
		local VARIANT=$3

		add-to-var PKG_CONFIG_PATH \
					$PREFIX/lib/pkgconfig
	}
	\end{lstlisting}

	\item Hook \code{mypaint-brushes-env}:

	\begin{lstlisting}
	function mypaint-brushes-env()
	{
		local PREFIX=$1
		local TARGET=$2
		local VARIANT=$3

		add-to-var PKG_CONFIG_PATH \
					$PREFIX/share/pkgconfig
	}
	\end{lstlisting}

	\item Hook \code{libegl-env}:

	\begin{lstlisting}
	function libgegl-env()
	{
		local PREFIX=$1
		local TARGET=$2
		local VARIANT=$3

		add-to-var PKG_CONFIG_PATH \
					$PREFIX/lib/pkgconfig
		add-to-var PATH            \
					$PREFIX/bin
	}
	\end{lstlisting}

\end{itemize}

The full description for those three modules are provided with scbi.

For this version of GIMP we need specific versions of the dependencies. A build-plan \code{.plan-gimpdev} is used to describe this:

\begin{lstlisting}
 libmypaint:v1.3.0
 mypaint-brushes:v1.3.0
\end{lstlisting}

That is, we need version 1.3.0 of \code{libmypaint} and \code{mypaint-brushes}.

At this point we can build GIMP with a simple:

\cmd{scbi \ddash{}plan=gimpdev \ddash{}deps gimp}

\printindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% SECTION

\end{document}

%%% Local Variables:
%%% TeX-open-quote: "¬´ "
%%% TeX-close-quote: " ¬ª"
%%% time-stamp-start: "\\\\newcommand{\\\\timestamp}{"
%%% time-stamp-end: "}"
%%% time-stamp-format: "%02d/%02m/%04y"
%%% End:

% LocalWords:  typographi√©es PDF Eureka
