############################## module-setup

function module-setup()
{
    local PREFIX=$1
    local MODULE=$2
    local TARGET=$3
    local OOT=$4

    # if module-src soft link exists use it to copy the module sources into
    # the pointed location. This is used when multiple modules are used
    # together to create the set of source for the build. In this case we do
    # not want to delete sources in rsync.
    #
    # Note: we do exclude gcc-interface directory here to avoid overwriting
    #       the gcc-interface sources from GNAT.

    if [ -h module-src ]; then
        SRCDIR=module-src
        OPT=
    else
        SRCDIR=$TARGET/src
        OPT=--delete
    fi

    if [ -h src -o -d src ]; then
        rsync -a $OPT --exclude=".git" --exclude=".svn" \
            --exclude "*.o" --exclude "*.a" --exclude "*.dll" \
            --exclude "*.so" --exclude "*.so.*" --exclude "*.ali" \
            --exclude "gcc-interface" \
            --link-dest=../src src/. $SRCDIR/

    fi

    #  If some patches are present, apply them now
    if [ $PATCH == yes ]; then
        (
            cd $SRCDIR

            for patch in $(ls $PATCHES/$MODULE-*.patch | sort); do
	        ilog apply-patch filename $(basename $patch)
                patch -p1 < $patch
                [[ ! $? = 0 ]] && return 1
            done
            return 0
        )

        [[ ! $? = 0 ]] && return 1
    fi

    rm -f build/build build
    ln -s $TARGET build

    if [ "$OOT" = "yes" ]; then
        mkdir -p build/build
    else
        ln -s src build/build
    fi

    return 0
}

############################## module-purge

function module-purge()
{
    local PREFIX=$1
    local MODULE=$2
    local TARGET=$3
    local OOT=$3

    # note that we keep the module install directory to be sure that we
    # can clean-up the final install destination.

    if [ -d $PREFIX/$TARGET ]; then
        rm -fr $PREFIX/$TARGET/build
        rm -fr $PREFIX/$TARGET/build-id
        rm -fr $PREFIX/$TARGET/install
        rm -fr $PREFIX/$TARGET/src
        rm -fr $PREFIX/build-id
        rm -f $PREFIX/build
    fi
}

############################## module-pre-install

function module-pre-install()
{
    local MPREFIX=$1
    local MODULE=$2
    local TARGET=$3
    local OOT=$4

    #  Finaly copy to given prefix
    local SUDO=""
    local IDIR=""

    fn-exists $MODULE-prefix

    if [ $? = 0 -a "$DEFAULT_PREFIX" = "yes" ]; then
        IDIR=$($MODULE-prefix)
    else
        IDIR=$PREFIX
    fi

    if [ ! -w $IDIR ]; then
        SUDO=sudo
    fi

    # note that we do not want to fail here
    # delete files in the final destination installation prefix.
    # then delete the module install location (double check that the
    # directory is the right one).

    if [ -f $MPREFIX/../manifest ]; then
        cat $MPREFIX/../manifest | while read file; do
            $SUDO rm -f $IDIR/$file
        done &&
        if [ $(basename $MPREFIX) = "install" \
             -a $(basename $(dirname $MPREFIX)) = "$MODULE" ]; then
            cd $MPREFIX && rm -fr .
        fi
    fi
}

############################## module-install

function module-install()
{
    local PREFIX=$1
    local MODULE=$2
    local TARGET=$3
    local OOT=$4

    if [ ! -f build-id ]; then
        #  No build-id, this means that the sources have been installed by
        #  the <module>-setup most probably. In this case just compute the
        #  build-id to be the md5sum of all sources available in src directory.
        #  If this directory does not exists, let's build a md5sum of the
        #  current date/time as a build-id. In this case the build will always
        #  been triggered.

        if [ -d src ]; then
            vid=$(cat src/* | md5sum | cut -d' ' -f1)
            get-build-id $PREFIX $TARGET $MODULE $vid > build-id
        else
            echo -n $(date) | md5sum | cut -d' ' -f1 > build-id
        fi
    fi

    # get all installed files

    (
        cd ./build/install
        find . -type f > ../manifest
    )

    cp build-id build/
}
