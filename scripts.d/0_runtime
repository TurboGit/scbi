
shopt -s extglob

#  associative array given the status of a module, $SCBI_LOADED[$module] is
#  set to yes when module is loaded and $SCBI_LOADED[$module.$variant] is
#  set to meta (for a meta-module) / final (for a standard module).
declare -gA SCBI_LOADED

declare -gA SCBI_MODVER

# Note that the hooks must use a canonical order, this order is used
# by scbi-format sub-command.
declare -g SCBI_ALL_HOOKS="plan|vcs|archive|patches|version|only-explicit-build|out-of-tree|modules|aggregate|propagate-version|build-depends|tests-depends|depends|external-env|build-env|tests-env|env|setup|config-options|config|build|install|wrapup|prefix|tests|run"

############################## fn-exists
# check wether a function is defined

function fn-exists()
{
    declare -f $1 > /dev/null
}

############################## copy-fonction
# copy function $1 to $2

function copy-function()
{
    declare -F "$1" > /dev/null || return 1
    local func="$(declare -f "$1")"
    eval "${2}(${func#*\(}"
}

############################## get-caller

function get-caller()
{
    local -n CRESULT=$1
    local IDX=${2:-2}

    local NAME=${FUNCNAME[$IDX]}

    if [[ $NAME =~ -((pre|post)-)?(cross-)?(${SCBI_ALL_HOOKS})$ ]]; then
        CRESULT=${NAME%-${BASH_REMATCH[4]}}

        #  Check if last string after dash is a known variant, if so remove
        #  the variant from the name.

        local P=${CRESULT%-*}
        local S=${CRESULT##*-}

	#  keep only the variant, remove plug-in name and version
        local V=${SCBI_MODVER[$P]#*/}
        local V=${V%:*}

        local HASV=false
        has-variant "$V" $S || [[ $S == "default" ]] || [[ $S == "common" ]] &&
            HASV=true

        # The three conditions are:
        #  1. CRESULT is not a known module
        #  2. The suffix (after last dash) is not empty
        #  3. The suffix is a known variant for this module
        if [[ -z ${SCBI_MODVER[$CRESULT]} ]] &&
               [[ -n ${S} ]] &&
               [[ $HASV == true ]]
        then
            CRESULT=$P
        fi
    else
        CRESULT=$NAME
    fi
}

############################## get-config-options

function get-config-options()
{
    local -n RESULT=$1
    local PREFIX=$2
    local TARGET=$3
    local VARIANT=$4

    local PLUGIN=""
    get-caller PLUGIN

    local IFS=$'\n'
    RESULT=( $(plugin-call-variant-hooks $PLUGIN config-options \
                                         $PREFIX $TARGET $VARIANT) )
}

############################## is-enabled
# check wether a feature is enabled (see option --enable-<feature>)

function is-enabled()
{
    local FEAT=${1/-/_}
    local THEN=$2
    local ELSE=$3

    local VAR=SCBI_${FEAT}_SET

    if [[ -z ${!VAR} ]]; then
        #  Get the caller plug-in name
        local PLUGIN=""
        get-caller PLUGIN

        VAR_GENERIC=SCBI_${FEAT}_FEATURE
        VAR_MODULE=SCBI_${PLUGIN//-/_}_${FEAT}_FEATURE

        [[ -n ${!VAR_GENERIC} ]] && VAR=$VAR_GENERIC
        [[ -n ${!VAR_MODULE} ]] && VAR=$VAR_MODULE
    fi

    if [[ "${!VAR}" = "true" ]]; then
        if [[ -z $THEN ]]; then
            echo "yes"
        else
            echo $THEN
        fi
        return 0
    else
        if [[ -n $ELSE ]]; then
            echo $ELSE
        fi
        return 1
    fi
}

############################## get-hook-value

function get-hook-value()
{
    local -n RESULT=$1
    local MODULE=$2
    local VARIANT=$3
    local HOOK=$4

    local FCT=""
    get-hook FCT $MODULE $VARIANT $HOOK

    RESULT=""

    local TVDIR=""
    get-target-dir TVDIR $MODULE $VARIANT

    if [[ -n $FCT ]]; then
        RESULT=$($FCT $TVDIR/install $SCBI_TARGET $VARIANT)
    fi
}

############################## is-hook-true

function is-hook-true()
{
    local MODULE=$1
    local VARIANT=$2
    local HOOK=$3
    local DEFAULT=$4

    local VALUE=""
    get-hook-value VALUE $MODULE $VARIANT $HOOK

    VALUE=${VALUE:-$DEFAULT}
    VALUE=${VALUE^^}

    [[ ${VALUE} = "TRUE" ]] || [[ ${VALUE} == "YES" ]]
}

############################## last-modified-directory
# returns the newest (last modified) directory matching pattern

function last-modified-directory()
{
    local PATTERN="$1"

    ls -td $PATTERN 2> /dev/null | head -1
}

############################## check-os-file
# check for a specific file in a set of hint directories, return full pathname
#
# get-os-file <FILENAME> <PATH1> <PATH2> ...

function get-os-file()
{
    local FILENAME=$1
    shift

    while [[ -n "$1" ]]; do
        F="$1/$FILENAME"
        RES=$(ls $F 2>&1 > /dev/null)
        if [[ $? == 0 ]]; then
            FILENAME=$F
            break
        fi
        shift
    done

    echo $FILENAME
}

############################## get-os-lib
# check for a specific lib, return full pathname
#
# get-os-lib <FILENAME>

function get-os-lib()
{
    local F=$1
    local BN=${F##*/}

    local R=$(get-os-file "$F" \
                          "/usr/lib*/$SCBI_TARGET" \
                          "/usr/lib*/$SCBI_TARGET/*" \
                          "/usr/lib*" \
                          "/usr/lib*/*" \
                          "/usr/lib*/*/lib*")

    if [[ "$R" != "$F" ]] || [[ "$BN" == "$F" ]]; then
        echo $R
    else
        get-os-file "$BN" \
                    "/usr/lib*/$SCBI_TARGET" \
                    "/usr/lib*/$SCBI_TARGET/*" \
                    "/usr/lib*" \
                    "/usr/lib*/*" \
                    "/usr/lib*/*/lib*"
    fi
}

function get-os-lib-dir()
{
    local R=$(get-os-lib "$1")
    echo ${R%/*}
}

############################## get-os-inc
# check for a specific include, return full pathname
#
# get-os-inc <FILENAME>

function get-os-inc()
{
    local F=$1
    local BN=${F##*/}

    local R=$(get-os-file "$F" \
                          "/usr/include/$SCBI_TARGET" \
                          "/usr/include" \
                          "/usr/include/$SCBI_TARGET/*" \
                          "/usr/include/*")

    if [[ "$R" != "$F" ]] || [[ "$BN" == "$F" ]]; then
        echo $R
    else
        get-os-file "$BN" \
                    "/usr/include/$SCBI_TARGET" \
                    "/usr/include" \
                    "/usr/include/$SCBI_TARGET/*" \
                    "/usr/include*/*"
    fi
}

function get-os-inc-dir()
{
    local R=$(get-os-inc "$1")
    echo ${R%/*}
}

############################## get-os-bin
# check for a specific binary, return full pathname
#
# get-os-bin <FILENAME>

function get-os-bin()
{
    get-os-file "$1" \
                "/usr/bin*" "/usr/lib*/*/bin"
}

function get-os-bin-dir()
{
    local R=$(get-os-bin "$1")
    echo ${R%/*}
}

############################## split all variants
# returns all variants separated with spaces, usage:
#
# for v in $(all-variants $VARIANT); do
#    ...
# done

function all-variants()
{
    local VARIANTS=$1
    if [[ "$VARIANTS" != "default" ]]; then
        echo "${VARIANTS//./ }"
    fi
}

function all-variants-v()
{
    local -n RESULT=$1
    local VARIANTS=$2

    RESULT=()
    if [[ "$VARIANTS" != "default" ]]; then
        RESULT=( ${VARIANTS//./ } )
    fi
}

############################## has variant
# returns true if variants exists
#
#  if has-variant "v1.v2" v2; then
#     ...
#  fi

function has-variant()
{
    local VARIANTS=$1
    local VAR=$2

    local ALLVARS=()
    all-variants-v ALLVARS $VARIANTS

    for v in ${ALLVARS[*]}; do
        if [[ $v == $VAR ]]; then
            return 0
        fi
    done
    return 1
}

############################## load-module
#
# load an SCBI build script

function load-module()
{
    local MODREF=$1

    local module_info=()
    get-module-ref module_info $MODREF
    local module=${module_info[0]}
    local variant=${module_info[1]}

    local key="${module}.${variant}"

    if [[ -z "${SCBI_LOADED[$module]}" ]]; then
        if [[ -f $SCBI_PLUGINS/$module ]]; then
            source $SCBI_PLUGINS/$module
            SCBI_LOADED[$module]=yes
        elif [[ -n "${SCBI_MODULE_ALIAS[$module]}" ]]; then
            local MA=${SCBI_MODULE_ALIAS[$module]}

            if [[ -f $SCBI_PLUGINS/$MA ]]; then
                _inherit-plugin_internal no "" $MA $module
            else
                return 1
            fi
        else
            return 1
        fi
    fi

    if [[ -z "${SCBI_LOADED[$key]}" ]]; then
        local MODS=$(plugin-call-variant-hooks \
                         $module modules $SCBI_PREFIX $SCBI_TARGET $variant)

        if [[ -z $MODS ]]; then
            SCBI_LOADED[$key]=final
        else
            SCBI_LOADED[$key]=meta

            get-hook FCT $module $variant aggregate

            [[ -n $FCT ]] &&
                SCBI_LOADED[${key}.agg]=$($FCT $SCBI_PREFIX \
                                               $SCBI_TARGET $variant)
        fi
    fi

    return 0
}

############################## inherit-plugin

function _inherit-plugin_internal()
{
    local NOVARIANT=$1
    local SCBI_HOOKS=$2
    local HPLUGIN=$3
    local PLUGIN=$4

    #  All hooks if no filter
    [[ -z $SCBI_HOOKS ]] &&
        local SCBI_HOOKS="${SCBI_ALL_HOOKS}"

    load-module $HPLUGIN

    #  For each known & existing hook name, create a wrapper with the
    #  name of the caller plug-in.

    local REGEXP="$SCBI_HOOKS"

    [[ $NOVARIANT == yes ]] &&
        REGEXP="$HPLUGIN(-pre|-post|-cross)*-($SCBI_HOOKS)"

    while read hook; do
        [[ $hook =~ $REGEXP ]] &&
            {
                local NHOOK=${hook/$HPLUGIN/$PLUGIN}
                # Only copy of new function does not exists
                declare -F "$NHOOK" > /dev/null ||
                    copy-function $hook $NHOOK
            }
    done < <( compgen -A function "$HPLUGIN-" )
}

function inherit-plugin()
{
    local HPLUGIN=""
    local NOVARIANT=no
    local HOOKS=""

    #  Get the caller plug-in name, this is called when sourcing a plug-in
    #  we need to use Bash caller here and not get-caller.
    local CALLER=( $(caller) )
    local PLUGIN=${CALLER[1]##*/}
    local P=$PLUGIN
    local options=$(getopt -l no-variant,hooks:,name: -- dummy $*)

    eval set -- "$options"
    while true; do
        case "$1" in
            --no-variant)
                NOVARIANT=yes
                ;;
            --hooks)
                shift
                [[ -n $HOOKS ]] && HOOKS+="|"
                HOOKS+=$1
                ;;
            --name)
                shift
                PLUGIN=$1
                ;;
            --)
                shift
                HPLUGIN=$1
                break
                ;;
            -*)
                echo unknown option in $PLUGIN
                exit 1
                break
                ;;
        esac
        shift
    done

    SCBI_LOADED[${P}.inh]+="$HPLUGIN "

    _inherit-plugin_internal $NOVARIANT "${HOOKS//,/|}" $HPLUGIN $PLUGIN
}

############################## get-version

function get-version()
{
    #  Get the caller plug-in name
    local PLUGIN=""
    get-caller PLUGIN

    local module_info=()
    get-module-ref module_info $PLUGIN
    echo ${module_info[3]}
}

############################## parse-module-ref
#
# Returns an array with the following information:
# ( module ["default"|variant] [DEV|VERSION|BRANCH|NONE] [branch|version|NONE] )

function parse-module-ref()
{
    local -n RESULT=$1
    local MODREF=$2

    local module=""

    #  check version

    local ver=${MODREF#*:}

    if [[ $ver == $MODREF ]]; then
        #  no version specified
        local KIND=NONE
        local version=NONE
        module=$MODREF
    else
        #  version specified, check for tar version
        local vb=${ver:0:1}

        if [[ $ver = dev ]]; then
            KIND=DEV
            local version=dev
        elif [[ $vb = '#' ]]; then
            KIND=VERSION
            local version=${ver:1}
        else
            KIND=BRANCH
            local version=$ver
        fi

        module=${MODREF%%:*}
    fi

    local variant=${module#*/}

    if [[ $variant == $module ]]; then
        #  no variant
        variant=default
    else
        module=${module%/*}
    fi

    RESULT=($module)
    RESULT+=($variant)
    RESULT+=($KIND)
    RESULT+=($version)
}

############################## get-module-display-ref
# Returns the ref of the module to be displayed

function get-module-display-ref()
{
    local -n RESULT="$1"
    local MODULE=$2
    local VARIANT=$3
    local REF=$4

    local vcs=( $(get-vcs-data $MODULE $VARIANT) )
    local vcs_name=${vcs[3]}

    if [[ $VARIANT == "native" ]]; then
        RESULT=${REF/NONE/"os"}
    elif [[ -z $vcs_name ]]; then
        # Not a VCS (probably a ref for an archive) use REF as-is if
        # defined or n/a if not.
        RESULT=${REF/NONE/"n/a"}
    else
        get-vcs-display-ref RESULT $vcs_name $REF
    fi
}

############################## get-module-ref
# Returns a module reference given the module name and possibly
# the parent package (for-module).

function get-module-ref()
{
    local -n RESULT="$1"
    local MODREF=$2
    local FORMODULE=${3:-"@root"}

    #  Remove variants and version
    FORMODULE=${FORMODULE/:*/}
    FORMODULE=${FORMODULE/\/*/}

    local gminfo=()
    parse-module-ref gminfo $MODREF

    local module=${gminfo[0]}

    local modplan=${SCBI_MODVER[$FORMODULE"="$module]}

    if [[ -z $modplan ]]; then
        local modplan=${SCBI_MODVER[$module]}

        [[ -n $modplan ]] &&
            parse-module-ref gminfo $modplan
    else
        parse-module-ref gminfo $modplan
    fi

    RESULT=(${gminfo[0]})
    RESULT+=(${gminfo[1]})
    RESULT+=(${gminfo[2]})
    RESULT+=(${gminfo[3]})
}

############################## get-module-name
# Get full module name according to the module plan

function get-module-name()
{
    local MODREF=$1

    local module_info=()
    get-module-ref module_info $MODREF $FORMODULE

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    [[ $variant != "default" ]] && module+="/$variant"
    [[ $ref != "NONE" ]] && module+=":$ref"

    echo $module
}

############################## get-module-version
# Get module version according to the module plan

function get-module-version()
{
    local MODREF=$1

    local PLUGIN=""
    get-caller PLUGIN

    local module_info=()
    get-module-ref module_info $MODREF $PLUGIN

    local ref=${module_info[3]}

    echo $ref
}

############################## check-module-version
# Check module version against a specific version
# The operator can be = < > >= <= !=

function check-module-version()
{
    local MODREF=$1
    local OP=$2
    local VER=$3

    local PLUGIN=""
    get-caller PLUGIN

    local module_info=()
    get-module-ref module_info $MODREF $PLUGIN

    local ref=${module_info[3]}

    check-versions $ref $OP $VER
}

############################## with-variant
# parameters are the OS library for the native support

function with-variant()
{
    local VNAME=$1
    shift

    #  Get the caller plug-in name, this is called when sourcing a plug-in
    #  we need to use Bash caller here and not get-caller.
    local CALLER=( $(caller) )
    local PLUGIN=${CALLER[1]##*/}

    local module_info=()
    get-module-ref module_info $PLUGIN
    local ref=${module_info[3]}

    #  Hooks with nop body & pre/post
    local SCBI_HOOKS=()

    for H in config build install; do
        local SCBI_HOOKS+=($H)
        local SCBI_HOOKS+=(pre-$H)
        local SCBI_HOOKS+=(post-$H)
        local SCBI_HOOKS+=(cross-$H)
        local SCBI_HOOKS+=(cross-pre-$H)
        local SCBI_HOOKS+=(cross-post-$H)
    done

    local H=""

    for hook in ${SCBI_HOOKS[*]}; do
        H="function $PLUGIN-$VNAME-$hook()"
        H+="{ true; }"
        eval $H
    done

    #  Hooks with nop body & pre/post
    local SCBI_HOOKS=()

    for H in env build-env build-depends patches; do
        local SCBI_HOOKS+=($H)
        local SCBI_HOOKS+=(common-$H)
        local SCBI_HOOKS+=(default-$H)
        local SCBI_HOOKS+=(cross-$H)
        local SCBI_HOOKS+=(common-cross-$H)
        local SCBI_HOOKS+=(default-cross-$H)
    done

    for hook in ${SCBI_HOOKS[*]}; do
        H="function $PLUGIN-$VNAME-$hook()"
        H+="{ true; }"
        eval $H
    done

    #  Hooks with NONE body

    H="function $PLUGIN-$VNAME-vcs()"
    H+="{ echo NONE; echo NONE; echo NONE; echo NONE; }"
    eval $H

    H="function $PLUGIN-$VNAME-archive()"
    H+="{ echo NONE; echo NONE; echo NONE; echo NONE; echo NONE; }"
    eval $H

    #  Hook prefix
    H="function $PLUGIN-$VNAME-prefix() { echo NONE; }"
    eval $H

    #  Hook depends/env
    H="function $PLUGIN-$VNAME-depends() { "
    local P="echo "
    while [[ -n "$1" ]]; do
        if [[ "$1" == "--env" ]]; then
            H+=" true; }"
            eval $H
            H="function $PLUGIN-$VNAME-env() { "
            P=""
        else
            mod=$1

            if [[ "${mod^^}" == "NONE" ]]; then
                H+=" $P;"
            else
                H+=" $P$mod;"
            fi
        fi
        shift
    done
    H+=" true; }"
    eval $H
}

############################## scbi-store-[get/set]-value scbi-store

function scbi-store-get-key()
{
    local KEY="$1"

    local VALUE=""
    local res=1
    local STORE_FILE=$SCBI_PLUGINS/.store

    if [[ -f $STORE_FILE ]]; then
        #  check KEY in store

        while IFS=" " read -r K V; do
            if [[ "$K" == "$KEY" ]]; then
                VALUE=$V
                res=0
                break;
            fi
        done < $STORE_FILE
    fi

    #  check if stdout (1) is a terminal

    if [[ -t 1 ]]; then
        echo $VALUE
    else
        echo -n $VALUE
    fi

    return $res
}

function scbi-store-set-key()
{
    local KEY="$1"
    local VALUE="$2"

    local STORE_FILE=$SCBI_PLUGINS/.store

    [[ ! -f $STORE_FILE ]] && touch $STORE_FILE

    declare -A STORE

    #  read store content, put it inside STORE

    while IFS=" " read -r K V; do
        STORE[$K]=$V
    done < $STORE_FILE

    STORE[$KEY]="$VALUE"

    #  clear content

    echo -n > $STORE_FILE

    #  write back content

    for K in "${!STORE[@]}"; do
        echo $K ${STORE[$K]} >> $STORE_FILE
    done

    unset STORE
    return 0
}

function scbi-store-list-keys()
{
    local KEY="$1"

    local VALUE=""
    local res=1
    local STORE_FILE=$SCBI_PLUGINS/.store

    if [[ -f $STORE_FILE ]]; then
        #  check KEY in store

        while IFS=" " read -r K V; do
            echo $K
        done < $STORE_FILE
    fi

    return 0
}

function scbi-store()
{
    local KEY="$1"
    local VALUE="$2"

    if [[ -z $KEY ]]; then
        scbi-store-list-keys
    elif [[ -z "$VALUE" ]]; then
        scbi-store-get-key "$KEY"
    else
        scbi-store-set-key "$KEY" "$VALUE"
    fi
}

############################## get-build-type

function get-build-type()
{
    local KIND=$1
    local DEFAULT=$2

    #  Get the caller plug-in name
    local PLUGIN=""
    get-caller PLUGIN

    VAR_GENERIC=SCBI_${KIND}_BUILD_TYPE
    VAR_MODULE=SCBI_${PLUGIN//-/_}_BUILD_TYPE

    [[ -n ${!VAR_GENERIC} ]] && DEFAULT=${!VAR_GENERIC}
    [[ -n ${!VAR_MODULE} ]] && DEFAULT=${!VAR_MODULE}

    echo -n $DEFAULT
}

############################## helper routines list & var
#  Add, Append, Prepend, Remove to/from a list and a variable
#  whose value is a list of item separated by a specific character.

function is-in-list()
{
    local -n LIST=$1
    local VALUE=$2

    printf -v SL "%s|" ${LIST[*]}
    SL=${SL%?}

    [[ $VALUE = @($SL) ]]
}

function remove-from-list()
{
    local -n LIST=$1
    local VALUE=$2

    for i in ${!LIST[@]}; do
        [[ ${LIST[$i]} == $VALUE ]] && unset LIST[$i]
    done

    true
}

function prepend-to-list()
{
    local -n _LIST=$1
    local VALUE=$2

    remove-from-list _LIST $VALUE
    _LIST=( $VALUE ${_LIST[@]} )
}

function append-to-list()
{
    local -n _LIST=$1
    local VALUE=$2

    remove-from-list _LIST $VALUE
    _LIST+=( $VALUE )
}

function add-to-list()
{
    local -n _LIST=$1
    local VALUE=$2

    ! is-in-list _LIST $VALUE &&
        _LIST=( $VALUE ${_LIST[@]} )

    true
}

function is-in-var-sep()
{
    local -n _VAR=$1
    local VALUE=$2
    local SEP=$3

    local _LIST=( ${_VAR//$SEP/ } )
    is-in-list _LIST $VALUE
}

function remove-from-var-sep()
{
    local -n _VAR=$1
    local VALUE=$2
    local SEP=$3

    local p_LIST=( ${_VAR//$SEP/ } )
    remove-from-list p_LIST $VALUE
    printf -v _VAR "%s$SEP" ${p_LIST[@]}
    _VAR=${_VAR%?}
}

function prepend-to-var-sep()
{
    local -n _VAR=$1
    local VALUE=$2
    local SEP=$3

    local p_LIST=( ${_VAR//$SEP/ } )
    prepend-to-list p_LIST $VALUE
    printf -v _VAR "%s$SEP" ${p_LIST[@]}
    _VAR=${_VAR%?}
}

function append-to-var-sep()
{
    local -n _VAR=$1
    local VALUE=$2
    local SEP=$3

    local p_LIST=( ${_VAR//$SEP/ } )
    append-to-list p_LIST $VALUE
    printf -v _VAR "%s$SEP" ${p_LIST[@]}
    _VAR=${_VAR%?}
}

function add-to-var-sep()
{
    local -n _VAR=$1
    local VALUE=$2
    local SEP=$3

    local p_LIST=( ${_VAR//$SEP/ } )
    add-to-list p_LIST $VALUE
    printf -v _VAR "%s$SEP" ${p_LIST[@]}
    _VAR=${_VAR%?}
}

############################## define-var
#  Append/Prepend/Set VALUE to environment variable VAR,
#  does nothing if VALUE does not exists and VAR is PATH.

function define-var()
{
    local ACTION=$1
    local VAR=$2
    local VALUE=$3

    #  Separator of values in variable
    local SEP=":"

    #  If adding to PATH, do so only if VALUE exists

    if [[ "${VAR}" != "PATH" ]] || [[ -d "$VALUE" ]]; then
        #  If SCBI_ENV_MODULE file exists, record the change into
        #  it. This is used internally by scbi to record .log/env.cmd
        #  for each module. This env file can then be sourced to replay
        #  the commands manually.

        if [[ -n $SCBI_ENV_MODULE ]]; then
            echo define-var $ACTION $VAR \"$VALUE\" >> $SCBI_ENV_MODULE
        fi

        case $ACTION in
            SET|S)
                export $VAR="${VALUE}"
            ;;
            UNSET|U)
                unset $VAR
            ;;
            ADD)
                [[ -n "$VALUE" ]] &&
                    {
                        add-to-var-sep ${VAR} "${VALUE}" $SEP
                        export $VAR
                    }
            ;;
            APPEND|A)
                [[ -n "$VALUE" ]] &&
                    {
                        append-to-var-sep ${VAR} "${VALUE}" $SEP
                        export $VAR
                    }
            ;;
            PREPEND|P)
                [[ -n "$VALUE" ]] &&
                    {
                        prepend-to-var-sep ${VAR} "${VALUE}" $SEP
                        export $VAR
                    }
            ;;
            REMOVE|R)
                remove-from-var-sep ${VAR} "${VALUE}" $SEP
                export $VAR
                [[ -z ${!VAR} ]] && unset $VAR
            ;;
        esac
    fi

    true
}

#  Helper routines to prepend/append or set a variable

function prepend-to-var()
{
    local VAR=$1
    local VALUE=$2

    define-var PREPEND $VAR "$VALUE"
}

function append-to-var()
{
    local VAR=$1
    local VALUE=$2

    define-var APPEND $VAR "$VALUE"
}

function remove-from-var()
{
    local VAR=$1
    local VALUE=$2

    define-var REMOVE $VAR "$VALUE"
}

function add-to-var()
{
    local VAR=$1
    local VALUE=$2

    define-var ADD $VAR "$VALUE"
}

function set-var()
{
    local VAR=$1
    local VALUE=$2

    define-var SET $VAR "$VALUE"
}

function unset-var()
{
    local VAR=$1

    define-var UNSET $VAR
}

############################## plugin-get-variant-hooks

function plugin-get-variant-hooks()
{
    local -n RESULT=$1
    local PLUGIN=$2
    local HOOK=$3
    local PREFIX=$4
    local TARGET=$5
    local VARIANT=$6

    shift 6

    local IFS
    unset IFS
    local ALLVARS=()
    all-variants-v ALLVARS $VARIANT

    #  Check common variant only for non native variant
    local CVAR=""
    [[ $VARIANT != native ]] && CVAR="common"

    local VARFOUND=no
    local found=0
    local FCT=""

    #  Always check the common hook, then the variants if defined
    #  or otherwise the default variant. Then if nothing found
    #  we call the main hook (no variant).

    local v

    for v in $CVAR ${ALLVARS[*]:-default}; do
        found=0
        if [[ $SCBI_HOST != $SCBI_TARGET ]]; then
            FCT="$PLUGIN-$v-cross-$HOOK"
            fn-exists $FCT
            [[ $? = 0 ]] && found=1
        fi

        if [[ $found == 0 ]]; then
            FCT="$PLUGIN-$v-$HOOK"
            fn-exists $FCT
            [[ $? = 0 ]] && found=1
        fi

        if [[ $found == 1 ]]; then
            [[ $v != "common" ]] && [[ $v != "default" ]] && VARFOUND=yes
            RESULT+=( $FCT )
        fi
    done

    if [[ $VARFOUND == no ]]; then
        found=0
        if [[ $SCBI_HOST != $SCBI_TARGET ]]; then
            FCT="$PLUGIN-cross-$HOOK"
            fn-exists $FCT
            [[ $? = 0 ]] && found=1
        fi

        if [[ $found == 0 ]]; then
            FCT="$PLUGIN-$HOOK"
            fn-exists $FCT
            [[ $? = 0 ]] && found=1
        fi

        [[ $found == 1 ]] && RESULT+=( $FCT )
    fi
}

############################## plugin-call-variant-hooks

function plugin-call-variant-hooks()
{
    local PLUGIN=$1
    local HOOK=$2
    local PREFIX=$3
    local TARGET=$4
    local VARIANT=$5

    shift 5

    local HOOKS=()
    plugin-get-variant-hooks HOOKS $PLUGIN $HOOK $PREFIX $TARGET $VARIANT

    for H in ${HOOKS[@]}; do
        $H $PREFIX $TARGET $VARIANT $*
    done
}

############################## plugin-call-env-hooks

function plugin-call-env-hooks()
{
    local FORMODULE=$1
    local MODREF=$2
    local ENV=$3

    local TVDIR=""

    function do-set-env()
    {
        local FORMODULE=$1
        local MODREF=$2
        local LEVEL=$3
        local DEPENDS_KIND=$4
        local IS_EXT=$5
        local IS_META=$6
        local IS_AGGREGATED=$7

        local emodule_info=()
        get-module-ref emodule_info $MODREF $FORMODULE

        local module=${emodule_info[0]}
        local variant=${emodule_info[1]}

        plugin-call-variant-hooks \
            $module $ENV $TVDIR/install $SCBI_TARGET $variant
    }

    #  Get module information

    local module_info=()
    get-module-ref module_info $MODREF $FORMODULE

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local ref=${module_info[3]}

    [[ "$ref" == "skip" ]] && return 0

    #  If a meta aggregate module we want the environment of all
    #  aggregated modules.

    local MODE="default"

    is-meta-module $MODREF > /dev/null

    if [[ $? == 0 ]]; then
        #  For a meta aggregate module the env if the one from
        #  all aggregated modules but using the aggregate
        #  install prefix.

        is-meta-aggregate-module MODE $MODREF
    fi

    #  If a module is aggregated we want its env to point to the
    #  meta aggregate module.

    #  Then setup the current module

    get-target-dir TVDIR $module $variant

    if [[ $MODE == direct ]]; then
        for MOD in $(plugin-call-variant-hooks \
                         $module modules \
                         $SCBI_PREFIX $SCBI_TARGET $variant);
        do
            plugin-call-variant-hooks \
                $MOD $ENV $TVDIR/install $SCBI_TARGET $variant
        done
    elif [[ $MODE == recursive ]]; then
        for MOD in $(plugin-call-variant-hooks \
                         $module modules \
                         $SCBI_PREFIX $SCBI_TARGET $variant);
        do
            for-all-modules-depends-with-meta do-set-env $MOD
        done
    else
        plugin-call-variant-hooks \
            $module $ENV $TVDIR/install $SCBI_TARGET $variant
    fi
}

############################## call-variant-hooks

function call-variant-hooks()
{
    local HOOK=$1
    local PREFIX=$2
    local TARGET=$3
    local VARIANT=$4

    shift 4

    local PLUGIN=""
    get-caller PLUGIN

    plugin-call-variant-hooks $PLUGIN $HOOK $PREFIX $TARGET $VARIANT $*
}

############################## check-versions
#
# Compare a and b as version strings. Rules:
# R1: a and b : dot-separated sequence of items. Items are numeric.
#     The last item can optionally end with letters, i.e., 2.5 or 2.5a.
# R2: Zeros are automatically inserted to compare the same number
#     of items, i.e., 1.0 < 1.0.1 means 1.0.0 < 1.0.1 => yes.
# R3: op can be '=' '==' '!=' '<' '<=' '>' '>=' (lexicographic).
# R4: Unrestricted number of digits of any item, i.e., 3.0003 > 3.0000004.
# R5: Unrestricted number of items.
# R6: Ignore trailing -X.Y versions (after dash) if present

function check-versions()
{
    local a=$1
    local op="$2"
    local b=$3

    local al=${1##*.}
    local bl=${3##*.}

    while [[ $al =~ ^[[:digit:]] ]]; do al=${al:1}; done
    while [[ $bl =~ ^[[:digit:]] ]]; do bl=${bl:1}; done
    local ai=${a%$al} bi=${b%$bl}

    local ap=${ai//[[:digit:]]} bp=${bi//[[:digit:]]}
    ap=${ap//./.0} bp=${bp//./.0}

    local w=1 fmt=$a.$b x IFS=.
    for x in $fmt; do [ ${#x} -gt $w ] && w=${#x}; done
    fmt=${*//[^.]}; fmt=${fmt//./%${w}s}
    printf -v a $fmt $ai$bp; printf -v a "%s-%${w}s" $a $al
    printf -v b $fmt $bi$ap; printf -v b "%s-%${w}s" $b $bl

    case "$op" in
        '<=' | '>=' )
            [ "$a" ${op:0:1} "$b" ] || [ "$a" = "$b" ]
            ;;
        * )
            [ "$a" $op "$b" ]
            ;;
    esac
}

############################## load-runtime-module-plan
#
# Load a flat module plan. Used for replay script.

function load-runtime-module-plan()
{
    local PLAN=$1

    while read modref arg var; do
        if [[ "${modref:0:1}" != "#" ]]; then
            local minfo=()
            parse-module-ref minfo $modref
            local module=${minfo[0]}
            SCBI_MODVER[$module]=${modref/*=/}
        fi
    done < $PLAN
}

############################## set-compiler-paths

function set-compiler-paths()
{
    local PREFIX=$1
    local TARGET=$2

    local VER=1

    if [[ $SCBI_IS_WINDOWS == no ]]; then
        VER=$(gcc -dumpversion)
    fi

    if [[ -z $TARGET ]]; then
        I1=$PREFIX/include/$SCBI_HOST
        I2=$PREFIX/include
        I3=$PREFIX/lib/gcc/$SCBI_HOST/$VER/include
        I4=$PREFIX/local/include

        IP1=$PREFIX/include/c++/$VER

        P=$PREFIX/$SCBI_HOST/share/gpr:$PREFIX/share/gpr
        L=$PREFIX/lib/$SCBI_HOST:$PREFIX/lib
    else
        I1=$PREFIX/lib/gcc/$TARGET/$VER/include
        I2=$PREFIX/include/$TARGET
        I3=$PREFIX/include
        I4=$PREFIX/local/include

        IP1=$PREFIX/include/$TARGET/c++/$VER
        IP2=$PREFIX/include/c++/$VER

        P=$PREFIX/$TARGET/share/gpr
        L=$PREFIX/lib/$TARGET

        #  The cross-compiler needs libiconv shared library if it was
        #  built against it.
        IC=$SCBI_BDIR/c-libiconv/x86_64-linux-gnu-default/install/lib

        [[ -d $IC ]] && L=$L:$IC
    fi

    export C_INCLUDE_PATH=$I1:$I2:$I3:$I4
    export CPLUS_INCLUDE_PATH=$IP1:$IP2:$I1:$I2:$I3:$I4

    export LIBRARY_PATH=$L:/usr/lib
    export LD_LIBRARY_PATH=$L:/usr/lib
    export ADA_PROJECT_PATH=$P
}

############################## target-env

function target-env()
{
    local PREFIX=$1
    local TARGET=$2

    if [[ -z $PREFIX ]]; then
        PREFIX=$(dirname $(dirname $(command -v gcc)))
    fi

    if [[ -z $TARGET ]]; then
        B=$PREFIX/bin
    else
        B=$PREFIX/$TARGET/bin
    fi

    export PATH=$B:$PATH

    set-compiler-paths $PREFIX $TARGET
}

############################## no-target-env

function no-target-env()
{
    local PREFIX=$1
    local TARGET=$2

    if [[ -z $PREFIX ]]; then
        PREFIX=$(dirname $(dirname $(command -v gcc)))

        #  check if gcc is inside a target specific dir
        #  <prefix>/<target>/bin

        if [[ -x $PREFIX/../bin/gcc ]]; then
            local DN=$(dirname $PREFIX)
            if [[ $DN != "/" ]]; then
                PREFIX=$DN
            fi
        fi
    fi

    if [[ -z $TARGET ]]; then
        B=$PREFIX/bin
    else
        B=$PREFIX/$TARGET/bin
    fi

    export PATH=$B:$PATH

    set-compiler-paths $PREFIX $SCBI_HOST
}

############################## system-compiler

function system-compiler()
{
    export PATH=/usr/local/bin:/usr/bin:/bin

    unset C_INCLUDE_PATH
    unset CPLUS_INCLUDE_PATH
    unset LIBRARY_PATH
    unset LD_LIBRARY_PATH
    unset ADA_PROJECT_PATH
}

############################## built-compiler

function built-compiler()
{
    local PREFIX=$SCBI_BDIR/install

    export PATH=$PREFIX/bin:$PATH

    set-compiler-paths $PREFIX
}
