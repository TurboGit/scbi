# ############################## has-discriminant
# returns 1 if the discriminant has been found

function has-discriminant()
{
    local disc=$1

    for d in ${SCBI_OS_DISCRIMINANTS[*]}; do
        if [[ $disc == $d ]]; then
            return 0
        fi
    done

    return 1
}

# ############################## check-discriminants
# return 1 if all discriminants match

function check-discriminants()
{
    local discs="$1"

    for d in ${discs/,/ }; do
        has-discriminant $d
        [[ $? == 1 ]] && return 1
    done

    return 0
}

# ############################## load-module-plan
#
#

function load-module-plan()
{
    local NAMEREF=$1

    local VARIANT=${NAMEREF#*/}

    if [[ $VARIANT == $NAMEREF ]]; then
        VARIANT=""
        NAME=${NAMEREF}
    else
        NAME=${NAMEREF%/*}
    fi

    local PLAN=$PWD/.scbi-plan-$NAME

    local GROUP=no
    local GMOD=""

    #  if not found in definitions install dir, look in current directory

    if [[ ! -f $PLAN ]]; then
        PLAN=$SCBI_PLUGINS/.plan-$NAME
    fi

    if [[ -f $PLAN ]]; then
        while read modref arg1 arg2 arg3; do
            if [[ "$modref" = "@load" ]]; then
                load-module-plan $arg1
            elif [[ "$modref" = "@on" ]]; then
                if [[ "$arg2" != "use" ]]; then
                    elog build syntax error, missing use in @on
                    exit 1
                fi

                if check-discriminants "$arg1"; then
                    local module_info=( $(parse-module-ref $arg3) )
                    local module=${module_info[0]}
                    MODVER[$module]=${arg3/*=/}
                fi
            elif [[ "$modref" = "@alias" ]]; then
                if [[ "$arg2" != "use" ]]; then
                    elog build syntax error, missing use in @alias
                    exit 1
                fi

                SCBI_MODULE_ALIAS[$arg1]=$arg3
            elif [[ "$modref" = "@for" ]]; then
                if [[ "$arg2" != "use" ]]; then
                    elog build syntax error, missing use in @for
                    exit 1
                fi

                local module_info=( $(parse-module-ref "$arg1=$arg3") )
                local module=${module_info[0]}
                MODVER[$module]=$arg3

            elif [[ -z $modref ]]; then
                true
            elif [[ "${modref:0:1}" = "]" ]]; then
                REF=""
                if [[ -n $arg1 ]]; then
                    REF=$arg1
                else
                    REF=${modref:1}
                fi
                #  set REF to all module's group in GMOD
                for mod in $GMOD; do
                    local module_info=( $(parse-module-ref $mod) )
                    local module=${module_info[0]}
                    local variant=${module_info[1]}
                    local kind=${module_info[2]}
                    local version=${module_info[3]}

                    local ref_info=( $(parse-module-ref "name$REF") )
                    local rvariant=${ref_info[1]}
                    local rkind=${ref_info[2]}
                    local rversion=${ref_info[3]}

                    local FREF=""

                    #  Override the variant & version only if defined in REF

                    if [[ $rvariant != "default" ]]; then
                        FREF="/$rvariant"
                    elif [[ $variant != "default" ]]; then
                        FREF="/$variant"
                    fi

                    if [[ $rversion != NONE ]]; then
                        if [[ $rkind == VERSION ]]; then
                            FREF="$FREF:#$rversion"
                        else
                            FREF="$FREF:$rversion"
                        fi
                    elif [[ $version != NONE ]]; then
                        if [[ $kind == VERSION ]]; then
                            FREF="$FREF:#$version"
                        else
                            FREF="$FREF:$version"
                        fi
                    fi

                    MODVER[$module]=${module}${FREF}
                done
                GROUP=no
                GMOD=""
            elif [[ $GROUP != no ]]; then
                #  store all module's group in GMOD
                [[ $GROUP == yes ]] && GMOD="$GMOD $modref"
            elif [[ "$modref" = "[" ]]; then
                if [[ -n $arg1 ]]; then
                    if [[ $arg1 = "=" ]]; then
                        if has-variant "$VARIANT" "$arg2" \
                            || check-discriminants "$arg2";
                        then
                            GROUP=yes
                        else
                            GROUP=closed
                        fi
                    elif [[ $arg1 = "/=" ]]; then
                        if has-variant "$VARIANT" "$arg2" \
                                || check-discriminants "$arg2";
                        then
                            GROUP=closed
                        else
                            GROUP=yes
                        fi
                    else
                       elog build "build plan unexpected $arg1 on group start"
                       exit 1
                    fi
                else
                    GROUP=yes
                fi
            elif [[ "${modref:0:1}" != "#" ]]; then
                local module_info=( $(parse-module-ref $modref) )
                local module=${module_info[0]}
                MODVER[$module]=${modref/*=/}
            fi
        done < $PLAN
    else
        elog build build plan .plan-$1 does not exists
        exit 1
    fi

    if [[ $GROUP = yes ]]; then
        elog build build plan group is not closed .plan-$1
        exit 1
    fi
}

############################## load-module-plan
#
# Checks all auto variant and use the native one or the default variant
# depending on the availability of the dependencies.

function handle-auto-variant()
{
    local eres=0

    for M in ${!MODVER[@]}; do
        local value=${MODVER[$M]}

        local mod=${M/*=/}
        local FORMODULE=${M%$mod}
        FORMODULE=${FORMODULE%=}

        local module_info=( $(get-module-ref $value $FORMODULE) )

        local module=${module_info[0]}
        local variant=${module_info[1]}

        if [[ $variant =~ ^auto(\.|$) ]]; then
            check-auto-variant $mod $FORMODULE
            local res=$?

            if [[ $res == 0 ]]; then
                #  replaces all variants by a single "native"
                value=${value/\/auto*([.a-zA-Z])/\/native}
                MODVER[$M]=$value
                ilog $M module $M using native variant
            elif [[ $res == 1 ]]; then
                #  remove "auto" from the list of variants, or replace
                #  it with FORMODULE if defined and auto is the only
                #  variant specified. This ensure that a separate
                #  directory is used for the build.
                value=${value/\/auto\./\/}

                if [[ -z $FORMODULE ]]; then
                    value=${value/\/auto}
                else
                    local FMOD=${FORMODULE//[-._]/}
                    value=${value/\/auto/\/$FMOD}
                fi
                MODVER[$M]=$value
                ilog module $M using standard variant
            else
                elog $M "$M auto mode must define a native variant"
                eres=1
            fi
        fi
    done

    return $eres
}

############################## display-build-plan
#
#

function _internal_list-build-plan()
{
    local module=""

    for module in ${!MODVER[*]}; do
        local FM=${module%=*}
        if [[ "$FM" != "$module" ]]; then
            echo "@for $FM use ${MODVER[$module]}"
        else
            echo "${MODVER[$module]}"
        fi
    done
}

function display-build-plan()
{
    echo "There is ${#MODVER[*]} module(s) in the plan"
    _internal_list-build-plan
}

############################## record-build-plan
#
#

function record-build-plan()
{
    local MODULE=$1
    local VARIANT=$2

    local PLAN=$SCBI_BDIR/$MODULE/$SCBI_TARGET-$VARIANT/.log/build-plan

    echo "# build plan"        > $PLAN
    _internal_list-build-plan >> $PLAN
}

############################## set-module-ref
#
# Set a module reference into the build plan only if this reference a
# specific version or is forced.

function set-module-ref()
{
    #  full module reference is name[/variant][:version]
    local MODREF="$1"

    local module_info=( $(parse-module-ref $MODREF) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    if [[ "$variant" != "default" ]]   \
         || [[ "${kind^^}" != "NONE" ]]   \
         || [[ "${ref^^}" != "NONE" ]];
    then
        if [[ "$ref" == "force" ]]; then
            MODVER[$module]=$module/$variant
        else
            MODVER[$module]=${MODREF/*=/}
        fi
    fi
}

############################## check-auto-variant

function check-auto-variant()
{
    local MODULE=$1
    local FORMODULE=${2:-"@root"}

    if [[ -f $SCBI_PLUGINS/$MODULE ]]; then
        #  Check external dependencies for native-depends

        (
            local res=0

            source $SCBI_PLUGINS/$MODULE

            fn-exists $MODULE-native-depends

            if [[ ! $? = 0 ]]; then
                #  Fatal error, stop now
                exit 2
            fi

            for dmodule in $(get-all-depends $MODULE native depends); do
                if [[ ! -f $SCBI_PLUGINS/$dmodule ]]; then
                    #  If OS dependency on a native variant has version set
                    #  to v (for example libtbb:v) we want this dependency
                    #  to be checking the module's version requested.

                    if [[ ${dmodule#*:} == "[v]" ]]; then
                        dmodule=${dmodule%:*}

                        local m_info=( $(get-module-ref $MODULE $FORMODULE) )
                        local ref=${m_info[3]}

                        if [[ $ref != NONE ]]; then
                            dmodule=${dmodule}:$ref
                        fi
                    fi

                    local STATUSES=( $(check-pkg-status $dmodule) )

                    while read pkg pver pres; do
                        if [[ $pres == $SCBI_PKG_NOT_FOUND ]]; then
                            ilog $MODULE unknown dependency $pkg
                            res=1
                        elif [[ $pres == $SCBI_PKG_NOT_INSTALLED ]]; then
                            ilog $MODULE dependency $pkg not installed
                            res=1
                        elif [[ $pres == $SCBI_PKG_VERSION_NOK ]]; then
                            ilog $MODULE module $pkg version $pver not found
                            res=1
                        elif [[ $pres == $SCBI_PKG_VERSION_OK ]]; then
                            if [[ $pver == 0 ]]; then
                                ilog $MODULE module $pkg found
                            else
                                ilog $MODULE module $pkg version $pver matching
                            fi
                        fi
                    done < <( echo ${STATUSES[*]} )
                fi
            done

            exit $res
        )
        return $?

    else
        #  No module definition, cannot have a native variant, error will
        #  be reported upward.
        return 1
    fi
}
