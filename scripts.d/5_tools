
declare -A SCBI_LOADED

declare SCBI_RECTREE=()

############################## fn-exists
# check wether a function is defined

function fn-exists()
{
    declare -f $1 > /dev/null
}

############################## get-hooks
# return the hook name for the given step. This can be the
# hook for a variant and/or cross build.

function get-hook()
{
    local module=$1
    local variant=$2
    local step=$3

    local HOOK=""

    if [[ $SCBI_HOST != $SCBI_TARGET ]]; then
        fn-exists $module-$variant-cross-$step
        if [[ $? = 0 ]]; then
            HOOK=$module-$variant-cross-$step
        else
            fn-exists $module-cross-$step
            [[ $? = 0 ]] && HOOK=$module-cross-$step
        fi
    fi

    if [[ -z $HOOK ]]; then
        fn-exists $module-$variant-$step
        if [[ $? = 0 ]]; then
            HOOK=$module-$variant-$step
        else
            fn-exists $module-$step
            [[ $? = 0 ]] && HOOK=$module-$step
        fi
    fi

    echo $HOOK
}

############################## is-enabled
# check wether a feature is enabled (see option --enable-<feature>)

function is-enabled()
{
    local VAR=SCBI_${1/-/_}_SET

    if [[ "${!VAR}" = "true" ]]; then
        echo "yes"
        return 0
    else
        return 1
    fi
}

############################## add-to-var
# add DIR to environment variable VAR, does nothing if DIR does not exists

function add-to-var()
{
    local VAR=$1
    local DIR=$2

    # If adding to PATH, do so only if DIR exists

    if [[ -d "$DIR" ]] || [[ "${VAR}" != "PATH" ]] &&
           [[ ":${!VAR}:" != *":$DIR:"* ]];
    then
        # If SCBI_ENV_MODULE file exists, record the change into
        # it. This is used internally by scbi to record .log/env.cmd
        # for each module. This env file can then be sourced to replay
        # the commands manually.

        if [[ ! -z $SCBI_ENV_MODULE ]]; then
            echo add-to-var $VAR $DIR >> $SCBI_ENV_MODULE
        fi

        export $VAR="${DIR}${!VAR:+:}${!VAR}"
    fi
}

############################## get-version-number
# return a 2 digits version number for $1

VERSION_OK=9999
VERSION_ERROR=-1

function get-version-number()
{
    echo -n "$1" | sed -e 's/[^0-9-]*\(\-\?[0-9]*\(\.[0-9]*\)\?\).*/\1/g'
}

############################## display-version

function display-version()
{
    local version=$1

    if [[ "$version" = "$VERSION_OK" ]]; then
        echo latest
    elif [[ "$version" = "$VERSION_ERROR" ]]; then
        echo not found
    else
        echo $version
    fi
}

############################## gprbuild-project
# for testing if a project compile and link

function gprbuild-project()
{
    local PRJ=$1

    (
        if [[ $SCBI_HOST == $TARGET ]]; then
            gprbuild -p -q $PRJ -cargs -gnatwA
        else
            gprbuild -p -q --target=$TARGET $PRJ -cargs -gnatwA
        fi
    )  > /dev/null 2>&1
}

############################## display-file

function display-file()
{
    local file=$1

    echo File : $file
    cat $file
}

############################## get-md5

function get-md5()
{
    md5sum | cut -d' ' -f1
}

############################## load-module
#
# load an SCBI build script

function load-module()
{
    local module=$1

    if [[ -z "${SCBI_LOADED[$module]}" ]]; then
        if [[ -f $SCBI_DEFS/$module ]]; then
            source $SCBI_DEFS/$module
            SCBI_LOADED[$module]=yes
            return 0
        else
            return 1
        fi
    else
        return 0
    fi
}

############################## check-dependency-tree
#
# check whether a module is in the dependency tree

function check-dependency-tree()
{
    local module=$1
    local res=1

    for m in ${SCBI_RECTREE[*]}; do
        if [[ $m = $module ]]; then
            res=0
        fi
    done

    return $res
}

############################## push-dependency-tree
#
# push module in dependency tree

function push-dependency-tree()
{
    local module=$1
    SCBI_RECTREE=( ${SCBI_RECTREE[*]} $module )
}

############################## pop-dependency-tree
#
# pop last module pushed from dependency tree

function pop-dependency-tree()
{
    unset SCBI_RECTREE[-1]
}

############################## for-all-modules

function _internal_for-all-modules()
{
    local CALLBACK=$1
    local WITH_META=$2
    local LEVEL=$3
    local WITHEXT=$4
    local IS_BUILD_DEPENDS=$5
    local MODREF=$6
    shift
    shift
    shift
    shift
    shift
    shift

    #  Check if recursive dependencies is needed

    [[ $DO_DEPS == yes-direct ]] && [[ $LEVEL -ge 2 ]] && return 0

    #  Get module information

    local module_info=( $(get-module-ref $MODREF) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    [ $ref = "skip" ] && return 0

    #  Next level
    local NEXTL=$((LEVEL + 1))

    #  Check dependency graph to ensure there is no circularities

    check-dependency-tree $module

    if [[ $? = 0 ]]; then
        elog $module recursive dependencies detected

        local N=${#SCBI_RECTREE[*]}
        N=$(expr $N - 2)

        for i in $(seq 0 $N); do
            local j=$(expr $i + 1)
            elog $module " . " ${SCBI_RECTREE[$i]} '->' ${SCBI_RECTREE[$j]}
        done

        elog $module " . " ${SCBI_RECTREE[-1]} '->' $module
        exit 1
    fi

    #  Then load module

    local IS_META=false

    if [[ -z "${SCBI_CHECKED[$module]}" ]]; then
        SCBI_CHECKED[$module]=yes

        load-module $module

        if [[ $? = 0 ]]; then
            push-dependency-tree $module

            FCT=$(get-hook $module $variant modules)

            if [[ ! -z $FCT ]]; then
                IS_META=true
            fi

            if [[ $WITH_META == true ]] && [[ $IS_META == true ]]; then
                # check for meta-modules if present

                for dmodule in $($FCT $SCBI_PREFIX $SCBI_TARGET $variant); do
                    _internal_for-all-modules $CALLBACK $WITH_META $NEXTL \
                                              $WITHEXT false $dmodule $@
                done

                $CALLBACK $module $MODREF $LEVEL \
                          $IS_BUILD_DEPENDS false $IS_META $@

                pop-dependency-tree
                return
            fi

            # Setup depends recursively if any

            FCT=$(get-hook $module $variant depends)

            if [[ ! -z $FCT ]]; then
                for dmodule in $($FCT $SCBI_PREFIX $SCBI_TARGET $variant); do
                    _internal_for-all-modules $CALLBACK $WITH_META $NEXTL \
                                              $WITHEXT false $dmodule $@
                done
            fi

            # Setup build-depends recursively if any

            FCT=$(get-hook $module $variant build-depends)

            if [[ ! -z $FCT ]]; then
                for dmodule in $($FCT $SCBI_PREFIX $SCBI_TARGET $variant); do
                    _internal_for-all-modules $CALLBACK $WITH_META $NEXTL \
                                              $WITHEXT true $dmodule $@
                done
            fi

            $CALLBACK $module $MODREF $LEVEL \
                      $IS_BUILD_DEPENDS false $IS_META $@

            pop-dependency-tree

        else
            # module does not exists, this is an external dependency

            if [[ $WITHEXT == true ]]; then
                $CALLBACK $module $MODREF $LEVEL \
                          $IS_BUILD_DEPENDS true $IS_META $@
            else
                check-pkg $module:$ref
            fi
        fi
    fi
}

# Iterate over all modules
function for-all-modules()
{
    local CALLBACK=$1
    local MODREF=$2
    shift
    shift

    declare -A SCBI_CHECKED
    SCBI_RECTREE=()
    _internal_for-all-modules $CALLBACK false 0 false false $MODREF $@
}

# Iterate over all modules and external dependencies
function for-all-modules-ext()
{
    local CALLBACK=$1
    local MODREF=$2
    shift
    shift

    declare -A SCBI_CHECKED
    SCBI_RECTREE=()
    _internal_for-all-modules $CALLBACK false 0 true false $MODREF $@
}

# Iterate over all modules and meta-modules
function for-all-modules-with-meta()
{
    local CALLBACK=$1
    local MODREF=$2
    shift
    shift

    declare -A SCBI_CHECKED
    SCBI_RECTREE=()
    _internal_for-all-modules $CALLBACK true 0 false false $MODREF $@
}

# Iterate over all modules, meta-modules and external dependencies
function for-all-modules-with-meta-ext()
{
    local CALLBACK=$1
    local MODREF=$2
    shift
    shift

    declare -A SCBI_CHECKED
    SCBI_RECTREE=()
    _internal_for-all-modules $CALLBACK true 0 true false $MODREF $@
}

############################## get-depends-build-id

function get-build-id-callback()
{
    local MODULE=$1
    local MODREF=$2
    local LEVEL=$3
    local IS_BUILD_DEPENDS=$4
    local IS_EXT=$5
    local IS_META=$6

    # Only compute for dependencies, not for the root module

    if [[ $LEVEL -gt 0 ]] && [[ $IS_META == false ]]; then
        if [[ -f $SCBI_BDIR/$MODULE/install-id ]]; then
            var=$(cat $SCBI_BDIR/$MODULE/install-id)

            if [[ -f $SCBI_BDIR/$MODULE/build-id-$var ]]; then
                cat $SCBI_BDIR/$MODULE/build-id-$var
            else
                echo $(date)
            fi
        else
            echo $(date)
        fi
    fi
}

function get-depends-build-id()
{
    (
        for-all-modules-with-meta get-build-id-callback $1 | get-md5
    )
}

############################## get-patch-md5

function get-patch-md5()
{
    local PATCH_FILE="$1"

    local patch=""

    if [[ -f "$SCBI_PATCH/$PATCH_FILE" ]]; then
        patch="$SCBI_PATCH/$PATCH_FILE"
    elif [[ -f "$SCBI_DEFS/patches/$PATCH_FILE" ]]; then
        patch="$SCBI_DEFS/patches/$PATCH_FILE"
    fi

    if [[ -f "$patch" ]]; then
        cat $patch | get-md5
    else
        echo not-found
    fi
}

############################## get-build-id

function get-build-id()
{
    local PREFIX=$1
    local TARGET=$2
    local MODREF=$3
    local vid="$4"

    # Get module information

    local module_info=( $(get-module-ref $MODREF) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    # Include the SCBI module, if changed we need to rebuild

    local mid=no-module-script

    [ -f $SCBI_DEFS/$module ] && mid=$(cat $SCBI_DEFS/$module | get-md5)

    # If patch activated

    local pid="no-patch-found"

    if [[ $DO_PATCH = yes ]]; then
        fn-exists $module-$variant-patches

        if [[ $? = 0 ]]; then
            for patch in $($module-$variant-patches $PREFIX $TARGET \
                                                    $kind $ref);
            do
                pid="$pid,$(get-patch-md5 $patch)"
            done

        else
            fn-exists $module-patches

            if [[ $? = 0 ]]; then
                for patch in $($module-patches $PREFIX $TARGET $variant \
                                               $kind $ref);
                do
                    pid="$pid,$(get-patch-md5 $patch)"
                done
            fi
        fi
    fi

    # Also compute id from dependencies to ensure we rebuild if one
    # dependency has changed.

    local did=$(get-depends-build-id $MODREF)

    # Now compute final id add compile version

    if [[ "$SCBI_HOST" = "$TARGET" ]] \
           || [[ "$(which $TARGET-gcc)" = "" ]];
    then
        echo -n $(gcc --version | head -1) ",$vid,$mid,$pid,$did" | get-md5

    else
        echo -n $($TARGET-gcc --version | head -1) ",$vid,$mid,$pid,$did" | get-md5
    fi
}

############################## check-tar-exists
# check if the tarball exists locally, do not try to download it
# exit status 0 = FOUND / 1 = NOT_FOUND

function check-tar-exists()
{
    local module=$1
    local version=$2

    fn-exists $module-tar

    if [[ ! $? = 0 ]]; then
        return 1
    fi

    local tar=( $($module-tar $version) )

    #local proxy=${tar[0]}
    #local tarcp=${tar[1]}
    #local tarurl=${tar[2]}
    local tarsrc=${tar[3]}

    if [[ -f $SCBI_TAR/$tarsrc ]]; then
        return 0
    else
        return 1
    fi
}

############################## set-proxy

function set-proxy()
{
    local NAME=$1

    fn-exists proxy-$NAME

    [[ $? = 0 ]] && proxy-$NAME
}

############################## get-tar

function get-tar()
{
    local module=$1
    local version=$2
    local res=0

    local tar=( $($module-tar $version) )

    local proxy=${tar[0]}
    local tarcp=${tar[1]}
    local tarurl=${tar[2]}
    local tarsrc=${tar[3]}

    #  The tarball is not present, try downloading it

    if [[ ! -f $SCBI_TAR/$tarsrc ]]     \
           && [[ "$tarcp" != "none" ]]  \
           && [[ "$tarurl" != "none" ]];
    then
        (
            check-tool $tarcp
            if [[ $? != 0 ]]; then
                elog $module Required tool $tarcp missing
                exit 1
            fi

            set-proxy $proxy

            if [[ $tarcp == wget ]]; then
                $tarcp $tarurl/$tarsrc -O $SCBI_TAR/$tarsrc > $log 2>&1
            elif  [ $tarcp == curl ]; then
                $tarcp $tarurl/$tarsrc --output $SCBI_TAR/$tarsrc > $log 2>&1
            else
                elog $module error: unknown tar protocol $tarcp
            fi

            [[ ! $? = 0 ]] && elog $module error: cannot get tar: $tarcp
        )
    fi

    [ ! -f $SCBI_TAR/$tarsrc ] &&
        elog $module error: tarball $tarsrc not found

    ilog build extract tarball $tarsrc

    [ ! -d $SCBI_BDIR/$module ] && mkdir -p $SCBI_BDIR/$module > $log 2>&1

    cd $SCBI_BDIR/$module

    rm -fr tarsrc tar > $log 2>&1
    ( rm -fr tartmp && mkdir -p tartmp ) > $log 2>&1
    cd tartmp

    tar xf $SCBI_TAR/$tarsrc
    topdir=$(ls -d *)

    if [[ -d "$topdir" ]]; then
        mv "$topdir" ../tarsrc
        cd ..
        rmdir tartmp
        ln -s $(realpath --relative-to="$PWD" $SCBI_TAR/$tarsrc) tar
    else
        echo Error, no top directory found.
        res=1
    fi

    return $res
}

############################## display-stat

function display-stat()
{
    echo
    echo stats
    echo -----
    echo "build dir             : $SCBI_BDIR"
    echo "install prefix        : $SCBI_PREFIX"
    echo "tar dir               : $SCBI_TAR"
    echo "patches dir           : $SCBI_PATCH"
    echo "user's Git repository : $SCBI_GIT_REPO"
    echo "user's SVN repository : $SCBI_SVN_REPO"
    echo -n "e-mail notification   :"

    if [[ $EMAIL_NOTIFICATION == no ]]; then
        echo " no"
    else
        echo " $EMAIL"
    fi
}

############################## display-modules

function display-modules()
{
    echo
    echo -n "modules:"

    local linelen=0

    for module in $SCBI_DEFS/[^0-9]*; do
        bn=$(basename $module)
        linelen=$(expr $linelen + ${#bn} + 1)
        if [[ $linelen -gt 70 ]]; then
            echo
            echo -n "        "
            linelen=${#bn}
        fi
        echo -n " $bn"
    done
    echo
}

############################## display-modules

function display-module-version()
{
    local MODREF=$1

    local module_info=( $(get-module-ref $MODREF) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    echo -n $ref
}

############################## display-plans

function display-plans()
{
    echo
    echo -n "plans  :"
    local linelen=0

    if [[ -z "$(ls $SCBI_DEFS/.plan-* 2> /dev/null)" ]]; then
        echo " none"
    else
        for module in $SCBI_DEFS/.plan-*; do
            bn=$(basename $module)
            linelen=$(expr $linelen + ${#bn} + 1)
            if [[ $linelen -gt 70 ]]; then
                echo
                echo -n "        "
                linelen=${#bn}
            fi
            echo -n " ${bn/.plan-/}"
        done
        echo
    fi
}

############################## get-build-type

function get-build-type()
{
    local KIND=$1
    local MODULE=$2
    local DEFAULT=$3

    VAR_GENERIC=SCBI_${KIND}_BUILD_TYPE
    VAR_MODULE=SCBI_${MODULE/-/_}_BUILD_TYPE

    [ ! -z ${!VAR_GENERIC} ] && DEFAULT=${!VAR_GENERIC}
    [ ! -z ${!VAR_MODULE} ] && DEFAULT=${!VAR_MODULE}

    echo -n $DEFAULT
}

############################## last-modified-directory
# returns the newest (last modified) directory matching pattern

function last-modified-directory()
{
    local PATTERN="$1"

    ls -td $PATTERN 2> /dev/null | head -1
}

############################## split all variants
# returns all variants separated with spaces, usage:
#
# for v in $(all-variants $VARIANT); do
#    ...
# done

function all-variants()
{
    local VARIANTS=$1
    if [[ "$VARIANTS" != "default" ]]; then
        echo "${VARIANTS//./ }"
    fi
}

############################## create-standalone-package

function copy-module-src-callback()
{
    local MODULE=$1
    local MODREF=$2
    local LEVEL=$3
    local IS_BUILD_DEPENDS=$4
    local IS_EXT=$5
    local IS_META=$6
    local DEST=$7

    if [[ $IS_EXT == true ]]; then
        echo -n " $MODULE" >> $DEST/build-deps

    else
        # copy tarball or vcs sources

        if [[ -d $SCBI_BDIR/$MODULE ]]; then
            ilog standalone "-   $MODULE"

            # two modules may share the same VCS or tarball
            if [[ -h $SCBI_BDIR/$MODULE/tar ]]; then
                FILE=$(readlink -f $SCBI_BDIR/$MODULE/tar)
                [ ! -f $DEST/.tar/$(basename $FILE) ] && cp -p $FILE $DEST/.tar
            elif [[ -h $SCBI_BDIR/$MODULE/vcs ]]; then
                DIR=$(readlink -f $SCBI_BDIR/$MODULE/vcs)
                [ ! -d $DEST/.vcs/$(basename $DIR) ] && cp -rp $DIR $DEST/.vcs/
            fi
        else
            elog standalone \
                 "-   $MODULE sources not found, cannot create archive"
            exit 1
        fi

        # copy SCBI module if present

        if [[ -f $SCBI_DEFS/$MODULE ]]; then
            cp -p $SCBI_DEFS/$MODULE $DEST/scripts.d

            # and then copy patches if any
            (
                function cp-patch()
                {
                    local PATCH_FILE="$1"

                    local patch=""

                    if [[ -f "$SCBI_PATCH/$PATCH_FILE" ]]; then
                        patch="$SCBI_PATCH/$PATCH_FILE"
                    elif [[ -f "$SCBI_DEFS/patches/$PATCH_FILE" ]]; then
                        patch="$SCBI_DEFS/patches/$PATCH_FILE"
                    else
                        elog standalone patch filename \
                             $(basename $PATCH_FILE) not found
                        return 1
                    fi

                    cp $patch $DEST/.patches
                }

                local module_info=( $(get-module-ref $MODREF) )

                local module=${module_info[0]}
                local variant=${module_info[1]}
                local kind=${module_info[2]}
                local ref=${module_info[3]}

                load-module $MODULE

                fn-exists $module-$variant-patches

                if [[ $? = 0 ]]; then
                    for patch in $($module-$variant-patches $PREFIX $TARGET); do
                        cp-patch $patch
                    done

                else
                    fn-exists $module-patches

                    if [[ $? = 0 ]]; then
                        for patch in $($module-patches $PREFIX $TARGET $variant); do
                            cp-patch $patch
                        done
                    fi
                fi
            )
        fi
    fi
}

function create-standalone-package()
{
    local STANDALONE_TMP=${SCBI_TMP:-/tmp}
    local STANDALONE=$STANDALONE_TMP/sa-$(basename $SCBI_BDIR)

    rm -fr $STANDALONE

    ilog standalone Create source archive in $STANDALONE

    (
        mkdir $STANDALONE
        cd $STANDALONE

        # record the external dependencies

        echo -n "apt install" > build-deps

        # copy scbi scripts

        mkdir bin .vcs .tar .patches scripts.d

        # The main SCBI script, the runtime scripts and the current plan

        cp $HOME/bin/scbi bin/
        cp -p $SCBI_DEFS/[0-9]_* scripts.d
        [ ! -z $SCBI_PLAN ] && cp -p $SCBI_DEFS/.plan-$SCBI_PLAN scripts.d

        # copy repositories and tars for all modules with dependencies

        for module in $MODULES; do
            for-all-modules-with-meta-ext \
                copy-module-src-callback $module $STANDALONE
        done

        # create default local environment

        echo 'SCBI_ROOT=$PWD/..'               > .scbi-env-std
        echo 'SCBI_BDIR=$PWD'                 >> .scbi-env-std
        echo "SCBI_PLAN=$SCBI_PLAN"           >> .scbi-env-std

        # then create the build script

        echo '#!/bin/bash'                                      > build
        echo -n 'export PYTHON_VERSION=$(python3 --version |'  >> build
        echo " cut -d' '"' -f2 | cut -c1-3)'                   >> build
        echo 'export PATH=$PWD/bin:$PATH'                      >> build
        echo "MODULES=\"$MODULES\""                            >> build
        echo '[ ! -z $1 ] && MODULES="$*"'                     >> build
        echo 'scbi --env=std --deps $MODULES'                  >> build

        chmod u+x build
    )

    cd $STANDALONE_TMP
    tar cfz $STANDALONE.tgz $(basename $STANDALONE) 2> /dev/null
    rm -fr $STANDALONE

    ilog standalone End create source archive
}

#  Returns the source directory for the given module full reference

function get-source-dir()
{
    local target=$1
    local modref=$2

    local module_info=( $(get-module-ref $modref) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}

    local SCBI_VCS_REPO=

    if [[ $kind == DEV ]]; then
        vcs=( $(get-vcs-data $module) )

        if [[ $? = 0 ]]; then
            VCS_NAME=${vcs[2]}

            case $VCS_NAME in
                git)
                    SCBI_VCS_REPO=$SCBI_GIT_REPO
                    ;;
                svn|subversion)
                    SCBI_VCS_REPO=$SCBI_SVN_REPO
                    ;;
                hg)
                    SCBI_VCS_REPO=$SCBI_HG_REPO
                    ;;
                *)
                    elog $module unsupported VCS $VCS_NAME
                    exit 1
            esac

            DIR=$SCBI_VCS_REPO/$module

        else
            DIR=$SCBI_BDIR/$module
        fi

    else
        DIR=$SCBI_BDIR/$module/$target-$variant/src
    fi

    echo $DIR
}

#  Returns the build directory for the given module full reference

function get-build-dir()
{
    local target=$1
    local modref=$2

    local module_info=( $(get-module-ref $modref) )

    local module=${module_info[0]}
    local variant=${module_info[1]}

    DIR=$SCBI_BDIR/$module/$target-$variant/build

    echo $DIR
}
