
declare -A SCBI_LOADED=[]

############################## fn-exists

function fn-exists()
{
    declare -f $1 > /dev/null
}

############################## add-to-var
# add DIR to environment variable VAR, does nothing if DIR does not exists

function add-to-var()
{
    local VAR=$1
    local DIR=$2

    # If adding to PATH, do so only if DIR exists

    if [ -d "$DIR" -o "${VAR}" != "PATH" ] &&
           [[ ":${!VAR}:" != *":$DIR:"* ]];
    then
        # If SCBI_ENV_MODULE file exists, record the change into
        # it. This is used internally by scbi to record .log/env.cmd
        # for each module. This env file can then be sourced to replay
        # the commands manually.

        if [ ! -z $SCBI_ENV_MODULE ]; then
            echo export $VAR="${DIR}${!VAR:+:\$${VAR}}" >> $SCBI_ENV_MODULE
        fi

        export $VAR="${DIR}${!VAR:+:}${!VAR}"
    fi
}

############################## get-version-number
# return a 2 digits version number for $1

VERSION_OK=9999
VERSION_ERROR=-1

function get-version-number()
{
    echo -n "$1" | sed -e 's/[^0-9-]*\(\-\?[0-9]*\(\.[0-9]*\)\?\).*/\1/g'
}

############################## display-version

function display-version()
{
    local version=$1

    if [ "$version" = "$VERSION_OK" ]; then
        echo latest
    elif [ "$version" = "$VERSION_ERROR" ]; then
        echo not found
    else
        echo $version
    fi
}

############################## gprbuild-project
# for testing if a project compile and link

function gprbuild-project()
{
    local PRJ=$1

    (
        if [ $HOST == $TARGET ]; then
            gprbuild -p -q $PRJ -cargs -gnatwA
        else
            gprbuild -p -q --target=$TARGET $PRJ -cargs -gnatwA
        fi
    )  > /dev/null 2>&1
}

############################## check-tool

function check-tool()
{
    if [ -z "$(which $1)" ]; then
        echo Required tool $1 missing, please update the PATH
        return 1
    fi
    return 0
}

############################## check-tools

function check-tools()
{
    local res=0

    while [ "$1" != "" ]; do
        check-tool $1
        res=$(expr $res + $?)
        shift
    done
    return $res
}

############################## display-file

function display-file()
{
    local file=$1

    echo File : $file
    cat $file
}

############################## get-md5

function get-md5()
{
    md5sum | cut -d' ' -f1
}

############################## load-module
#
#

function load-module()
{
    local module=$1

    if [ -z "${SCBI_LOADED[$module]}" ]; then
        if [ -f $DEFS/$module ]; then
            source $DEFS/$module
            SCBI_LOADED[$module]=yes
            return 0
        else
            return 1
        fi
    else
        return 0
    fi
}

############################## for-all-modules

function _internal_for-all-modules()
{
    local CALLBACK=$1
    local WITH_META=$2
    local IS_ROOT=$3
    local MODREF=$4
    shift
    shift
    shift
    shift

    #  Get module information

    local module_info=( $(get-module-ref $MODREF) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    #  Then load module

    load-module $module

    if [ $? = 0 -a -z "${SCBI_CHECKED[$module]}" ]; then
        SCBI_CHECKED[$module]=yes

        if [ $WITH_META == true ]; then
            # check for meta-modules if present

            fn-exists $module-$variant-modules

            if [ $? = 0 ]; then
                for dmodule in $($module-$variant-modules); do
                    _internal_for-all-modules $CALLBACK $WITH_META false \
                                              $dmodule $@
                done
                $CALLBACK $module $MODREF $IS_ROOT $@
                return
            else
                fn-exists $module-modules

                if [ $? = 0 ]; then
                    for dmodule in $($module-modules); do
                        _internal_for-all-modules $CALLBACK $WITH_META false \
                                                  $dmodule $@
                    done
                    $CALLBACK $module $MODREF $IS_ROOT $@
                    return
                fi
            fi
        fi

        # Setup depends recursively if any

        fn-exists $module-$variant-depends

        if [ $? = 0 ]; then
            for dmodule in $($module-$variant-depends); do
                _internal_for-all-modules $CALLBACK $WITH_META false \
                                          $dmodule $@
            done
        else
            fn-exists $module-depends

            if [ $? = 0 ]; then
                for dmodule in $($module-depends); do
                    _internal_for-all-modules $CALLBACK $WITH_META false \
                                              $dmodule $@
                done
            fi
        fi

        $CALLBACK $module $MODREF $IS_ROOT $@
    fi
}

function for-all-modules()
{
    local CALLBACK=$1
    local MODREF=$2
    shift
    shift

    declare -A SCBI_CHECKED=[]
    _internal_for-all-modules $CALLBACK false true $MODREF $@
}

function for-all-modules-with-meta()
{
    local CALLBACK=$1
    local MODREF=$2
    shift
    shift

    declare -A SCBI_CHECKED=[]
    _internal_for-all-modules $CALLBACK true true $MODREF $@
}

############################## get-depends-build-id

function get-build-id-callback()
{
    local MODULE=$1
    local MODREF=$2
    local IS_ROOT=$3

    # Only compute for dependencies, not for the root module

    if [ $IS_ROOT == false ]; then
        if [ -f $BDIR/$MODULE/install-id ]; then
            var=$(cat $BDIR/$MODULE/install-id)

            if [ -f $BDIR/$MODULE/build-id-$var ]; then
                cat $BDIR/$MODULE/build-id-$var
            else
                echo $(date)
            fi
        else
            echo $(date)
        fi
    fi
}

function get-depends-build-id()
{
    (
        for-all-modules get-build-id-callback $1 | get-md5
    )
}

############################## get-build-id

function get-build-id()
{
    local PREFIX=$1
    local TARGET=$2
    local MODREF=$3
    local vid="$4"

    #  Get module information

    local module_info=( $(get-module-ref $MODREF) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    # If patch activated and patches dir exists

    local pid=no-patch-found

    if [ $PATCH = yes -a -d $PATCHES ]; then
        if [ ! -z $(ls $PATCHES/$module-*.patch 2> /dev/null) ]; then
            local pid=$(cat $PATCHES/$module-*.patch 2>&1 | get-md5)
        fi
    fi

    # Also compute id from dependencies to ensure we rebuild if one
    # dependency has changed.

    local did=$(get-depends-build-id $MODREF)

    # Now compute final id add compile version

    if [ "$HOST" = "$TARGET" -o "$(which $TARGET-gcc)" = "" ]; then
        echo -n $(gcc --version | head -1) ",$vid,$pid,$did" | get-md5

    else
        echo -n $($TARGET-gcc --version | head -1) ",$vid,$pid,$did" | get-md5
    fi
}

############################## check-tar-exists
# check if the tarball exists locally, do not try to download it
# exit status 0 = FOUND / 1 = NOT_FOUND

function check-tar-exists()
{
    local module=$1
    local version=$2

    fn-exists $module-tar

    if [[ ! $? = 0 ]]; then
        return 1
    fi

    local tar=( $($module-tar $version) )

    local proxy=${tar[0]}
    local tarcp=${tar[1]}
    local tarurl=${tar[2]}
    local tarsrc=${tar[3]}

    if [ -f $TARBALL/$tarsrc ]; then
        return 0
    else
        return 1
    fi
}

############################## get-tar

function get-tar()
{
    local module=$1
    local version=$2
    local res=0

    local tar=( $($module-tar $version) )

    local proxy=${tar[0]}
    local tarcp=${tar[1]}
    local tarurl=${tar[2]}
    local tarsrc=${tar[3]}

    #  The tarball is not present, try downloading it

    if [ ! -f $TARBALL/$tarsrc \
           -a "$tarcp" != "none" -a "$tarurl" != "none" ];
    then
        (
            fn-exists proxy-$proxy

            [[ $? = 0 ]] && proxy-$proxy

            if [ $tarcp == wget ]; then
                $tarcp $tarurl/$tarsrc -O $TARBALL/$tarsrc > $log 2>&1
            elif  [ $tarcp == curl ]; then
                $tarcp $tarurl/$tarsrc --output $TARBALL/$tarsrc > $log 2>&1
            else
                elog $module error: unknown tar protocol $tarcp
            fi

            [[ ! $? = 0 ]] && elog $module error: cannot get tar: $tarcp
        )
    fi

    [ ! -f $TARBALL/$tarsrc ] &&
        elog $module error: tarball $tarsrc not found

    ilog build extract tarball $tarsrc

    [ ! -d $BDIR/$module ] && mkdir -p $BDIR/$module > $log 2>&1

    cd $BDIR/$module

    rm -fr tarsrc tar > $log 2>&1
    ( rm -fr tartmp && mkdir -p tartmp ) > $log 2>&1
    cd tartmp

    tar xf $TARBALL/$tarsrc
    topdir=$(ls -d *)

    if [ -d "$topdir" ]; then
        mv "$topdir" ../tarsrc
        cd ..
        rmdir tartmp
        ln -s $(realpath --relative-to="$PWD" $TARBALL/$tarsrc) tar
    else
        echo Error, no top directory found.
        res=1
    fi

    return $res
}

############################## display-stat

function display-stat()
{
    echo
    echo stats
    echo -----
    echo "build dir             : $BDIR"
    echo "install prefix        : $PREFIX"
    echo "tar dir               : $TARBALL"
    echo "patches dir           : $PATCHES"
    echo "user's Git repository : $GIT_REPO"
    echo "user's SVN repository : $SVN_REPO"
    echo -n "e-mail notification   :"

    if [ $EMAIL_NOTIFICATION == no ]; then
        echo " no"
    else
        echo " $EMAIL"
    fi
}

############################## display-modules

function display-modules()
{
    echo
    echo -n "modules:"

    local linelen=0

    for module in $DEFS/[^0-9]*; do
        bn=$(basename $module)
        linelen=$(expr $linelen + ${#bn} + 1)
        if [ $linelen -gt 70 ]; then
            echo
            echo -n "        "
            linelen=${#bn}
        fi
        echo -n " $bn"
    done
    echo
}

############################## display-plans

function display-plans()
{
    echo
    echo -n "plans  :"
    local linelen=0

    if [ -z "$(ls $DEFS/.plan-* 2> /dev/null)" ]; then
        echo " none"
    else
        for module in $DEFS/.plan-*; do
            bn=$(basename $module)
            linelen=$(expr $linelen + ${#bn} + 1)
            if [ $linelen -gt 70 ]; then
                echo
                echo -n "        "
                linelen=${#bn}
            fi
            echo -n " ${bn/.plan-/}"
        done
        echo
    fi
}
