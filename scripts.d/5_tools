
declare -A SCBI_LOADED=[]
declare SCBI_RECTREE=()

############################## fn-exists
# check wether a function is defined

function fn-exists()
{
    declare -f $1 > /dev/null
}

############################## is-enabled
# check wether a feature is enabled (see option --enable-<feature>)

function is-enabled()
{
    local VAR=SCBI_${1/-/_}_SET

    if [ "${!VAR}" = "true" ]; then
        echo "yes"
        return 0
    else
        return 1
    fi
}

############################## add-to-var
# add DIR to environment variable VAR, does nothing if DIR does not exists

function add-to-var()
{
    local VAR=$1
    local DIR=$2

    # If adding to PATH, do so only if DIR exists

    if [ -d "$DIR" -o "${VAR}" != "PATH" ] &&
           [[ ":${!VAR}:" != *":$DIR:"* ]];
    then
        # If SCBI_ENV_MODULE file exists, record the change into
        # it. This is used internally by scbi to record .log/env.cmd
        # for each module. This env file can then be sourced to replay
        # the commands manually.

        if [ ! -z $SCBI_ENV_MODULE ]; then
            echo add-to-var $VAR $DIR >> $SCBI_ENV_MODULE
        fi

        export $VAR="${DIR}${!VAR:+:}${!VAR}"
    fi
}

############################## get-version-number
# return a 2 digits version number for $1

VERSION_OK=9999
VERSION_ERROR=-1

function get-version-number()
{
    echo -n "$1" | sed -e 's/[^0-9-]*\(\-\?[0-9]*\(\.[0-9]*\)\?\).*/\1/g'
}

############################## display-version

function display-version()
{
    local version=$1

    if [ "$version" = "$VERSION_OK" ]; then
        echo latest
    elif [ "$version" = "$VERSION_ERROR" ]; then
        echo not found
    else
        echo $version
    fi
}

############################## gprbuild-project
# for testing if a project compile and link

function gprbuild-project()
{
    local PRJ=$1

    (
        if [ $SCBI_HOST == $TARGET ]; then
            gprbuild -p -q $PRJ -cargs -gnatwA
        else
            gprbuild -p -q --target=$TARGET $PRJ -cargs -gnatwA
        fi
    )  > /dev/null 2>&1
}

############################## display-file

function display-file()
{
    local file=$1

    echo File : $file
    cat $file
}

############################## get-md5

function get-md5()
{
    md5sum | cut -d' ' -f1
}

############################## load-module
#
# load an SCBI build script

function load-module()
{
    local module=$1

    if [ -z "${SCBI_LOADED[$module]}" ]; then
        if [ -f $SCBI_DEFS/$module ]; then
            source $SCBI_DEFS/$module
            SCBI_LOADED[$module]=yes
            return 0
        else
            return 1
        fi
    else
        return 0
    fi
}

############################## check-dependency-tree
#
# check whether a module is in the dependency tree

function check-dependency-tree()
{
    local module=$1
    local res=1

    for m in ${SCBI_RECTREE[*]}; do
        if [ $m = $module ]; then
            res=0
        fi
    done

    return $res
}

############################## push-dependency-tree
#
# push module in dependency tree

function push-dependency-tree()
{
    local module=$1
    SCBI_RECTREE=( ${SCBI_RECTREE[*]} $module )
}

############################## pop-dependency-tree
#
# pop last module pushed from dependency tree

function pop-dependency-tree()
{
    unset SCBI_RECTREE[-1]
}

############################## for-all-modules

function _internal_for-all-modules()
{
    local CALLBACK=$1
    local WITH_META=$2
    local IS_ROOT=$3
    local WITHEXT=$4
    local MODREF=$5
    shift
    shift
    shift
    shift
    shift

    #  Get module information

    local module_info=( $(get-module-ref $MODREF) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    #  Check dependency graph to ensure there is no circularities

    check-dependency-tree $module

    if [ $? = 0 ]; then
        elog $module recursive dependencies detected
        local N=${#SCBI_RECTREE[*]}
        N=$(expr $N - 2)
        for i in $(seq 0 $N); do
            local j=$(expr $i + 1)
            elog $module " . " ${SCBI_RECTREE[$i]} '->' ${SCBI_RECTREE[$j]}
        done

        elog $module " . " ${SCBI_RECTREE[-1]} '->' $module
        exit 1
    fi

    #  Then load module

    load-module $module

    if [ $? = 0 ]; then
        if [ -z "${SCBI_CHECKED[$module]}" ]; then
            push-dependency-tree $module
            SCBI_CHECKED[$module]=yes

            if [ $WITH_META == true ]; then
                # check for meta-modules if present

                fn-exists $module-$variant-modules

                if [ $? = 0 ]; then
                    for dmodule in $($module-$variant-modules); do
                        _internal_for-all-modules $CALLBACK $WITH_META false \
                                                  $WITHEXT $dmodule $@
                    done
                    $CALLBACK $module $MODREF $IS_ROOT false $@
                    pop-dependency-tree
                    return
                else
                    fn-exists $module-modules

                    if [ $? = 0 ]; then
                        for dmodule in $($module-modules $variant); do
                            _internal_for-all-modules $CALLBACK $WITH_META false \
                                                      $WITHEXT $dmodule $@
                        done
                        $CALLBACK $module $MODREF $IS_ROOT false $@
                        pop-dependency-tree
                        return
                    fi
                fi
            fi

            # Setup depends recursively if any

            fn-exists $module-$variant-depends

            if [ $? = 0 ]; then
                for dmodule in $($module-$variant-depends); do
                    _internal_for-all-modules $CALLBACK $WITH_META false \
                                              $WITHEXT $dmodule $@
                done
            else
                fn-exists $module-depends

                if [ $? = 0 ]; then
                    for dmodule in $($module-depends $variant); do
                        _internal_for-all-modules $CALLBACK $WITH_META false \
                                                  $WITHEXT $dmodule $@
                    done
                fi
            fi

            $CALLBACK $module $MODREF $IS_ROOT false $@
            pop-dependency-tree
        fi

    else
        # module does not exists, this is an external dependency
        check-pkg $module:$ref

        if [ $WITHEXT == true ]; then
            $CALLBACK $module $MODREF $IS_ROOT true $@
        fi
    fi
}

# Iterate over all modules
function for-all-modules()
{
    local CALLBACK=$1
    local MODREF=$2
    shift
    shift

    declare -A SCBI_CHECKED=[]
    SCBI_RECTREE=()
    _internal_for-all-modules $CALLBACK false true false $MODREF $@
}

# Iterate over all modules and meta-modules
function for-all-modules-with-meta()
{
    local CALLBACK=$1
    local MODREF=$2
    shift
    shift

    declare -A SCBI_CHECKED=[]
    SCBI_RECTREE=()
    _internal_for-all-modules $CALLBACK true true false $MODREF $@
}

# Iterate over all modules, meta-modules and external dependencies
function for-all-modules-with-meta-ext()
{
    local CALLBACK=$1
    local MODREF=$2
    shift
    shift

    declare -A SCBI_CHECKED=[]
    SCBI_RECTREE=()
    _internal_for-all-modules $CALLBACK true true true $MODREF $@
}

############################## get-depends-build-id

function get-build-id-callback()
{
    local MODULE=$1
    local MODREF=$2
    local IS_ROOT=$3
    local IS_EXT=$4

    # Only compute for dependencies, not for the root module

    if [ $IS_ROOT == false ]; then
        if [ -f $SCBI_BDIR/$MODULE/install-id ]; then
            var=$(cat $SCBI_BDIR/$MODULE/install-id)

            if [ -f $SCBI_BDIR/$MODULE/build-id-$var ]; then
                cat $SCBI_BDIR/$MODULE/build-id-$var
            else
                echo $(date)
            fi
        else
            echo $(date)
        fi
    fi
}

function get-depends-build-id()
{
    (
        for-all-modules get-build-id-callback $1 | get-md5
    )
}

############################## get-patch-md5

function get-patch-md5()
{
    local PATCH_FILE="$1"

    local patch=""

    if [ -f "$SCBI_PATCH/$PATCH_FILE" ]; then
        patch="$SCBI_PATCH/$PATCH_FILE"
    elif [ -f "$SCBI_DEFS/patches/$PATCH_FILE" ]; then
        patch="$SCBI_DEFS/patches/$PATCH_FILE"
    fi

    if [ -f "$patch" ]; then
        cat $patch | get-md5
    else
        echo not-found
    fi
}

############################## get-build-id

function get-build-id()
{
    local PREFIX=$1
    local TARGET=$2
    local MODREF=$3
    local vid="$4"

    # Get module information

    local module_info=( $(get-module-ref $MODREF) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    # Include the SCBI module, if changed we need to rebuild

    local mid=no-module-script

    [ -f $SCBI_DEFS/$module ] && mid=$(cat $SCBI_DEFS/$module | get-md5)

    # If patch activated

    local pid="no-patch-found"

    if [ $PATCH = yes ]; then
        fn-exists $module-$variant-patches

        if [ $? = 0 ]; then
            for patch in $($module-$variant-patches $PREFIX $TARGET); do
                pid="$pid,$(get-patch-md5 $patch)"
            done

        else
            fn-exists $module-patches

            if [ $? = 0 ]; then
                for patch in $($module-patches $PREFIX $TARGET $variant); do
                    pid="$pid,$(get-patch-md5 $patch)"
                done
            fi
        fi
    fi

    # Also compute id from dependencies to ensure we rebuild if one
    # dependency has changed.

    local did=$(get-depends-build-id $MODREF)

    # Now compute final id add compile version

    if [ "$SCBI_HOST" = "$TARGET" -o "$(which $TARGET-gcc)" = "" ]; then
        echo -n $(gcc --version | head -1) ",$vid,$mid,$pid,$did" | get-md5

    else
        echo -n $($TARGET-gcc --version | head -1) ",$vid,$mid,$pid,$did" | get-md5
    fi
}

############################## check-tar-exists
# check if the tarball exists locally, do not try to download it
# exit status 0 = FOUND / 1 = NOT_FOUND

function check-tar-exists()
{
    local module=$1
    local version=$2

    fn-exists $module-tar

    if [[ ! $? = 0 ]]; then
        return 1
    fi

    local tar=( $($module-tar $version) )

    #local proxy=${tar[0]}
    #local tarcp=${tar[1]}
    #local tarurl=${tar[2]}
    local tarsrc=${tar[3]}

    if [ -f $SCBI_TAR/$tarsrc ]; then
        return 0
    else
        return 1
    fi
}

############################## set-proxy

function set-proxy()
{
    local NAME=$1

    fn-exists proxy-$NAME

    [[ $? = 0 ]] && proxy-$NAME
}

############################## get-tar

function get-tar()
{
    local module=$1
    local version=$2
    local res=0

    local tar=( $($module-tar $version) )

    local proxy=${tar[0]}
    local tarcp=${tar[1]}
    local tarurl=${tar[2]}
    local tarsrc=${tar[3]}

    #  The tarball is not present, try downloading it

    if [ ! -f $SCBI_TAR/$tarsrc \
           -a "$tarcp" != "none" -a "$tarurl" != "none" ];
    then
        (
            check-tool $tarcp
            if [ $? != 0 ]; then
                elog $module Required tool $tarcp missing
                exit 1
            fi

            set-proxy $proxy

            if [ $tarcp == wget ]; then
                $tarcp $tarurl/$tarsrc -O $SCBI_TAR/$tarsrc > $log 2>&1
            elif  [ $tarcp == curl ]; then
                $tarcp $tarurl/$tarsrc --output $SCBI_TAR/$tarsrc > $log 2>&1
            else
                elog $module error: unknown tar protocol $tarcp
            fi

            [[ ! $? = 0 ]] && elog $module error: cannot get tar: $tarcp
        )
    fi

    [ ! -f $SCBI_TAR/$tarsrc ] &&
        elog $module error: tarball $tarsrc not found

    ilog build extract tarball $tarsrc

    [ ! -d $SCBI_BDIR/$module ] && mkdir -p $SCBI_BDIR/$module > $log 2>&1

    cd $SCBI_BDIR/$module

    rm -fr tarsrc tar > $log 2>&1
    ( rm -fr tartmp && mkdir -p tartmp ) > $log 2>&1
    cd tartmp

    tar xf $SCBI_TAR/$tarsrc
    topdir=$(ls -d *)

    if [ -d "$topdir" ]; then
        mv "$topdir" ../tarsrc
        cd ..
        rmdir tartmp
        ln -s $(realpath --relative-to="$PWD" $SCBI_TAR/$tarsrc) tar
    else
        echo Error, no top directory found.
        res=1
    fi

    return $res
}

############################## display-stat

function display-stat()
{
    echo
    echo stats
    echo -----
    echo "build dir             : $SCBI_BDIR"
    echo "install prefix        : $SCBI_PREFIX"
    echo "tar dir               : $SCBI_TAR"
    echo "patches dir           : $SCBI_PATCH"
    echo "user's Git repository : $SCBI_GIT_REPO"
    echo "user's SVN repository : $SCBI_SVN_REPO"
    echo -n "e-mail notification   :"

    if [ $EMAIL_NOTIFICATION == no ]; then
        echo " no"
    else
        echo " $EMAIL"
    fi
}

############################## display-modules

function display-modules()
{
    echo
    echo -n "modules:"

    local linelen=0

    for module in $SCBI_DEFS/[^0-9]*; do
        bn=$(basename $module)
        linelen=$(expr $linelen + ${#bn} + 1)
        if [ $linelen -gt 70 ]; then
            echo
            echo -n "        "
            linelen=${#bn}
        fi
        echo -n " $bn"
    done
    echo
}

############################## display-plans

function display-plans()
{
    echo
    echo -n "plans  :"
    local linelen=0

    if [ -z "$(ls $SCBI_DEFS/.plan-* 2> /dev/null)" ]; then
        echo " none"
    else
        for module in $SCBI_DEFS/.plan-*; do
            bn=$(basename $module)
            linelen=$(expr $linelen + ${#bn} + 1)
            if [ $linelen -gt 70 ]; then
                echo
                echo -n "        "
                linelen=${#bn}
            fi
            echo -n " ${bn/.plan-/}"
        done
        echo
    fi
}

############################## get-build-type

function get-build-type()
{
    local KIND=$1
    local MODULE=$2
    local DEFAULT=$3

    VAR_GENERIC=${KIND}_BUILD_TYPE
    VAR_MODULE=${MODULE/-/_}_BUILD_TYPE

    [ ! -z ${!VAR_GENERIC} ] && DEFAULT=${!VAR_GENERIC}
    [ ! -z ${!VAR_MODULE} ] && DEFAULT=${!VAR_MODULE}

    echo $DEFAULT
}

############################## last-modified-directory
# returns the newest (last modified) directory matching pattern

function last-modified-directory()
{
    local PATTERN="$1"

    ls -td $PATTERN 2> /dev/null | head -1
}

############################## split all variants
# returns all variants separated with spaces, usage:
#
# for v in $(all-variants $VARIANT); do
#    ...
# done

function all-variants()
{
    local VARIANTS=$1
    echo "${VARIANTS//./ }"
}


############################## create-standalone-package

function copy-module-src-callback()
{
    local MODULE=$1
    local MODREF=$2
    local IS_ROOT=$3
    local IS_EXT=$4
    local DEST=$5

    if [ $IS_EXT == true ]; then
        echo -n " $MODULE" >> $DEST/build-deps

    else
        # copy tarball or vcs sources

        if [ -d $SCBI_BDIR/$MODULE ]; then
            ilog standalone "-   $MODULE"

            # two modules may share the same VCS or tarball
            if [ -h $SCBI_BDIR/$MODULE/tar ]; then
                FILE=$(readlink -f $SCBI_BDIR/$MODULE/tar)
                [ ! -f $DEST/.tar/$(basename $FILE) ] && cp -p $FILE $DEST/.tar
            elif [ -h $SCBI_BDIR/$MODULE/vcs ]; then
                DIR=$(readlink -f $SCBI_BDIR/$MODULE/vcs)
                [ ! -d $DEST/.vcs/$(basename $DIR) ] && cp -rp $DIR $DEST/.vcs/
            fi
        else
            elog standalone \
                 "-   $MODULE sources not found, cannot create archive"
            exit 1
        fi

        # copy SCBI module if present

        if [ -f $SCBI_DEFS/$MODULE ]; then
            cp -p $SCBI_DEFS/$MODULE $DEST/scripts.d

            # and then copy patches if any
            (
                function cp-patch()
                {
                    local PATCH_FILE="$1"

                    local patch=""

                    if [ -f "$SCBI_PATCH/$PATCH_FILE" ]; then
                        patch="$SCBI_PATCH/$PATCH_FILE"
                    elif [ -f "$SCBI_DEFS/patches/$PATCH_FILE" ]; then
                        patch="$SCBI_DEFS/patches/$PATCH_FILE"
                    else
                        elog standalone patch filename \
                             $(basename $PATCH_FILE) not found
                        return 1
                    fi

                    cp $patch $DEST/.patches
                }

                local module_info=( $(get-module-ref $MODREF) )

                local module=${module_info[0]}
                local variant=${module_info[1]}
                local kind=${module_info[2]}
                local ref=${module_info[3]}

                load-module $MODULE

                fn-exists $module-$variant-patches

                if [ $? = 0 ]; then
                    for patch in $($module-$variant-patches $PREFIX $TARGET); do
                        cp-patch $patch
                    done

                else
                    fn-exists $module-patches

                    if [ $? = 0 ]; then
                        for patch in $($module-patches $PREFIX $TARGET $variant); do
                            cp-patch $patch
                        done
                    fi
                fi
            )
        fi
    fi
}

function create-standalone-package()
{
    local STANDALONE_TMP=${SCBI_TMP:-/tmp}
    local STANDALONE=$STANDALONE_TMP/sa-$(basename $SCBI_BDIR)

    rm -fr $STANDALONE

    ilog standalone Create source archive in $STANDALONE

    (
        mkdir $STANDALONE
        cd $STANDALONE

        # record the external dependencies

        echo -n "apt install" > build-deps

        # copy scbi scripts

        mkdir bin .vcs .tar .patches scripts.d

        # The main SCBI script, the runtime scripts and the current plan

        cp $HOME/bin/scbi bin/
        cp -p $SCBI_DEFS/[0-9]_* scripts.d
        [ ! -z $SCBI_PLAN ] && cp -p $SCBI_DEFS/.plan-$SCBI_PLAN scripts.d

        # copy repositories and tars for all modules with dependencies

        for module in $MODULES; do
            for-all-modules-with-meta-ext \
                copy-module-src-callback $module $STANDALONE
        done

        # create default local environment

        echo 'SCBI_ROOT=$PWD/..'               > .scbi-env-std
        echo 'SCBI_BDIR=$PWD'                 >> .scbi-env-std
        echo "SCBI_PLAN=$SCBI_PLAN"           >> .scbi-env-std

        # then create the build script

        echo '#!/bin/bash'                                      > build
        echo -n 'export PYTHON_VERSION=$(python3 --version |'  >> build
        echo " cut -d' '"' -f2 | cut -c1-3)'                   >> build
        echo 'export PATH=$PWD/bin:$PATH'                      >> build
        echo "MODULES=\"$MODULES\""                            >> build
        echo '[ ! -z $1 ] && MODULES="$*"'                     >> build
        echo 'scbi --env=std --deps $MODULES'                  >> build

        chmod u+x build
    )

    cd $STANDALONE_TMP
    tar cfz $STANDALONE.tgz $(basename $STANDALONE) 2> /dev/null
    rm -fr $STANDALONE

    ilog standalone End create source archive
}
