
#  associative array given the status of a module, $SCBI_LOADED[$module] is
#  set to yes when module is loaded and $SCBI_LOADED[$module.$variant] is
#  set to meta (for a meta-module) / final (for a standard module).
declare -A SCBI_LOADED
declare -A SCBI_MODULE_ALIAS

declare SCBI_RECTREE=()

############################## display-stacktrace
#
function display-stacktrace()
{
    local frame=0 LINE SUB FILE

    while read LINE SUB FILE < <(caller "$frame"); do
        printf '  %s @ %s:%s\n' "${SUB}" "${FILE}" "${LINE}" > $(tty)
        ((frame++))
    done
}

############################## get-hooks
# return the hook name for the given step. This can be the
# hook for a variant and/or cross build.

function get-hook()
{
    local MODULE=$1
    local VARIANT=$2
    local STEP=$3

    local HOOK=""

    if [[ $SCBI_HOST != $SCBI_TARGET ]]; then
        fn-exists $MODULE-$VARIANT-cross-$STEP
        if [[ $? = 0 ]]; then
            HOOK=$MODULE-$VARIANT-cross-$STEP
        else
            fn-exists $MODULE-cross-$STEP
            [[ $? = 0 ]] && HOOK=$MODULE-cross-$STEP
        fi
    fi

    if [[ -z $HOOK ]]; then
        fn-exists $MODULE-$VARIANT-$STEP
        if [[ $? = 0 ]]; then
            HOOK=$MODULE-$VARIANT-$STEP
        else
            fn-exists $MODULE-$STEP
            [[ $? = 0 ]] && HOOK=$MODULE-$STEP
        fi
    fi

    echo $HOOK
}

############################## get-version-number
# return a 3 digits version number for $1

VERSION_OK=9999
VERSION_ERROR=-1

function get-version-number()
{
    echo -n "$1" | sed -e 's/[^0-9-]*\(\-\?[0-9]*\(\.[0-9]*\)\?\(\.[0-9]*\)\?\).*/\1/g'
}

############################## display-version

function display-version()
{
    local VERSION=$1

    if [[ "$VERSION" = "$VERSION_OK" ]]; then
        echo latest
    elif [[ "$VERSION" = "$VERSION_ERROR" ]]; then
        echo not found
    else
        echo $VERSION
    fi
}

############################## gprbuild-project
# for testing if a project compile and link

function gprbuild-project()
{
    local PRJ=$1

    (
        if [[ $SCBI_HOST == $TARGET ]]; then
            gprbuild -p -q $PRJ -cargs -gnatwA
        else
            gprbuild -p -q --target=$TARGET $PRJ -cargs -gnatwA
        fi
    )  > /dev/null 2>&1
}

############################## display-file

function display-file()
{
    local FILE=$1

    echo File : $FILE
    cat $FILE
}

############################## get-md5

function get-md5()
{
    md5sum | cut -d' ' -f1
}

############################## load-module
#
# load an SCBI build script

function load-module()
{
    local MODREF=$1

    local module_info=( $(get-module-ref $MODREF) )
    local module=${module_info[0]}
    local variant=${module_info[1]}

    local key="${module}.${variant}"

    if [[ -z "${SCBI_LOADED[$module]}" ]]; then
        if [[ -f $SCBI_PLUGINS/$module ]]; then
            source $SCBI_PLUGINS/$module
            SCBI_LOADED[$module]=yes
        elif [[ ! -z "${SCBI_MODULE_ALIAS[$module]}" ]]; then
            local MA=${SCBI_MODULE_ALIAS[$module]}

            if [[ -f $SCBI_PLUGINS/$MA ]]; then
                _inherit-plugin_internal $MA $module
            else
                return 1
            fi
        else
            return 1
        fi
    fi

    if [[ -z "${SCBI_LOADED[$key]}" ]]; then
        local FCT=$(get-hook $module $variant modules)

        if [[ -z $FCT ]]; then
            SCBI_LOADED[$key]=final
        else
            SCBI_LOADED[$key]=meta
        fi
    fi

    return 0
}

############################## is-meta-module
#
# return yes/0 if MODREF is a meta-module

function is-meta-module()
{
    local MODREF=$1

    local module_info=( $(get-module-ref $MODREF) )
    local module=${module_info[0]}
    local variant=${module_info[1]}

    local key="${module}.${variant}"

    if [[ -z "${SCBI_LOADED[$module]}" ]]; then
        load-module $MODREF
    fi

    if [[ "${SCBI_LOADED[$key]}" == "meta" ]]; then
        echo "yes"
        return 0
    else
        echo "no"
        return 1
    fi
}

############################## check-dependency-tree
#
# check whether a module is in the dependency tree

function check-dependency-tree()
{
    local MODULE=$1
    local res=1

    for m in ${SCBI_RECTREE[*]}; do
        if [[ $m = $MODULE ]]; then
            res=0
        fi
    done

    return $res
}

############################## push-dependency-tree
#
# push module in dependency tree

function push-dependency-tree()
{
    local MODULE=$1
    SCBI_RECTREE=( ${SCBI_RECTREE[*]} $MODULE )
}

############################## pop-dependency-tree
#
# pop last module pushed from dependency tree

function pop-dependency-tree()
{
    unset SCBI_RECTREE[${#SCBI_RECTREE[@]}-1]
}

############################## get-all-depends
#
# return each module in $module-$hook and also in each active variants
# $module-<variant>-$hook.

function get-all-depends()
{
    local MODULE="$1"
    local VARIANT="$2"
    local HOOK="$3"

    for M in $(_internal_call-variant-hooks \
                   $MODULE $HOOK "$SCBI_PREFIX" "$SCBI_TARGET" $VARIANT);
    do
        #  Module is found
        if [[ -f $SCBI_PLUGINS/$M ]]; then
            echo $M
        else
            #  Check if we have an alias for it
            local MA=${SCBI_MODULE_ALIAS[$M]}
            if [[ ! -z $MA ]] && [[ -f $SCBI_PLUGINS/$MA ]]; then
                echo $MA
            else
                echo $M
            fi
        fi
    done

    true
}

############################## for-all-modules
#
#   CALLBACK         : called for each module
#   WITH_META        : true / false
#   WITH_DEPS        : both        : depends and build-depends
#                      deps        : only depends
#                      build-deps  : only build-depends
#                      build-deps-1 : first level build-deps then deps
#   WITH_EXT         : true / false
#   DEPTH            : max recursive depth, 0 top-level module
#   LEVEL            : current recursive level
#   DEPENDS_KINDS    : dependency kind : default | build | tests
#   MODREF           : the module to iterate on
#   FORMODULE        : the module in which the ref was found
#                      (@root for top-level)
function _internal_for-all-modules()
{
    local CALLBACK=$1
    local WITH_META=$2
    local WITH_DEPS=$3
    local WITH_EXT=$4
    local DEPTH=$5
    local LEVEL=$6
    local DEPENDS_KIND=$7
    local MODREF=$8
    local FORMODULE=$9
    shift 9

    #  Wether to handle the depends or build-depends or both

    local R_DEPS=yes
    local R_BDEPS=yes
    local R_TDEPS=no

    if [[ $WITH_DEPS == deps ]]; then
        local R_BDEPS=no
    elif [[ $WITH_DEPS == tests-deps ]]; then
        local R_DEPS=no
        local R_BDEPS=no
        local R_TDEPS=yes
    elif [[ $WITH_DEPS == build-deps ]]; then
        local R_DEPS=no
    elif [[ $WITH_DEPS == build-deps-1 ]]; then
        local R_DEPS=no
    fi

    #  Check if recursive dependencies is needed

    [[ $LEVEL -gt $DEPTH ]] && return 0

    #  Get module information

    local module_info=( $(get-module-ref $MODREF $FORMODULE) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    [[ $ref = "skip" ]] && return 0

    #  Next level
    local NEXTL=$((LEVEL + 1))

    #  Check dependency graph to ensure there is no circularities

    check-dependency-tree $module

    if [[ $? = 0 ]]; then
        elog $module recursive dependencies detected

        local N=${#SCBI_RECTREE[*]}
        ((N-=2))

        for (( i=0 ; i<=$N ; i++ )); do
            local j=$((i + 1))
            elog $module " . ${SCBI_RECTREE[$i]}" '->' ${SCBI_RECTREE[$j]}
        done

        elog $module " . ${SCBI_RECTREE[-1]}" '->' $module
        exit 1
    fi

    #  Then load module

    local IS_META=false

    if [[ -z "${SCBI_CHECKED[$module]}" ]]; then
        SCBI_CHECKED[$module]=yes

        load-module $MODREF

        if [[ $? = 0 ]]; then
            push-dependency-tree $module

            local FCT=$(get-hook $module $variant modules)

            if [[ ! -z $FCT ]]; then
                IS_META=true
            fi

            if [[ $WITH_META == true ]] && [[ $IS_META == true ]]; then
                #  check for meta-modules if present. note that a meta-module
                #  does not account for a new level as it contains no module
                #  and is used in place of a set of module. so here we do not
                #  pass NEXTL but LEVEL if not in strict direct dependencies.

                local NXL=$LEVEL
                [[ $DO_DEPS == yes-direct ]] && NXL=$NEXTL

                for dmodule in $($FCT $SCBI_PREFIX $SCBI_TARGET $variant); do
                    _internal_for-all-modules $CALLBACK $WITH_META $WITH_DEPS \
                                              $WITH_EXT $DEPTH $NXL \
                                              $DEPENDS_KIND $dmodule $module $@
                done

                $CALLBACK $FORMODULE $MODREF $LEVEL \
                          $DEPENDS_KIND false $IS_META $@

                pop-dependency-tree
                return
            fi

            #  Setup depends recursively if any

            [[ $R_DEPS == yes ]] &&
                for dmodule in $(get-all-depends $module $variant depends); do
                    _internal_for-all-modules $CALLBACK $WITH_META $WITH_DEPS \
                                              $WITH_EXT $DEPTH $NEXTL \
                                              default $dmodule $module $@
                done

            #  Setup build-depends recursively if any

            [[ $R_BDEPS == yes ]] &&
                {
                    local NEXTD=$WITH_DEPS
                    [[ $NEXTD == build-deps-1 ]] && NEXTD=deps
                    for dmodule in \
                        $(get-all-depends $module $variant build-depends);
                    do
                        _internal_for-all-modules $CALLBACK $WITH_META $NEXTD \
                                                  $WITH_EXT $DEPTH $NEXTL \
                                                  build $dmodule $module $@
                    done
                }

            #  Setup tests-depends if any

            [[ $R_TDEPS == yes ]] &&
                for dmodule in \
                    $(get-all-depends $module $variant tests-depends);
                do
                    _internal_for-all-modules $CALLBACK $WITH_META $WITH_DEPS \
                                              $WITH_EXT $DEPTH $NEXTL \
                                              tests $dmodule $module $@
                done

            $CALLBACK $FORMODULE $MODREF $LEVEL \
                      $DEPENDS_KIND false $IS_META $@

            pop-dependency-tree

        else
            #  module does not exists, this is an external dependency

            if [[ $WITH_EXT == true ]]; then
                local PKGNAME=$(get-pkg-name $MODREF)
                [[ ! -z $PKGNAME ]] &&
                    $CALLBACK $FORMODULE $PKGNAME $LEVEL \
                              $DEPENDS_KIND true $IS_META $@
            else
                check-pkg $module:$ref
                if [[ $? == 1 ]] && [[ $DO_WARNING_EXTERNAL == no ]]; then
                    exit 1
                fi
            fi
        fi
    fi
}

#  Iterate over all modules
function for-all-modules()
{
    local CALLBACK=$1
    local MODREF=$2
    shift 2

    local DEPTH=99999
    [[ $DO_DEPS == yes-direct ]] && DEPTH=2

    declare -A SCBI_CHECKED
    SCBI_RECTREE=()
    _internal_for-all-modules $CALLBACK false both false $DEPTH 0 default \
                              $MODREF "@root" $@
}

#  Iterate over all modules and external dependencies
function for-all-modules-ext()
{
    local CALLBACK=$1
    local MODREF=$2
    shift 2

    local DEPTH=99999
    [[ $DO_DEPS == yes-direct ]] && DEPTH=2

    declare -A SCBI_CHECKED
    SCBI_RECTREE=()
    _internal_for-all-modules $CALLBACK false both true $DEPTH 0 default \
                              $MODREF "@root" $@
}

#  Iterate over all modules and meta-modules
function for-all-modules-with-meta()
{
    local CALLBACK=$1
    local MODREF=$2
    shift 2

    local DEPTH=99999
    [[ $DO_DEPS == yes-direct ]] && DEPTH=2

    declare -A SCBI_CHECKED
    SCBI_RECTREE=()
    _internal_for-all-modules $CALLBACK true both false $DEPTH 0 default \
                              $MODREF "@root" $@
}

#  Iterate over all depends modules and meta-modules
function for-all-modules-depends-with-meta()
{
    local CALLBACK=$1
    local MODREF=$2
    shift 2

    local DEPTH=99999
    [[ $DO_DEPS == yes-direct ]] && DEPTH=2

    declare -A SCBI_CHECKED
    SCBI_RECTREE=()
    _internal_for-all-modules $CALLBACK true deps false $DEPTH 0 default \
                              $MODREF "@root" $@
}

#  Iterate over all modules, meta-modules and external dependencies
function for-all-modules-with-meta-ext()
{
    local CALLBACK=$1
    local MODREF=$2
    shift 2

    local DEPTH=99999
    [[ $DO_DEPS == yes-direct ]] && DEPTH=2

    declare -A SCBI_CHECKED
    SCBI_RECTREE=()
    _internal_for-all-modules $CALLBACK true both true $DEPTH 0 default \
                              $MODREF "@root" $@
}

#  Iterate over all direct modules, meta-modules and external dependencies
function for-all-direct-modules-with-meta-ext()
{
    local CALLBACK=$1
    local MODREF=$2
    shift 2

    declare -A SCBI_CHECKED
    SCBI_RECTREE=()
    _internal_for-all-modules $CALLBACK true both true 1 0 default \
                              $MODREF "@root" $@
}

#  Iterate over all modules, meta-modules and external
#  dependencies. This is to construct the environment, so first we
#  check direct build-depends and then recursively the dependencies.
function for-all-modules-build-depends-with-meta()
{
    local CALLBACK=$1
    local MODREF=$2
    shift 2

    local DEPTH=99999
    declare -A SCBI_CHECKED
    SCBI_RECTREE=()
    _internal_for-all-modules $CALLBACK true build-deps-1 false $DEPTH 0 build \
                              $MODREF "@root" $@
}

function for-all-modules-tests-depends-with-meta()
{
    local CALLBACK=$1
    local MODREF=$2
    shift 2

    local DEPTH=999999
    declare -A SCBI_CHECKED
    SCBI_RECTREE=()

    _internal_for-all-modules $CALLBACK true tests-deps false $DEPTH 0 tests \
                              $MODREF "@root" $@
}

############################## for-final-modules
# list all direct final modules resolving the meta-modules references

function _internal_for-final-modules()
{
    local FORMODULE=$1
    local MODREF=$2

    #  Get module information

    local module_info=( $(get-module-ref $MODREF $FORMODULE) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    [[ $ref = "skip" ]] && return 0

    if [[ $(is-meta-module $MODREF) == yes ]]; then
        load-module $MODREF

        local FCT=$(get-hook $module $variant modules)

        for dmodule in $($FCT $SCBI_PREFIX $SCBI_TARGET $variant); do
            _internal_for-final-modules $module $dmodule
        done
    else
        echo $module
    fi
}

#  Parameters is a list of modules
function for-final-modules()
{
    declare -A SCBI_CHECKED
    SCBI_RECTREE=()

    for module in $@; do
        _internal_for-final-modules "@root" $module
    done | sort | uniq
}

############################## get-depends-build-id

function get-build-id-callback()
{
    local FORMODULE=$1
    local MODREF=$2
    local LEVEL=$3
    local DEPENDS_KIND=$4
    local IS_EXT=$5
    local IS_META=$6

    local module_info=( $(get-module-ref $MODREF $FORMODULE) )
    local module=${module_info[0]}
    local variant=${module_info[1]}

    #  Only compute for dependencies, not for the root module

    if [[ $LEVEL -gt 0 ]] && [[ $IS_META == false ]]; then
        if [[ $IS_EXT == true ]]; then
            echo ${SCBI_PKGS[$module]}
        elif [[ -f $SCBI_BDIR/$module/build-id-$variant ]]; then

            if [[ -f $SCBI_BDIR/$module/build-id-$variant ]]; then
                cat $SCBI_BDIR/$module/build-id-$variant
            else
                printf "%(%c)T" -1
            fi
        else
            printf "%(%c)T" -1
        fi
    fi
}

function get-depends-build-id()
{
    (
        for-all-direct-modules-with-meta-ext get-build-id-callback $1 | get-md5
    )
}

############################## get-patch-md5

function get-patch-md5()
{
    local PATCH_FILE="$1"

    local patch=""

    if [[ -f "$SCBI_PATCH/$PATCH_FILE" ]]; then
        patch="$SCBI_PATCH/$PATCH_FILE"
    elif [[ -f "$SCBI_PLUGINS/patches/$PATCH_FILE" ]]; then
        patch="$SCBI_PLUGINS/patches/$PATCH_FILE"
    fi

    if [[ -f "$patch" ]]; then
        cat $patch | get-md5
    else
        echo not-found
    fi
}

############################## get-build-id

function get-build-id()
{
    local PREFIX=$1
    local TARGET=$2
    local FORMODULE=$3
    local MODREF=$4
    local vid="$5"

    #  Get module information

    local module_info=( $(get-module-ref $MODREF $FORMODULE) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    #  Include the SCBI module, if changed we need to rebuild
    #  We also include the module refrence to ensure virtual modules
    #  withou build, nor install hook for native libraries (see with-variant)
    #  will get differentiated.

    local mid=$variant:$ref

    [[ -f $SCBI_PLUGINS/$module ]] &&
        mid="$mid,$(cat $SCBI_PLUGINS/$module | get-md5)"

    #  And add possible SCBI_<module>_BUILD_TYPE that is in the environment

    local var_module=SCBI_${module//-/_}_BUILD_TYPE

    [[ ! -z ${!var_module} ]] &&
        mid="$mid,${!var_module}"

    #  And possibly the SCBI_*_BUILD_TYPE global settings for
    #  some known builders.

    for builder in CMAKE CONFIGURE MAKE GPR; do
        local BVAR=SCBI_${builder}_BUILD_TYPE
        [[ ! -z ${!BVAR} ]] && mid="$mid,${!BVAR}"
    done

    #  If patch activated

    local pid="no-patch-found"

    if [[ $DO_PATCH = yes ]]; then
        local FCT=$(get-hook $module $variant patches)

        if [[ ! -z $FCT ]]; then
            for patch in $($FCT $PREFIX $TARGET $variant $kind $ref); do
                pid="$pid,$(get-patch-md5 $patch)"
            done
        fi
    fi

    #  Also compute id from dependencies to ensure we rebuild if one
    #  dependency has changed.

    local did=$(get-depends-build-id $MODREF)

    #  Also check if some environment values are used on this project

    local eid=""

    local FCT=$(get-hook $module $variant external-env)

    if [[ ! -z $FCT ]]; then
        eid=",$($FCT $PREFIX $TARGET $variant)"
    fi

    #  Now compute final id

    echo -n "$vid,$mid,$pid,$did$eid" | get-md5
}

############################## check-tar-exists
# check if the tarball exists locally, do not try to download it
# exit status 0 = FOUND / 1 = NOT_FOUND

function check-tar-exists()
{
    local MODULE=$1
    local VARIANT=$2
    local VERSION=$3

    local tar=( $(get-tar-data $MODULE $VARIANT $VERSION) )

    if [[ ! $? = 0 ]]; then
        return 1
    fi

    #local proxy=${tar[1]}
    #local taropts=${tar[2]}
    #local tarcp=${tar[3]}
    #local tarurl=${tar[4]}
    local tarsrc=${tar[5]}

    if [[ -f $SCBI_TAR/$tarsrc ]]; then
        return 0
    else
        return 1
    fi
}

############################## set-proxy

function set-proxy()
{
    local NAME=$1

    fn-exists proxy-$NAME

    [[ $? = 0 ]] && proxy-$NAME
}

############################## get-tar-data
# returns in order:
#
#  hook-variant-name-used
#        _
#  proxy  |
#  cp     | as defined in the hook
#  url    |
#  src   _|
#

function get-tar-data()
{
    local MODULE=$1
    local VARIANT=$2
    local VERSION=$3

    local TAR_FUNCTION=$(get-hook $MODULE $VARIANT tar)
    TAR_FUNCTION=${TAR_FUNCTION:=${MODULE}-tar}

    local TAR_VARIANT=default

    #  check first for module specifc VCS variant except for native
    #  variant.

    if [[ $VARIANT != "native" ]]; then
        VAR=SCBI_${MODULE//-/_}_TAR_VARIANT

        if [[ "${!VAR}" != "" ]]; then
            fn-exists $MODULE-${!VAR}-tar
            if [[ $? = 0 ]]; then
                TAR_VARIANT=${!VAR}
                TAR_FUNCTION=$module-${TAR_VARIANT}-tar
            else
                elog build "error: tar specific function for $module not found."
                exit 1
            fi
        elif [[ "${SCBI_TAR_VARIANT}" != "" ]]; then
            fn-exists $module-${SCBI_TAR_VARIANT}-tar
            if [[ $? = 0 ]]; then
                TAR_VARIANT=${SCBI_TAR_VARIANT}
                TAR_FUNCTION=$MODULE-${TAR_VARIANT}-tar
            fi
        fi
    fi

    fn-exists $TAR_FUNCTION

    if [[ $? = 0 ]]; then
        #  First we output the actual variant used
        echo $TAR_VARIANT

        fn-exists scbi-rewrite-tar
        if [[ $? = 0 ]]; then
            scbi-rewrite-tar $($TAR_FUNCTION $VERSION)
        else
            $TAR_FUNCTION $VERSION
        fi
        return 0
    else
        return 1
    fi
}

############################## get-tar

function get-tar()
{
    local MODULE=$1
    local VARIANT=$2
    local VERSION=$3

    local res=0

    local tar=( $(get-tar-data $MODULE $VARIANT $VERSION) )

    local proxy=${tar[1]}
    local taropts=${tar[2]}
    local tarcp=${tar[3]}
    local tarurl=${tar[4]}
    local tarsrc=${tar[5]}

    #  If tarsrc set to NONE, there is nothing to do for this hook

    if [[ "${tarsrc^^}" == "NONE" ]]; then
        return 0
    fi

    local options=""

    if [[ "${taropts^^}" != "NONE" ]]; then
        options="${taropts/,/ }"
    fi

    #  The tarball is not present, try downloading it

    if [[ "${tarcp^^}" != "NONE" ]]  \
           && [[ "${tarurl^^}" != "NONE" ]];
    then
        check-tool $tarcp
        if [[ $? != 0 ]]; then
            elog $MODULE Required tool $tarcp missing
            return 1
        fi

        (
            set-proxy $proxy

            local do_download=0

            #  Get SHA-1 if present

            if [[ $tarcp == wget ]]; then
                $tarcp $options $tarurl/$tarsrc.sha1 \
                       -O /tmp/$tarsrc.sha1 > $log 2>&1
            elif [[ $tarcp == curl ]]; then
                $tarcp $options $tarurl/$tarsrc.sha1 \
                       --output /tmp/$tarsrc.sha1 > $log 2>&1
            elif [[ $tarcp == cp ]] || [[ $tarcp == scp ]]; then
                $tarcp $options $tarurl/$tarsrc.sha1 \
                       /tmp/$tarsrc.sha1 > $log 2>&1
            else
                false
            fi

            #  Check SHA1 if found, check up-to-date

            if [[ $? == 0 ]]; then
                diff -q $SCBI_TAR/$tarsrc.sha1 \
                     /tmp/$tarsrc.sha1 > /dev/null 2>&1

                if [[ $? -ne 0 ]]; then
                    cp /tmp/$tarsrc.sha1 $SCBI_TAR/$tarsrc.sha1
                    do_download=1
                fi
            fi

            rm -f /tmp/$tarsrc.sha1

            if [[ $do_download == 1 ]] || [[ ! -f $SCBI_TAR/$tarsrc ]]; then
                do_download=1

                if [[ $tarcp == wget ]]; then
                    $tarcp $options $tarurl/$tarsrc \
                           -O $SCBI_TAR/$tarsrc > $log 2>&1
                elif [[ $tarcp == curl ]]; then
                    $tarcp $options $tarurl/$tarsrc \
                           --output $SCBI_TAR/$tarsrc > $log 2>&1
                elif [[ $tarcp == cp ]] || [[ $tarcp == scp ]]; then
                    $tarcp $options $tarurl/$tarsrc \
                           $SCBI_TAR/$tarsrc > $log 2>&1
                else
                    elog $MODULE error: unknown tar protocol $tarcp
                fi

                if [[ $? -ne 0 ]]; then
                    rm -f $SCBI_TAR/$tarsrc $SCBI_TAR/$tarsrc.sha1
                    elog $MODULE error: cannot get tar: $tarcp
                fi
            fi

            return $do_download
        )
    else
        false
    fi

    local downloaded=$?

    [[ ! -f $SCBI_TAR/$tarsrc ]] &&
        elog $MODULE error: tarball $tarsrc not found &&
        return 1

    [[ $downloaded == 0 ]] && [[ -d $SCBI_BDIR/$MODULE/tarsrc ]] && return 0

    ilog build extract tarball $tarsrc

    [[ ! -d $SCBI_BDIR/$MODULE ]] &&
        mkdir -p $SCBI_BDIR/$MODULE > $log 2>&1

    cd $SCBI_BDIR/$MODULE

    {
        rm -fr tarsrc tar tar-sha1
        rm -fr tartmp
        mkdir -p tartmp
    } > $log 2>&1

    cd tartmp

    tar xf $SCBI_TAR/$tarsrc

    [[ $? == 1 ]] &&
        elog $MODULE error: tarball $tarsrc is corrupted &&
        return 1

    topdir=$(ls -d *)

    if [[ -d "$topdir" ]]; then
        mv $topdir ../tarsrc
        cd ..
        rmdir tartmp
        ln -s $(realpath --relative-to="$PWD" $SCBI_TAR/$tarsrc) tar
        [[ -f $SCBI_TAR/$tarsrc.sha1 ]] &&
            ln -s $(realpath --relative-to="$PWD" $SCBI_TAR/$tarsrc.sha1) \
               tar-sha1
    else
        elog $MODULE error: no top directory found
        res=1
    fi

    return $res
}

############################## display-stat

function display-stat()
{
    echo "SCBI : $SCBI_VERSION"
    echo
    echo stats
    echo -----
    if [[ $SCBI_IS_WINDOWS == yes ]]; then
        printf "%-21s : %s\n" "host" "windows"
    else
        printf "%-21s : %s\n" "host" "$(lsb_release -s -d)"
    fi
    printf "%-21s : %s\n" "build dir"             "$SCBI_BDIR"
    printf "%-21s : %s\n" "install prefix"        "$SCBI_PREFIX"
    printf "%-21s : %s\n" "tar dir"               "$SCBI_TAR"
    printf "%-21s : %s\n" "patches dir"           "$SCBI_PATCH"
    printf "%-21s : %s\n" "user's Git repository" "$SCBI_GIT_REPO"
    printf "%-21s : %s\n" "user's SVN repository" "$SCBI_SVN_REPO"
    printf "%-21s : "     "e-mail notification"

    if [[ $SCBI_EMAIL_NOTIFICATION == no ]]; then
        echo "no"
    else
        echo "$SCBI_EMAIL"
    fi

    printf "%-21s : %s\n" "supported platforms" "${SCBI_OS_NAMES[*]}"
    printf "%-21s : %s\n" "discriminants"       "${SCBI_OS_DISCRIMINANTS[*]}"
}

############################## display-modules

function display-modules()
{
    echo
    echo -n "modules:"

    local linelen=0

    for module in $SCBI_PLUGINS/[^0-9_]*; do
        bn=$(basename $module)
        linelen=$((linelen + ${#bn} + 1))
        if [[ $linelen -gt 70 ]]; then
            echo
            echo -n "        "
            linelen=${#bn}
        fi
        echo -n " $bn"
    done
    echo
}

############################## display-modules

function display-module-version()
{
    local MODREF=$1

    local module_info=( $(get-module-ref $MODREF) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    echo -n $ref
}

############################## display-plans

function display-plans()
{
    echo
    echo -n "plans  :"
    local linelen=0

    if [[ -z "$(ls $SCBI_PLUGINS/.plan-* 2> /dev/null)" ]]; then
        echo " none"
    else
        for module in $SCBI_PLUGINS/.plan-*; do
            bn=$(basename $module)
            linelen=$((linelen + ${#bn} + 1))
            if [[ $linelen -gt 70 ]]; then
                echo
                echo -n "        "
                linelen=${#bn}
            fi
            echo -n " ${bn/.plan-/}"
        done
        echo
    fi
}

############################## create-standalone-package

function copy-module-src-callback()
{
    local FORMODULE=$1
    local MODREF=$2
    local LEVEL=$3
    local DEPENDS_KIND=$4
    local IS_EXT=$5
    local IS_META=$6
    local DEST=$7

    local module_info=( $(get-module-ref $MODREF $FORMODULE) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    if [[ $IS_EXT == true ]]; then
        echo -n " $module" >> $DEST/build-deps

    else
        #  copy tarball or vcs sources

        if [[ -d $SCBI_BDIR/$module ]]; then
            ilog standalone "-   $module"

            #  two modules may share the same VCS or tarball
            if [[ -h $SCBI_BDIR/$module/tar ]]; then
                FILE=$(readlink -f $SCBI_BDIR/$module/tar)
                [[ ! -f $DEST/.tar/$(basename $FILE) ]] &&
                    cp -p $FILE $DEST/builds/.tar
            elif [[ -h $SCBI_BDIR/$module/vcs ]]; then
                DIR=$(readlink -f $SCBI_BDIR/$module/vcs)
                [[ ! -d $DEST/.vcs/$(basename $DIR) ]] &&
                    cp -rp $DIR $DEST/builds/.vcs/
            fi
        else
            elog standalone \
                 "-   $module sources not found, cannot create archive"
            exit 1
        fi

        #  copy SCBI module if present

        if [[ -f $SCBI_PLUGINS/$module ]]; then
            cp -p $SCBI_PLUGINS/$module $DEST/scripts.d

            #  and then copy patches if any
            (
                function cp-patch()
                {
                    local PATCH_FILE="$1"

                    local patch=""

                    if [[ -f "$SCBI_PATCH/$PATCH_FILE" ]]; then
                        patch="$SCBI_PATCH/$PATCH_FILE"
                    elif [[ -f "$SCBI_PLUGINS/patches/$PATCH_FILE" ]]; then
                        patch="$SCBI_PLUGINS/patches/$PATCH_FILE"
                    else
                        elog standalone patch filename \
                             $(basename $PATCH_FILE) not found
                        return 1
                    fi

                    cp $patch $DEST/builds/.patches
                }

                load-module $MODREF

                local FCT=$(get-hook $module $variant patches)

                if [[ ! -z $FCT ]]; then
                    for patch in $($FCT $PREFIX $TARGET $VARIANT $kind $ref); do
                        cp-patch $patch
                    done
                fi
            )
        fi
    fi
}

function create-standalone-package()
{
    local STANDALONE_TMP=${SCBI_TMP:-/tmp}
    local STANDALONE=$STANDALONE_TMP/sa-$(basename $SCBI_BDIR)

    rm -fr $STANDALONE

    ilog standalone Create source archive in $STANDALONE

    (
        mkdir $STANDALONE
        cd $STANDALONE

        #  record the external dependencies

        echo -n "apt install" > build-deps

        #  copy scbi scripts

        mkdir -p bin scripts.d
        mkdir -p builds/.vcs builds/.tar builds/.patches

        #  The main SCBI script, the runtime scripts and the current plan

        cp $SCBI_BINARY bin/
        cp -p $SCBI_PLUGINS/[0-9]_* scripts.d
        [[ ! -z $SCBI_PLAN ]] && cp -p $SCBI_PLUGINS/.plan-$SCBI_PLAN scripts.d

        #  copy repositories and tars for all modules with dependencies

        for module in $SCBI_MODULES; do
            for-all-modules-with-meta-ext \
                copy-module-src-callback $module $STANDALONE
        done

        #  create default local environment

        echo 'SCBI_ROOT=$PWD'                  > .scbi-env-std
        echo 'SCBI_BDIR=$SCBI_ROOT/builds'    >> .scbi-env-std
        echo 'SCBI_PREFIX=$SCBI_BDIR/install' >> .scbi-env-std
        echo 'SCBI_TAR=$SCBI_BDIR/.tar'       >> .scbi-env-std
        echo 'SCBI_PATCH=$SCBI_BDIR/.patches' >> .scbi-env-std
        echo 'SCBI_LOGS=$SCBI_BDIR/.logs'     >> .scbi-env-std
        echo "SCBI_PLAN=$SCBI_PLAN"           >> .scbi-env-std

        #  then create the build script

        echo '#!/bin/bash'                                      > build
        echo -n 'export PYTHON_VERSION=$(python3 --version |'  >> build
        echo " cut -d' '"' -f2 | cut -c1-3)'                   >> build
        echo 'export PATH=$PWD/bin:$PATH'                      >> build
        echo "SCBI_MODULES=\"$SCBI_MODULES\""                  >> build
        echo '[ ! -z $1 ] && SCBI_MODULES="$*"'                >> build
        echo './bin/scbi --env=std --deps $SCBI_MODULES'       >> build

        chmod u+x build
    )

    cd $STANDALONE_TMP
    tar cfz $STANDALONE.tgz $(basename $STANDALONE) 2> /dev/null
    rm -fr $STANDALONE

    ilog standalone End create source archive
}

#  Returns the source directory for the given module full reference

function get-source-dir()
{
    local TARGET=$1
    local MODREF=$2

    local module_info=( $(get-module-ref $MODREF) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}

    local SCBI_VCS_REPO=

    if [[ $kind == DEV ]]; then
        vcs=( $(get-vcs-data $module $variant) )

        if [[ $? = 0 ]]; then
            VCS_NAME=${vcs[3]}

            case $VCS_NAME in
                git)
                    SCBI_VCS_REPO=$SCBI_GIT_REPO
                    ;;
                svn|subversion)
                    SCBI_VCS_REPO=$SCBI_SVN_REPO
                    ;;
                hg)
                    SCBI_VCS_REPO=$SCBI_HG_REPO
                    ;;
                *)
                    elog $module unsupported VCS $VCS_NAME
                    exit 1
            esac

            DIR=$SCBI_VCS_REPO/$module

        else
            DIR=$SCBI_BDIR/$module
        fi

    else
        DIR=$SCBI_BDIR/$module/$TARGET-$variant/src
    fi

    echo $DIR
}

#  Returns the build directory for the given module full reference

function get-build-dir()
{
    local TARGET=$1
    local MODREF=$2

    local module_info=( $(get-module-ref $MODREF) )

    local module=${module_info[0]}
    local variant=${module_info[1]}

    DIR=$SCBI_BDIR/$module/$TARGET-$variant/build

    echo $DIR
}

############################## module-clean-install

function module-clean-install()
{
    local MPREFIX=$1
    local FORMODULE=$2
    local MODULE=$3
    local VARIANT=$4
    local TARGET=$5
    local OOT=$6

    local SUDO=""
    local _IDIR=""

    fn-exists $MODULE-$VARIANT-prefix

    if [[ $? = 0 ]] && [[ "$SCBI_DEFAULT_PREFIX" = "yes" ]]; then
        _IDIR=$($MODULE-$VARIANT-prefix $MPREFIX $TARGET)
    else
        fn-exists $MODULE-prefix

        if [[ $? = 0 ]] && [[ "$SCBI_DEFAULT_PREFIX" = "yes" ]]; then
            _IDIR=$($MODULE-prefix $MPREFIX $TARGET $VARIANT)
        else
            _IDIR=$SCBI_PREFIX
        fi
    fi

    if [[ $_IDIR != NONE ]]; then
        if [[ ! -w ${_IDIR} ]]; then
            SUDO=sudo
        fi

        #  note that we do not want to fail here
        #  delete files in the final destination installation prefix.
        #  then delete the module install location (double check that the
        #  directory is the right one).

        if [[ -f $MPREFIX/../manifest ]]; then
            cat $MPREFIX/../manifest | while read file; do
                $SUDO rm -f ${_IDIR}/$file
                echo ${file%/*}
            done | sort | uniq | while read dir; do
                rmdir --ignore-fail-on-non-empty --parents \
                      ${_IDIR}/$dir > /dev/null 2>&1 ;
            done &&
                if [[ $(basename $MPREFIX) = "install" ]] \
                       && [[ $(basename $(dirname $MPREFIX)) = "$module" ]];
                then
                    cd $MPREFIX && rm -fr .
                fi
        fi
    fi
}
