#!/bin/bash
#
#  SCBI - (C) Pascal Obry - 2007-2023
#

shopt -s extglob

declare -A SCBI_INI_DB

SCBI_VERSION=@VERSION@
SCBI_BINARY=$(realpath $0)

############################## do-clear-steps

function do-clear-steps()
{
    [[ $DO_SETUP   == yes ]] && DO_SETUP=no
    [[ $DO_CONFIG  == yes ]] && DO_CONFIG=no
    [[ $DO_BUILD   == yes ]] && DO_BUILD=no
    [[ $DO_INSTALL == yes ]] && DO_INSTALL=no
    [[ $DO_WRAPUP  == yes ]] && DO_WRAPUP=no
}

############################## check-tool

function check-tool()
{
    if [[ -z "$(command -v $1 2> /dev/null)" ]]; then
        return 1
    fi
    return 0
}

############################## check-tools

function check-tools()
{
    local res=0

    while [[ -n $1 ]]; do
        check-tool $1
        res=$(($res + $?))
        shift
    done
    return $res
}

############################## check-tools-abort

function check-tools-abort()
{
    local TOOLS="$1"

    check-tools $TOOLS

    [[ $? != 0 ]] &&
        echo Required tools ${TOOLS} missing, please install &&
        exit 1
}

############################## ini-load-file

function ini-load-file()
{
    local INIFILE=$1

    local cur_section=""
    local cur_key=""
    local cur_val=""

    while read -r line; do
        #  First skip comments
        if [[ "$line" =~ ^[:space:]*\#(.*) ]]; then
            continue
        elif [[ "$line" =~ ^(\[)(.*)(\])$ ]]; then
            cur_section=${BASH_REMATCH[2]}

        elif [[ "$line" =~ ^([^=]+)=([^=]+)$ ]]; then
            cur_key=${BASH_REMATCH[1]// /}
            cur_val=${BASH_REMATCH[2]%%+ }

            if [[ -n "$cur_key" ]]; then
                # section + key is the associative in bash array, the
                # field seperator is a dot.
                db_key="${cur_section}${cur_section:+.}${cur_key}"
                SCBI_INI_DB[$db_key]=$cur_val
            fi
        fi
    done < $INIFILE
}

function ini-load-files()
{
    [[ -f $HOME/.scbi ]] && ini-load-file $HOME/.scbi
    [[ -f .scbi ]] && ini-load-file .scbi
    [[ -f $SCBI_INI_FILE ]] && ini-load-file $SCBI_INI_FILE
}

############################## ini-apply-values

function ini-set-enable()
{
    local FEATURES=$1

    for F in ${FEATURES/,/ }; do
        export SCBI_${F//-/_}_SET=true
    done
}

function ini-get-option()
{
    local SECTION=$1
    local VAR=$2

    if [[ -n ${SCBI_INI_DB[$SECTION.$VAR]} ]]; then
        eval echo "${SCBI_INI_DB[$SECTION.$VAR]}"
    elif [[ -n $SECTION ]] && [[ -n ${SCBI_INI_DB[common.$VAR]} ]]; then
        eval echo "${SCBI_INI_DB[common.$VAR]}"
    elif [[ -n ${SCBI_INI_DB[$VAR]} ]]; then
        eval echo "${SCBI_INI_DB[$VAR]}"
    else
        echo -n ""
    fi
}

function ini-apply-values()
{
    local SECTION=$1

    local sec
    local var
    local val

    #  A table of value to be read in the ini file and the
    #  corresponding SCBI variable.

    declare -A KV=(
        ["build-dir"]="SCBI_BDIR"
        ["env"]="ENV_NAME"
        ["git-repo"]="SCBI_GIT_REPO"
        ["hg-repo"]="SCBI_HG_REPO"
        ["jobs"]="SCBI_JOBS"
        ["log"]="SCBI_LOGS"
        ["patch"]="SCBI_PATCH"
        ["plan"]="SCBI_PLAN"
        ["plugins"]="SCBI_PLUGINS"
        ["prefix"]="SCBI_PREFIX"
        ["root-dir"]="SCBI_ROOT"
        ["svn-repo"]="SCBI_SVN_REPO"
        ["archives"]="SCBI_ARCHIVES"
        ["target"]="SCBI_TARGET"
    )

    for K in ${!SCBI_INI_DB[*]}; do
        if [[ "$K" =~ ^([^\.]+)\.([^\.]+)$ ]]; then
            sec=${BASH_REMATCH[1]}
            var=${BASH_REMATCH[2]}
        else
            sec=""
            var=$K
        fi
        val=""

        #  If root/common section or selected section

        local _SKIP=",setup,config,build,install,wrapup,force,modules,stat,"
        local _SKIP+="update,purge,archive,deps,safe,tar,no-patch,enable,run,"

        if ( [[ -z $sec ]] && [[ -z $SECTION ]] ) ||
               ( [[ $sec == "common" ]] && [[ -n $SECTION ]] ) ||
               [[ $SECTION == $sec ]];
        then
            #  If this is a controlled variable (known in KV table)
            if [[ -n ${KV[$var]} ]]; then
                var=${KV[$var]}
                val=$(ini-get-option "$SECTION" $K)
            else
                #  A free variable, just assign
                var=${var//-/_}
                val=$(eval echo ${SCBI_INI_DB[$K]})
            fi

            #  Value should not be null and variable not in _SKIP list as
            #  handled below.

            if [[ -n $val ]] && [[ ${_SKIP/,$var,//} == ${_SKIP} ]]; then
                export $var=$val
            fi
        fi
    done

    #  Set features if enabled

    local FEAT=$(ini-get-option "$SECTION" enable)

    if [[ -n $FEAT ]]; then
        ini-set-enable $FEAT
    fi

    #  Set modules' list

    SCBI_MODULES=$(ini-get-option "$SECTION" modules)

    #  Set options controlled with a DO_<NAME>

    for OPTS in setup config build install wrapup color \
                      quiet force update purge archive stat;
    do
        local VAR=DO_${OPTS^^}
        local O=$(ini-get-option "$SECTION" $OPTS)
        [[ -n $O ]] && export $VAR=$O
    done

    #  Set other options

    for OPTS in safe tar no-patch; do
        local O=$(ini-get-option "$SECTION" $OPTS)
        [[ ${O^^} == YES ]] &&
            SCBI_INI_OPTIONS+="${SCBI_INI_OPTIONS:+ }--$OPTS"
    done

    local O="$(ini-get-option "$SECTION" deps)"
    [[ -n ${O} ]] && DEPS=$O

    #  Run option

    local O="$(ini-get-option "$SECTION" run)"
    [[ -n ${O} ]] &&
        {
            DO_RUN=yes
            DO_RUN_CMD="$O"
        }

    #  Tests option

    local O="$(ini-get-option "$SECTION" tests)"
    [[ -n ${O} ]] &&
        {
            DO_TEST=yes
            [[ $O == only ]] &&
                {
                    do-clear-steps
                    DO_TEST=yes-only
                }
        }

    local O="$(ini-get-option "$SECTION" tests-list)"
    [[ -n "${O}" ]] &&
        {
            SCBI_TESTS_OPTIONS="$O"
        }

    #  Finally whatever specific options are given

    SCBI_INI_OPTIONS+="${SCBI_INI_OPTIONS:+ }"$(ini-get-option "$SECTION" options)
}

CDPATH=

#  Environment

#  Setup host & Check for tools used by scbi itself

SCBI_IS_WINDOWS=no
SCBI_OS_MODULE=
SCBI_OS_MODULE_FILE=

check-tools-abort rsync sed diff

if [[ $(uname -a) =~ Cygwin ]]; then
    SCBI_IS_WINDOWS=yes
    SCBI_HOST=x86_64-cygwin
    SCBI_OS_MODULE=windows
elif [[ $(uname -a) =~ Msys ]]; then
    SCBI_IS_WINDOWS=yes
    SCBI_HOST=x86_64-mingw64
    SCBI_OS_MODULE=windows
else
    check-tools-abort gcc
    SCBI_HOST=$(gcc -dumpmachine | sed -e 's/-pc//;s/-unknown//')
fi

SCBI_TARGET=$SCBI_HOST
SCBI_TARGET_SPECIFIED=no
SCBI_ENV_DIR=
ENV_NAME=${SCBI_DEFAULT_ENV:+-$SCBI_DEFAULT_ENV}

#  General script setup
SCBI_DLOG=on-failure
SCBI_PLUGINS="$PWD/scripts.d"
SCBI_JOBS=${SCBI_JOBS:-$(grep -c ^processor /proc/cpuinfo 2>/dev/null || sysctl -n hw.ncpu)}
SCBI_HALF_JOBS=${SCBI_HALF_JOBS:-$((SCBI_JOBS / 2))}

#  Modules to be handled and already handled
SCBI_MODULES=
SCBI_HANDLED="$(mktemp -p /dev/shm/)"
SCBI_CURRENT_MODULE=

#  Actions setup
DO_PURGE=no
SCBI_PREFIX=
SCBI_DEFAULT_PREFIX=yes
DO_QUIET=no
DO_UPDATE=no
DO_ARCHIVE=no
DO_FORCE=no
DO_MOD_VER=no
DO_STAT=no
DO_DEPS=no
DO_EXT=no
DO_CLEAN_INSTALL=no
DO_LIST_VER=yes
DO_PLAN=no
DO_STORE=no
DEPS=no
ISOOT=yes
DO_PATCH=yes
STEPS=""
BUILD_SCBI_TARGET=
SCBI_PLAN=
SCBI_PLAN_CL=
ARCHIVE_CACHE=yes
DRY_RUN=no
SAFE_MODE=no
DO_STANDALONE=no
SCBI_FILTER=all
CMDLINE_BUILD_DIR=
DO_HELP=no
DO_VERSION=no
DO_SHELL=no
DO_RUN=no
DO_RUN_CMD=
DO_WARNING_EXTERNAL=no
SCBI_TESTS_OPTIONS=

DO_COLOR=no
SCBI_CBOLD=""
SCBI_CTEXT=""
SCBI_CCLEAR=""
SCBI_CRED=""
SCBI_CGREEN=""
SCBI_CBLUE=""

DO_SETUP=yes
DO_CONFIG=yes
DO_BUILD=yes
DO_INSTALL=yes
DO_TEST=no
DO_WRAPUP=yes

export SCBI_ROOT SCBI_BDIR SCBI_CLANG_VERSION SCBI_GTK_VERSION SCBI_PLAN
export SCBI_HOST SCBI_TARGET SCBI_PLUGINS SCBI_JOBS SCBI_HALF_JOBS
export SCBI_IS_WINDOWS SCBI_VERSION SCBI_BINARY SCBI_OS_NAME SCBI_OS_VERSION
export SCBI_CURRENT_MODULE SCBI_ENV_DIR
export SCBI_CBOLD SCBI_CRED SCBI_CGREEN SCBI_CBLUE SCBI_CCLEAR SCBI_CTEXT

############################## check-handled
#
# check whether a module has already been handled

function check-handled()
{
    local KEY=$1

    grep "^$KEY" $SCBI_HANDLED &> /dev/null

    if [[ $? = 1 ]]; then
        echo "$KEY" >> $SCBI_HANDLED
        return 0
    else
        return 1
    fi
}

############################## clean-up
#
# clean-up before exit

function clean-up()
{
    rm -f $SCBI_HANDLED
    rm -f $SCBI_LINE_SEP
}

############################## load-module-env
#
# load an environment description, this cannot be in 5_tools as an
# envrionment script must be loaded before any other.

function load-module-env()
{
    local ENAME=env${1:+-}$1
    local ENV=$PWD/.scbi-$ENAME

    # if not found in current directory look in definitions install dir

    if [[ ! -f $ENV ]]; then
        # look for it in parent directory too
        ENV=$PWD/../.scbi-$ENAME

        if [[ ! -f $ENV ]]; then
            # look for it in $HOME directory too
            ENV=$HOME/.scbi-$ENAME

            if [[ ! -f $ENV ]]; then
                ENV=$SCBI_PLUGINS/.$ENAME
            fi
        fi
    fi

    if [[ -f $ENV ]]; then
        SCBI_ENV_DIR=$(dirname $ENV)
        source $ENV
    elif [[ -n $1 ]]; then
        echo build environment .$ENAME not found
        exit 1
    fi
}

############################## module-wrapper
#
# called for each module and step

function module-wrapper()
{
    local PREFIX=$1
    local MODULE=$2
    local VARIANT=$3
    local STEP=$4

    local dvariant=""

    #  set variant display if not part of step and not default

    if [[ ${STEP/$VARIANT/} == $STEP && "$VARIANT" != "default" ]]; then
        dvariant=" [${VARIANT//./ }]"
    fi

    if [[ $STEP = "build" ]] && [[ -n $BUILD_SCBI_TARGET ]]; then
        mstep=build-$BUILD_SCBI_TARGET
    else
        mstep=$STEP
    fi

    #  global logs
    log=$SCBI_LOGS/$TODAY/$SCBI_TARGET-$MODULE-$VARIANT-$mstep.log

    #  local log for last module command
    mlog=$SCBI_BDIR/$MODULE/$SCBI_TARGET-$VARIANT/logs/$mstep.log
    clog=$SCBI_BDIR/$MODULE/$SCBI_TARGET-$VARIANT/logs/$mstep.cmd

    ilog $MODULE $mstep$dvariant starting

    (
        cd $SCBI_BDIR/$MODULE >> $log 2>&1

        #  Go to build directory

        if [[ "$STEP" =~ (pre-|post-)*(setup|wrapup)$ ]]; then
            cd $SCBI_BDIR/$MODULE
        elif [[ -d $SCBI_BDIR/$MODULE/$SCBI_TARGET-$VARIANT/build ]]; then
            cd $SCBI_BDIR/$MODULE/$SCBI_TARGET-$VARIANT/build
        else
            #  a native module has no sources for example
            cd $SCBI_BDIR/$MODULE
        fi

        #  Record run command

        show-command $MODULE $MODULE-$mstep \
                     $PREFIX $SCBI_TARGET $VARIANT 2&> $clog

        #  Call module step

        local res=0

        local IS_TESTS=no
        local TEST_OPTS=

        if [[ "$STEP" =~ "tests" ]]; then
            IS_TESTS=yes
            TESTS_OPTS="$SCBI_TESTS_OPTIONS"
        fi

        if [[ $SCBI_DLOG = yes ]] || [[ "$IS_TESTS" = "yes" ]]; then
            $MODULE-$mstep $PREFIX $SCBI_TARGET $VARIANT "$TESTS_OPTS" 2>&1 \
                | tee -a $log | tee $mlog
            #  We want the status of the first command and not the tee ones
            res=${PIPESTATUS[0]}
        else
            {
                PS4="_TRACE: "
                set -o xtrace
                $MODULE-$mstep $PREFIX $SCBI_TARGET $VARIANT
                res=$?
                set +o xtrace
                return $res
            } 2>&1 | tee $mlog &>> $log
            res=${PIPESTATUS[0]}
        fi

        #  Check for errors

        if [[ $res -ne 0 ]]; then
            if [[ $SCBI_DLOG = on-failure ]] && [[ "$STEP" != "tests" ]]; then
                tail -100 $mlog | grep -v "^_[_]*TRACE: "
            fi
            elog $MODULE $mstep failed with error $res

            RDIR=$SCBI_BDIR/$MODULE/$SCBI_TARGET-$VARIANT/logs

            case $STEP in
                config|build|install|cross-config|cross-build|cross-install)
                    elog $MODULE to reproduce:
                    elog $MODULE bash $RDIR/$mstep.cmd
                    elog $MODULE use bash -x option for debug
                    ;;
            esac

            return $res
        else
            ilog $MODULE $mstep$dvariant completed
            return 0
        fi
    )
    return $?
}

############################## module-variant-wrapper
#
# called for each module, variant and step, switch to proper step to call
# depending on the existence of the variant.

function _internal_module-variant-wrapper()
{
    local PREFIX=$1
    local MODULE=$2
    local VARIANT=$3
    local FCT=$4

    [[ -z $FCT ]] && return

    #  Now check that the body is not empty (default variant)
    local BODY=$(declare -f $FCT | tail --lines=-3)
    local BODY=$(echo $BODY)
    local res=0

    if [[ "$BODY" != "{ true }" ]]; then
        module-wrapper $PREFIX $MODULE \
                       $VARIANT ${FCT#"${MODULE}-"} || exit 1
        res=$?
    fi
    return $res
}

function module-variant-wrapper()
{
    local PREFIX=$1
    local MODULE=$2
    local VARIANT=$3
    local STEP=$4

    local FCT=""
    get-hook FCT $MODULE $VARIANT $STEP

    if [[ -n $FCT ]]; then
        _internal_module-variant-wrapper $PREFIX $MODULE $VARIANT $FCT
    fi
}

############################## usage

function usage()
{
    echo
    echo SCBI $SCBI_VERSION
    echo
    echo $0 [options] module1 [module2 ... modulen]

    echo ""
    echo "   modulen  <name>           build from repository main branch"
    echo "   modulen  <name>/<variant> build <variant> from repository version"
    echo "   modulen  <name>:<branch>  build from repository version <branch>"
    echo "   modulen  <name>:#<ver>    build from tarbal version <ver>"
    echo "   modulen  <name>:dev       build from user's repository current branch"
    echo ""
    echo "   -h | --help             this help message"
    echo "   -v | --version          display driver & plug-ins versions"
    echo "   -q | --quiet            do not display information log"
    echo "      | --color:[n]        use colored output (no, dark, light)"
    echo "      | --ini=<section>    load ini file given section"
    echo "   -t | --prefix=<dir>     the global install directory"
    echo "      | --build-dir=<dir>  the root build directory."
    echo "   -e | --env=<name>       environment file ~/.scbi-<name>"
    echo "      | --plan=<name>      a build plan for modules"
    echo "      | --enable-<name>    enable feature name"
    echo "   -t | --target=<name>    the target to build for ($SCBI_TARGET)"
    echo "      | --plugins=<dir>    specify the modules/plugins directory"
    echo "      | --store KEY VAL    list, set or retrieve private store data"
    echo "   -j | --jobs=<n>         max compilation jobs \$SCBI_JOBS"
    echo "   -S | --no-setup         skip setup"
    echo "   -I | --no-install       skip install"
    echo "   -W | --no-wrapup        skip wrapup"
    echo "   -u | --update           do update"
    echo "   -s | --setup            do setup"
    echo "   -c | --config           do config"
    echo "   -b | --build            do build"
    echo "   -i | --install          do install"
    echo "   -w | --wrapup           do wrapup"
    echo "      | --clean-install    clean installation directory"
    echo "      | --tar              check for tar only if explicitly specified"
    echo "      | --tests[:only][=O] run the testsuite, eventually build"
    echo "   -d | --deps[:warning]   check/build dependencies"
    echo "   -a | --archive          build binary archive"
    echo "      | --standalone       create a standalone source archive"
    echo "   -l | --log:n            log display control yes|no|on-failure"
    echo "   -f | --force            force rebuild, do not check build id"
    echo "   -p | --purge[:only]     remove build directory, build eventually"
    echo "      | --safe             clean-up build directory before configure"
    echo "      | --shell:n          start a shell with module's environment"
    echo "      | --run:\"cmd arg\"    run command in module's environment"
    echo "      | --list-depends:n   list module's dependencies (direct, full)"
    echo "      | --list-externals:n list module's external dependencies"
    echo "      | --list-no-version  do not display modules/externals version"
    echo "      | --list-filter:n    filter depends/external for dev or runtime"
    echo "      | --list-plan        list current current plan"
    echo "      | --module-ref:n     display variant/version of specific module"
    echo "      | --dry-run          only list modules handled"
    echo "      | --stat[:full]      display some status of current setup"
    echo "   -n | --no-patch         do not apply patches"
}

############################## handle-modue-env
#
# call module ENV, checking for variant

SCBI_ENV_MODULE=

function handle-module-env()
{
    local FORMODULE=$1
    local MODREF=$2
    local ENV=$3

    #  Get module information

    local module_info=()
    get-module-ref module_info $MODREF $FORMODULE

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local ref=${module_info[3]}

    [[ $ref = "skip" ]] && return 0

    #  Then setup the current module

    local TVDIR=$SCBI_BDIR/$module/$SCBI_TARGET-$variant

    if [[ -n $SCBI_ENV_MODULE ]]; then
        echo >> $SCBI_ENV_MODULE
        echo "# $MODREF" >> $SCBI_ENV_MODULE
        SCBI_MODULES_DIR["$module"]+="$TVDIR/install"
        SCBI_MODULES_DIR["${module}@src"]+="$TVDIR/src"
        SCBI_MODULES_DIR["${module}@build"]+="$TVDIR/build"
    fi

    plugin-call-variant-hooks \
        $module $ENV \
        $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install $SCBI_TARGET $variant
}

############################## register-depends-callback
# used for --list-depends and --list-external

declare -a MODULE_LIST

function register-depends-callback()
{
    local FORMODULE=$1
    local MODREF=$2
    local LEVEL=$3
    local DEPENDS_KIND=$4
    local IS_EXT=$5
    local IS_META=$6

    local IS_BUILD_DEPENDS=false
    [[ $DEPENDS_KIND == build ]] && IS_BUILD_DEPENDS=true

    local selext=false
    local selbuild=false
    local selected=false

    if [[ $DO_EXT != no ]] || [[ $IS_EXT == false ]]; then
        selext=true
    fi

    if [[ $SCBI_FILTER == all ]] || [[ $SCBI_FILTER == dev ]]; then
        selbuild=true
    fi

    if [[ $selbuild == $IS_BUILD_DEPENDS ]] || [[ $SCBI_FILTER == all ]]; then
        selected=true
    fi

    if [[ $DO_DEPS == yes-direct ]] && [[ $LEVEL -ne 1 ]]; then
        selected=false
    fi

    if [[ $DO_EXT == yes-only ]] && [[ $IS_EXT == false ]]; then
        selected=false
    fi

    if [[ $selext == true ]] && [[ $selected == true ]]; then
        if [[ "$SCBI_FILTER" == "run" ]] &&
               [[ "${MODREF: -4}" == "-dev" ]];
        then
            MOD=$(get-lib-for-dev $MODREF)
        else
            MOD=$MODREF
        fi

        #  Do we need the version of the module

        if [[ $DO_LIST_VER == yes ]]; then
            local module_info=()
            get-module-ref module_info $MODREF $FORMODULE

            local module=${module_info[0]}
            local ref=${module_info[3]}

            if [[ $ref == NONE ]]; then
                if [[ $IS_EXT == true ]]; then
                    local V=$(get-pkg-version $module)
                    if [[ -z $V ]]; then
                        MOD="$module"
                    else
                        MOD="$module:$V"
                    fi
                else
                    MOD="$module"
                fi
            else
                MOD="$module:$ref"
            fi
        fi

        MODULE_LIST+=($MOD)
    fi
}

############################## handle-env
#
# recursively set the environment for the module based on the dependencies

function handle-env-callback()
{
    local FORMODULE=$1
    local MODREF=$2
    local LEVEL=$3
    local DEPENDS_KIND=$4
    local IS_EXT=$5
    local IS_META=$6

    #  Only the environment of the dependencies and not self. The env
    #  hook of a module is only used for clients and not for the module
    #  itself.

    [[ $LEVEL -ge 1 ]] || [[ $DEPENDS_KIND == tests ]] &&
        handle-module-env $FORMODULE $MODREF env
}

function handle-env()
{
    local FORMODULE=$1
    local MODREF=$2

    for-all-modules-depends-with-meta handle-env-callback $MODREF
}

function handle-build-depends-env()
{
    local FORMODULE=$1
    local MODREF=$2

    for-all-modules-build-depends-with-meta handle-env-callback $MODREF
}

function handle-tests-depends-env()
{
    local FORMODULE=$1
    local MODREF=$2

    for-all-modules-tests-depends-with-meta handle-env-callback $MODREF
}

############################## is-module-up-to-date

function is-module-up-to-date()
{
    local MODREF=$1
    local FORMODULE=$2

    local module_info=()
    get-module-ref module_info $MODREF $FORMODULE

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    load-module $MODREF

    local mver=$VERSION_ERROR

    #  Get the version hook, if none present all versions are ok

    local FCT=""
    get-hook FCT $module $variant version

    if [[ -n $FCT ]]; then
        TDIR=$(mktemp -d)

        [[ $? != 0 ]] &&
            echo cannnot create a temp directory &&
            exit 1

        pushd $TDIR > /dev/null 2>&1

        mver=$( handle-build-depends-env "@root" $MODREF
                handle-module-env "@root" $MODREF env
                $FCT $SCBI_PREFIX $SCBI_TARGET
              )

        popd > /dev/null 2>&1

        rm -r $TDIR
    else
        mver=$VERSION_OK
    fi

    local SID=""

    if [[ $variant == "native" ]]; then
        #  A native variant
        SID="native-$ref"
    elif [[ -e $SCBI_BDIR/$module/src ]]; then
        #  A VCS or TAR
        case "$kind" in
            NONE|BRANCH)
                SID="vcs-$ref"
                ;;
            VERSION)
                SID="archive-$ref"
                ;;
            DEV)
                SID="$ref"
                ;;
        esac
    else
        #  No sources
        SID="none-$ref"
    fi

    local rsid=1

    #  If we have a source-id check if the content corresponds to SID

    [[ -f $SCBI_BDIR/$module/source-id ]] &&
        [[ "$(cat $SCBI_BDIR/$module/source-id)" == $SID ]] &&
            rsid=0;

    #  Clean-up the version number (only digits and a single dot)

    get-version-number mver $mver

    if [[ "${ref^^}" = "NONE" ]]; then
        ref=0
    else
        get-version-number ref $ref
    fi

    local rbid=0

    if [[ $DO_FORCE = yes ]]; then
        rm -f $SCBI_BDIR/$module/$SCBI_TARGET-$variant/build-id
        rbid=1
    else
        #  Check build id, only rebuild if mismatch

        diff -q $SCBI_BDIR/$module/build-id-$variant \
             $SCBI_BDIR/$module/$SCBI_TARGET-$variant/build-id > /dev/null 2>&1
        rbid=$?
    fi

    check-versions "$ref" ">" "$mver"
    local cver=$?

    if [[ $rbid -gt 0 ]]                  ||
           [[ $rsid -gt 0 ]]              ||
           [[ -z $mver ]]                 ||
           [[ "$mver" = $VERSION_ERROR ]] ||
           [[ $cver == 0 ]];
    then
        # Rebuild needed, $? = 1
        false
    else
        # Rebuild not needed, $? = 0
        true
    fi
}

############################## handle-depends
#
# check for module dependencies, handle them if build scripts found for
# them. Also check for distrib packages if exists.

function handle-depends()
{
    local FORMODULE=$1
    local MODREF=$2

    local module_info=()
    get-module-ref module_info $MODREF $FORMODULE

    if [[ -n ${module_info[4]} ]]; then
        module_info[1]=""
        module_info[2]=""
        module_info[3]=""
        elog ${module_info[@]}
        exit 1
    fi

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    #  Check if module exists

    local IS_MODULE=no

    [[ -f $SCBI_PLUGINS/$module ]] && local IS_MODULE=true

    #  Before anything check if we need to skip this dependency

    if [[ "$ref" == "skip" ]]; then
        if [[ $IS_MODULE == true ]]; then
            ilog $module %BModule %t$module%c marked to be skipped
        else
            ilog $module %BDependency %t$module%c marked to be skipped
        fi
        return
    fi

    #  If we want latest version, just handle this module

    if [[ "$kind" = "DEV" ]]; then
        handle-module $FORMODULE $MODREF
        return
    fi

    cd $SCBI_ROOT

    local formodule_info=()
    get-module-ref formodule_info $FORMODULE
    fmodule=${formodule_info[0]}
    fvariant=${formodule_info[1]}

    #  If module not found, check for a possible distrib package

    if [[ $IS_MODULE == no ]]; then
        MES=$(check-pkg $module:$ref)

        if [[ $? = 0 ]]; then
            return 0
        else
            local MNAME=$fmodule
            [[ $fvariant != "default" ]] && MNAME="$MNAME/$fvariant"

            local MSG="error"
            [[ $DO_WARNING_EXTERNAL == yes ]] && MSG="warning"

            echo "$MSG: missing dependencies for building $MNAME"

            local IDX=${#SCBI_MODULES_LIST[*]}
            (( IDX-- ))

            while [[ $IDX -gt 0 ]]; do
                (( IDX-- ))
                local MNAME=${SCBI_MODULES_LIST[$IDX]}
                echo "$MSG    required by $(get-module-name $MNAME)"
            done

            for dmodule in $(get-all-depends $fmodule $fvariant build-depends); do
                [[ ! -f $SCBI_PLUGINS/$dmodule ]] && check-pkg $dmodule
            done

            for dmodule in $(get-all-depends $fmodule $fvariant depends); do
                [[ ! -f $SCBI_PLUGINS/$dmodule ]] && check-pkg $dmodule
            done

            [[ $DO_TEST != no ]] &&
                {
                    for dmodule in \
                        $(get-all-depends $fmodule $fvariant tests-depends);
                    do
                        [[ ! -f $SCBI_PLUGINS/$dmodule ]] && check-pkg $dmodule
                    done
                }

            if [[ $DO_WARNING_EXTERNAL == yes ]]; then
                false
                return 0
            else
                exit 1
            fi

        fi
    fi

    handle-module $fmodule $MODREF
}

############################## handle-sources
#
#  get the module sources from a tar or a vcs
#

function handle-sources()
{
    local FORMODULE=$1
    local MODREF=$2

    #  Get module information

    local module_info=()
    get-module-ref module_info $MODREF $FORMODULE

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    [[ "$variant" = "native" ]] &&
        {
            echo -n "native-$ref" > source-id
            echo "native $ref" > source-ref
            return 0;
        }

    rm -f source-ref

    #  Check if a given archive exists even if a standard branch ref has
    #  been provided. This is an optimization to used a local archive
    #  instead of a repository branch.

    if [[ $kind == BRANCH ]] && [[ "$ARCHIVE_CACHE" == "yes" ]]; then
        check-archive-exists $module $variant $ref
        [[ $? == 0 ]] && kind=VERSION
    fi

    #  If building from archive, extract it now

    if [[ $kind == VERSION ]]; then
        local tar=( $(get-archive-data $module $variant $ref) )
        local nv=${#tar[*]}

        if [[ $nv == 0 ]]; then
            echo "error: $module-archive function not defined, cannot get archive"
            exit 1
        fi

        if [[ $nv != 6 ]]; then
            local V=${tar[0]}
            if [[ $V == default ]]; then
                V=""
            else
                V+="-"
            fi
            local nv=$(( $nv - 1 ))
            echo "error: $module-${V}archive function returned $nv values, 5 expected"
            exit 1
        fi

        tarsrc=${tar[5]}

        #  We need to extract the archive if the version does not match
        #  the one currently extracted.

        if [[ -f source-id ]]; then
            if [[ "$(cat source-id)" != "archive-$ref" ]] ||
                   [[ ${tarsrc^^} = "NONE" ]];
            then
                rm -fr archive-src
            fi
        fi

        if [[ $DO_UPDATE = yes ]] || [[ ! -d archive-src ]] || [[ ! -f archive ]]; then
            V=${tar[0]#default}
            ilog $module get sources from archive ${V:+[$V]}

            get-archive $module $variant $ref >> $log 2>&1

            if [[ $? != 0 ]]; then
                #  In case of error display log from get-archive
                grep ' : ' $log
                ilog $module cannot get/find archive sources
                exit 1
            fi
        fi

        echo -n "archive-$ref" > source-id

        #  Compute and store the version id of the sources. This includes the
        #  tar sha1 if present to ensure a tar with the same name but different
        #  content will trigger a build.

        local archive_sha1=""
        [[ -e archive-sha1 ]] &&
            {
                archive_sha1=$(cat archive-sha1)
                echo "archive $ref sha-1 ${archive_sha1// */}" > source-ref
            }

        get-build-id $SCBI_PREFIX $SCBI_TARGET \
                     $FORMODULE $MODREF archive-$ref$archive_sha1 \
                     > build-id-$variant

        #  We set the link for the source so that no module will have to
        #  do it.

        ln -s archive-src src

    else
        #  Get sources from repository

        local vcs=( $(get-vcs-data $module $variant) )

        local nv=${#vcs[*]}

        #  We request a specific version but there is no VCS hook defined
        #  this is an error.

        if [[ $kind == BRANCH ]] && [[ $nv == 0 ]]; then
            echo "error: $module-vcs function not defined, cannot get vcs"
            exit 1
        fi

        if [[ $nv != 0 ]] && [[ $nv != 5 ]] && [[ $nv != 6 ]]; then
            local V=${vcs[0]}
            if [[ $V == default ]]; then
                V=""
            else
                V+="-"
            fi
            local nv=$(( $nv - 1 ))
            echo "error: $module-${V}vcs function returned $nv values, 4 or 5 expected"
            exit 1
        fi

        local VCS_NAME=${vcs[3]}
        local VCS_URL=${vcs[4]}

        if [[ $nv > 0 ]] && [[ "${VCS_NAME^^}" != "NONE" ]]; then
            REPO=$(basename $VCS_URL .git)

            if [[ $kind = DEV ]]; then
                local SCBI_VCS_REPO=

                case $VCS_NAME in
                    git)
                        SCBI_VCS_REPO=$SCBI_GIT_REPO
                        ;;
                    svn|subversion)
                        SCBI_VCS_REPO=$SCBI_SVN_REPO
                        ;;
                    hg)
                        SCBI_VCS_REPO=$SCBI_HG_REPO
                        ;;
                    *)
                        elog $module unsupported VCS $VCS_NAME
                        exit 1
                esac

                if [[ -d $SCBI_VCS_REPO/$REPO ]]; then
                    ln -s $SCBI_VCS_REPO/$REPO vcs

                    #  Compute and store the version id of the sources +
                    #  compiler. That is when the compiler is changed we
                    #  want to rebuild the software.

                    echo -n "$ref" > source-id

                    vcs-build-id $SCBI_PREFIX $SCBI_TARGET \
                                 $FORMODULE $MODREF $(pwd)/vcs \
                                 > build-id-$variant

                else
                    ilog $module cannot find local dev repository:
                    ilog $module $SCBI_VCS_REPO/$REPO
                    exit 1
                fi

            else
                if [[ ! $DO_TEST =~ "yes-only" ]]; then
                    if [[ -f source-id ]]; then
                        if [[ "$(cat source-id)" != "vcs-$ref" ]]; then
                            # a different version is needed
                            DO_UPDATE=yes
                        fi
                    else
                        DO_UPDATE=yes
                    fi
                fi

                if [[ $DO_UPDATE = yes ]] || [[ ! -d ../.vcs/$REPO ]]; then
                    V=${vcs[0]#default}
                    ilog $module get sources from $VCS_NAME ${V:+[$V]}

                    get-vcs $SCBI_PREFIX $SCBI_TARGET $FORMODULE $MODREF

                    if [[ $? != 0 ]]; then
                        exit 1
                    fi
                else
                    ln -s ../.vcs/$REPO vcs
                fi

                echo -n "vcs-$ref" > source-id

                #  Compute and store the version id of the sources +
                #  compiler. That is when the compiler is changed we
                #  want to rebuild the software.

                vcs-build-id $SCBI_PREFIX $SCBI_TARGET \
                             $FORMODULE $MODREF $(pwd)/vcs \
                             > build-id-$variant
            fi

            if [[ ! -h src ]]; then
                #  Setting source reference, note that for Subversion this
                #  need to properly set the link to the directory in the vcs.
                #  This action is done by svn-branch that we call here.

                case $VCS_NAME in
                    svn|subversion)
                        svn-branch "" "" $module $ref ""
                        ;;
                    *)
                        ln -s vcs src
                        ;;
                esac
            fi

            get-vcs-ref $VCS_NAME $ref $(pwd)/vcs > source-ref

            return 0

        else
            echo -n "none-$ref" > source-id

            #  No VCS, no TAR, just rebuild the sources if present
            if [[ ! -d src ]]; then
                ilog $module "no sources (vcs or tar)"

                get-build-id $SCBI_PREFIX $SCBI_TARGET \
                             $FORMODULE $MODREF "$variant" \
                             > build-id-$variant
            else
                get-build-id $SCBI_PREFIX $SCBI_TARGET \
                             $FORMODULE $MODREF "$(date)" \
                             > build-id-$variant
            fi
        fi

        #  If get-vcs is not defined then the $module-setup routine is in
        #  charge of creating/populating the src directory.
    fi
}

############################## handle-meta-module

function handle-meta-module()
{
    local METAMODULE=$1
    local VARIANT=$2

    #  check for plan

    local FCT=""
    get-hook FCT $METAMODULE $VARIANT plan

    [[ -n $FCT ]] &&
        load-module-plan $($FCT $SCBI_PLAN)

    record-build-plan $METAMODULE $VARIANT

    #  check for dependencies

    [[ $DEPS == yes ]] &&
        for dmodule in $(get-all-depends $METAMODULE $VARIANT build-depends); do
            handle-depends $METAMODULE $dmodule || exit 1
        done

    #  check for setup

    local FCT_SETUP=""
    get-hook FCT_SETUP $METAMODULE $VARIANT setup

    local FCT_WRAPUP=""
    get-hook FCT_WRAPUP $METAMODULE $VARIANT wrapup

    line-sep
    ilog $METAMODULE %BMetamodule %t$METAMODULE%c \[%g${VARIANT//./ }%c\] setup \
        | tee -a $log
    _internal_module-variant-wrapper $SCBI_BDIR/install \
                                     $METAMODULE $VARIANT $FCT_SETUP || exit 1
    ilog $METAMODULE End metamodule $METAMODULE \[${VARIANT//./ }\] setup \
        | tee -a $log
    line-sep

    [[ $DEPS == yes ]] || ( [[ -z $FCT_SETUP ]] && [[ -z $FCT_WRAPUP ]] ) &&
        for module in $(plugin-call-variant-hooks \
                        $METAMODULE modules $SCBI_PREFIX $SCBI_TARGET $VARIANT);
        do
            handle-module $METAMODULE $module || exit 1
        done

    #  check for wrapup

    line-sep
    ilog $METAMODULE %BMetamodule %t$METAMODULE%c \[%g${VARIANT//./ }%c\] wrapup \
        | tee -a $log
    _internal_module-variant-wrapper $SCBI_BDIR/install \
                                     $METAMODULE $VARIANT $FCT_WRAPUP || exit 1
    ilog $METAMODULE End metamodule $METAMODULE \[${VARIANT//./ }\] wrapup \
        | tee -a $log
    line-sep
}

############################## record-module-env

function record-module-env()
{
    local MODULE=$1
    local VARIANT=$2

    local ENVLOG=$SCBI_LOGS/$TODAY/$SCBI_TARGET-$MODULE-$VARIANT-env.log

    echo "==================== env " > $ENVLOG
    env >> $ENVLOG

    [[ -n $(command -v gprls 2> /dev/null) ]] &&
        {
            echo "==================== gprls " >> $ENVLOG
            gprls -v 2>&1 >> $ENVLOG
        }

    [[ -n $(command -v gcc 2> /dev/null) ]] &&
        {
            echo "==================== gcc " >> $ENVLOG
            gcc -v &>> $ENVLOG
        }
}

############################## handle-module

function handle-module()
{
    local FORMODULE=$1
    local MODREF=$2

    #  Get module information

    local module_info=()
    get-module-ref module_info $MODREF $FORMODULE

    if [[ -n ${module_info[4]} ]]; then
        module_info[1]=""
        module_info[2]=""
        module_info[3]=""
        elog ${module_info[@]}
        exit 1
    fi

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    SCBI_CURRENT_MODULE=$module

    #  If already handled, nothing more to do

    check-handled "$module+$variant+$ref"
    [[ $? = 1 ]] && return

    #  If this module is marked as to be skipped

    if [[ "$ref" == "skip" ]]; then
        ilog $module %BModule %t$module%c marked to be skipped
        return
    fi

    log=$SCBI_LOGS/$TODAY/$SCBI_TARGET-$module-$variant-report.log

    cd $SCBI_ROOT

    [[ ! -f $SCBI_PLUGINS/$module ]] &&
        echo "error: no description for module $module" &&
        exit 1

    #  Then load module setup

    load-module $MODREF

    #  Check if module to be handled only if specificed on command line

    if [[ $FORMODULE != "@root" ]]; then
        is-hook-true $module $variant only-explicit-build FALSE

        if [[ $? == 0 ]]; then
            ilog $module Module $module built only if explitly specified
            return
        fi
    fi

    #  Create module build directory

    SCBI_MODULES_LIST+=( "$MODREF" )

    mkdir -p $SCBI_BDIR/$module/$SCBI_TARGET-$variant/logs > $log 2>&1

    #  Check if meta-module, if so call handle-module for each one

    if [[ $(is-meta-module $MODREF) == "yes" ]]; then
        (
            handle-meta-module $module $variant
        )
        res=$?
        unset SCBI_MODULES_LIST[-1]
        return $res
    fi

    #  Check for depends, and handle them if any

    if [[ $DEPS = yes ]]; then
        #  First we check for build dependencies
        (
            for dmodule in $(get-all-depends $module $variant build-depends); do
                handle-depends $MODREF $dmodule
            done
        )
        [[ $? != 0 ]] && exit 1

        [[ $DRY_RUN == no ]] && line-sep

        #  And then we check for standard dependencies
        (
            for dmodule in $(get-all-depends $module $variant depends); do
                handle-depends $MODREF $dmodule
            done
        )
        [[ $? != 0 ]] && exit 1

        [[ $DRY_RUN == no ]] && line-sep

        #  Finaly check for tests dependencies if needed
        [[ $DO_TEST != no ]] &&
            {
                (
                    for dmodule in \
                        $(get-all-depends $module $variant tests-depends);
                    do
                        handle-depends $MODREF $dmodule
                    done
                )
                [[ $? != 0 ]] && exit 1

                [[ $DRY_RUN == no ]] && line-sep
            }
    fi

    if [[ $DRY_RUN == yes ]]; then
        echo "$MODREF"
        unset SCBI_MODULES_LIST[-1]
        return 0
    fi

    clog $module

    #  If purge is asked, first remove current build structure

    if [[ $DO_PURGE = yes || $DO_PURGE = only ]]; then
        ilog $module Purging $module for $SCBI_TARGET/$variant
        [[ -d $SCBI_BDIR/$module ]] &&
            module-purge $SCBI_BDIR/$module $FORMODULE $module \
                         $variant $SCBI_TARGET
    fi

    if [[ $DO_CLEAN_INSTALL = yes ]]; then
        ilog $module Clean $module install for $SCBI_TARGET/$variant
        [[ -d $SCBI_BDIR/$module ]] &&
            module-clean-install \
                $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install \
                $FORMODULE $module $variant $SCBI_TARGET
        unset SCBI_MODULES_LIST[-1]
        return 0
    fi

    #  If purge-only, stop there

    if [[ $DO_PURGE = only ]]; then
        unset SCBI_MODULES_LIST[-1]
        return 0
    fi

    if [[ $ref == NONE ]]; then
        DISPREF=master
    else
        DISPREF=$ref
    fi

    line-sep
    ilog $module %BBuilding %t$module%c \[%g${variant//./ }%c\] \(%g$DISPREF%c\) | tee -a $log

    if [[ $SCBI_HOST == $SCBI_TARGET ]]; then
        ilog $module native $SCBI_TARGET | tee -a $log
    else
        ilog $module cross $SCBI_TARGET | tee -a $log
    fi

    ilog $module steps : $STEPS | tee -a $log

    #  Create the build root directory if needed, note that we do check here
    #  even if already created when entering this routine. This is because
    #  in case of a purge the build directory could have been removed.

    [[ -d $SCBI_BDIR/$module/$SCBI_TARGET-$variant ]] ||
        mkdir $SCBI_BDIR/$module/$SCBI_TARGET-$variant

    #  Set module environment if defined

    (
        #  We need to remove the link/sources to ensure proper setting by
        #  the module.

        [[ -d $SCBI_BDIR/$module ]] && cd $SCBI_BDIR/$module && rm -fr src vcs

        handle-sources $FORMODULE $MODREF

        [[ $? != 0 ]] && exit 1

        #  Set cross-env if needed

        if [[ "$SCBI_HOST" != "$SCBI_TARGET" ]]; then
            target-env $SCBI_BDIR/install $SCBI_TARGET
        fi

        ENVTMP="$(mktemp -p /dev/shm/)"
        SCBI_ENV_MODULE=$ENVTMP
        declare -A SCBI_MODULES_DIR=()

        handle-build-depends-env $FORMODULE $MODREF

        handle-module-env $FORMODULE $MODREF build-env >> $SCBI_ENV_MODULE

        #  And then setup recursively the environment to use dependencies

        handle-env $FORMODULE $MODREF

        unset SCBI_ENV_MODULE

        #  Check if envrionment is to be done for out-of-tree build

        is-hook-true $module $variant out-of-tree TRUE || ISOOT=no

        #  make sure the current build softlink is pointing to
        #  the variant. this is needed as the setup won't be
        #  done.

        [[ -d build ]] && rm -fr build
        [[ -h build ]] && rm build
        ln -s $SCBI_TARGET-$variant build

        #  Only rebuild if mismatch

        is-module-up-to-date $MODREF $FORMODULE

        if [[ $? = 0 ]]; then
            ilog $module no build needed, versions match

            STEPS=""

            # if testing is expected, at least do that

            if [[ $DO_TEST =~ "yes" ]]; then
                STEPS="tests"
            fi

        else
            #  Record the build-plan

            record-build-plan $module $variant

            #  Log module environment

            record-module-env $module $variant

            #  Setup the build environment for the current module

            local SCBI_LOGS_DIR=$SCBI_BDIR/$module/$SCBI_TARGET-$variant/logs
            SCBI_ENV_MODULE=$SCBI_LOGS_DIR/env.cmd
            rm -f $SCBI_ENV_MODULE

            [[ -n $SCBI_OS_MODULE_FILE ]] &&
                {
                    echo
                    echo "# OS specific support"
                    cat $SCBI_OS_MODULE_FILE
                } >> $SCBI_ENV_MODULE

            if [[ -d $SCBI_BDIR/$module/$SCBI_TARGET-$variant ]]; then
                #  Exports all environment variables starting with SCBI_
                echo                          >> $SCBI_ENV_MODULE
                echo "# SCBI global settings" >> $SCBI_ENV_MODULE

                while read VAR; do
                    if [[ "$VAR" != "${VAR#SCBI_*}" ]]; then
                        local NAME=${VAR%=*}
                        local VALUE=${VAR#*=}
                        case $NAME in
                            SCBI_JOBS|SCBI_HALF_JOBS)
                                echo export $NAME=\${$NAME:-$VALUE}
                                ;;
                            SCBI_PLUGINS)
                                echo export $NAME=\'$SCBI_LOGS_DIR\'
                                ;;
                            *)
                                echo export $NAME=\'$VALUE\'
                                ;;
                        esac >> $SCBI_ENV_MODULE
                    fi
                done < <( env )
            fi

            cat $ENVTMP >> $SCBI_ENV_MODULE

            # Generate the SCBI_MODULES_DIR associative array
            {
                echo
                echo "# SCBI_MODULES_DIR"
                echo "declare -A SCBI_MODULES_DIR=("

                for D in ${!SCBI_MODULES_DIR[@]}; do
                    local V="${SCBI_MODULES_DIR[$D]}"
                    local V=${V/$SCBI_TARGET/\$SCBI_TARGET}
                    echo "  [\"$D\"]=\"\$SCBI_BDIR${V#$SCBI_BDIR}\""
                done

                echo ")"
            } >> $SCBI_ENV_MODULE

            unset SCBI_ENV_MODULE

            #  If install is requested and we already have a local install
            #  directory, clean it to ensure no old versions are installed
            #  into the same location.

            if [[ $DO_INSTALL != no ]]; then
                rm -fr $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install
                rm -f  $SCBI_BDIR/$module/install-id
                rm -f  $SCBI_BDIR/$module/install-${SCBI_TARGET}-id
            fi

            #  Build is needed, on safe mode we remove the current
            #  build directory to ensure that old configuration and/or
            #  build artifacts are not going to break new build.
            #
            #  Note that we do that only for out-of-tree build as in
            #  the build in-tree the sources are fully synchronized from
            #  src directory (deleting all non existing files in source
            #  location).

            if [[ $SAFE_MODE = yes ]] && [[ $ISOOT = yes ]]; then
                rm -fr $SCBI_BDIR/$module/$SCBI_TARGET-$variant/build
                rm -fr $SCBI_BDIR/$module/$SCBI_TARGET-$variant/build-id
            fi
        fi

        rm -f $ENVTMP

        for step in $STEPS; do
            #  If test step (last step for a module) ensure that the
            #  module's env is loaded as tests are client of the module
            #  artifacts.

            if [[ $step == "tests" ]]; then
                handle-tests-depends-env $FORMODULE $MODREF
                handle-module-env $FORMODULE $MODREF env
            fi

            ########## PRE module

            #  Apply any generic pre-step (module-pre-setup, module-pre-purge)

            local res=0

            fn-exists module-pre-$step

            if [[ $? = 0 ]]; then
                cd $SCBI_BDIR/$module

                if [[ $SCBI_DLOG = yes ]]; then
                    module-pre-$step \
                        $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install \
                        $FORMODULE \
                        $module \
                        $variant $SCBI_TARGET $ISOOT 2>&1 \
                        | tee $log
                    res=${PIPESTATUS[0]}
                else
                    module-pre-$step \
                        $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install \
                        $FORMODULE \
                        $module \
                        $variant $SCBI_TARGET $ISOOT 2>&1 \
                        | tee -a $log
                    res=${PIPESTATUS[0]}
                fi
            fi

            if [[ $res != 0 ]]; then
                elog $module generic module pre-$step failed with error $res
                return $res
            fi

            #  Apply module specific step if any

            module-variant-wrapper \
                $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install $module \
                $variant pre-$step || exit 1

            ########## module

            module-variant-wrapper \
                $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install $module \
                $variant $step || exit 1

            #  Apply any generic step (module-setup, module-purge)

            res=0

            fn-exists module-$step

            if [[ $? = 0 ]]; then
                cd $SCBI_BDIR/$module

                if [[ $SCBI_DLOG = yes ]]; then
                    module-$step \
                        $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install \
                        $FORMODULE \
                        $module $variant $SCBI_TARGET $ISOOT 2>&1 | tee $log
                    res=${PIPESTATUS[0]}
                else
                    module-$step \
                        $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install \
                        $FORMODULE \
                        $module $variant $SCBI_TARGET $ISOOT 2>&1 | tee -a $log
                    res=${PIPESTATUS[0]}
                fi
            fi

            if [[ $res -ne 0 ]]; then
                elog $module generic module $step failed with error $res
                return $res
            fi

            ########## POST module

            module-variant-wrapper \
                $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install \
                $module $variant post-$step || exit 1

            res=0

            fn-exists module-post-$step

            if [[ $? = 0 ]]; then
                cd $SCBI_BDIR/$module

                if [[ $SCBI_DLOG = yes ]]; then
                    module-post-$step \
                        $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install \
                        $FORMODULE \
                        $module $variant $SCBI_TARGET $ISOOT \
                        2>&1 | tee $log
                    res=${PIPESTATUS[0]}
                else
                    module-post-$step \
                        $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install \
                        $FORMODULE \
                        $module $variant $SCBI_TARGET $ISOOT \
                        2>&1 | tee -a $log
                    res=${PIPESTATUS[0]}
                fi
            fi

            if [[ $res != 0 ]]; then
                elog $module generic module post-$step failed with error $res
                return $res
            fi
        done
    ) || exit 1

    #  Create binary archive if needed

    if [[ $DO_ARCHIVE = yes ]]; then
        cd $SCBI_BDIR/$module/build >> $log 2>&1
        tar cf $module-bin.tar --directory=install .
        bzip2 -9 $module-bin.tar
    fi

    local _IDIR=""

    local FCT=""
    get-hook FCT $module $variant prefix

    if [[ -n $FCT ]] && [[ "$SCBI_DEFAULT_PREFIX" = "yes" ]]; then
        _IDIR=$($FCT $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install \
                     $SCBI_TARGET $variant)
    else
        _IDIR=$SCBI_PREFIX
    fi

    if [[ ${_IDIR^^} == NONE ]]; then
        ilog $module skip global install

    elif [[ "$DO_INSTALL" != "no" ]] &&
             [[ -d $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install ]];
    then
        local IDEST=${_IDIR/$SCBI_BDIR/<sandbox>}
        IDEST=${IDEST/$HOME/\$HOME}

        ilog $module copy install into $IDEST

        #  Record global install
        echo "$variant" > $SCBI_BDIR/$module/install-${SCBI_TARGET}-id
        echo ${_IDIR}  >> $SCBI_BDIR/$module/install-${SCBI_TARGET}-id

        #  Finaly copy to given prefix
        local SUDO=""

        if [[ ! -d ${_IDIR} ]]; then
            mkdir -p ${_IDIR} &> /dev/null
            [[ $? != 0 ]] && SUDO=sudo
        fi

        if [[ ! -w ${_IDIR} ]]; then
            SUDO=sudo
        fi

        $SUDO mkdir -p ${_IDIR}/
        $SUDO rsync -a --force \
              $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install/. \
              ${_IDIR}/. > $log 2>&1
    fi || elog $module fail to copy to ${_IDIR}

    ilog $module End Building $module \[${variant//./ }\] \($DISPREF\) \
        | tee -a $log
    line-sep

    unset SCBI_MODULES_LIST[-1]
}

############################## sub-commands

if [[ $1 == "source-archive" ]]; then
    shift
    declare -fx load-module-env check-tools-abort check-tools check-tool
    export DO_QUIET
    $(dirname $SCBI_BINARY)/scbi-source-archive subcommand $*
    exit $?
elif [[ $1 == "lint" ]]; then
    shift
    $(dirname $SCBI_BINARY)/scbi-lint $*
    exit $?
fi

############################## body

#  First we check for --enable-*, --run* and --tests* options

#  First handle specific parameters:
#    --enable-*
#    --run:"some command"

#  Load ini file
ini-load-files
#  Apply default global values
ini-apply-values ""

SCBIOPTS=""

while [[ $# -gt 0 ]]; do
    case $1 in
        --enable-*)
            VAR=${1/--enable-/}
            export SCBI_${VAR//-/_}_SET=true
            ;;
        --run:*)
            DO_RUN=yes
            DO_RUN_CMD=${1/*:/}
            ;;
        --tests:only*)
            do-clear-steps
            DO_TEST=yes-only
            OPTS=( ${1/=/ } )
            SCBI_TESTS_OPTIONS="${OPTS[*]:1}"
            ;;
        --tests*)
            DO_TEST=yes
            OPTS=( ${1/=/ } )
            SCBI_TESTS_OPTIONS="${OPTS[*]:1}"
            ;;
        --ini*)
            ini-apply-values ${1#*=}
            ;;
        *)
            SCBIOPTS+="${SCBIOPTS:+ }$1"
            ;;
    esac
    shift
done

OPTFILE=$(mktemp)
OPTARG=
SCBIOPTS+="${SCBIOPTS:+ }$SCBI_INI_OPTIONS"

ALLOPTS=$(getopt -u -o t:j:adefSIuscbilnpqvwWh \
                 -l store,target:,no-setup,no-install,update,setup,config \
                 -l build,build-target:,install,clean-install,tar \
                 -l log,log:yes,log:no,log:on-failure,purge,purge:only \
                 -l quiet,prefix:,help,version,module-ref \
                 -l module-ref:version,module-ref:variant,module-ref:full \
                 -l deps,deps:warning,archive,force,env:,no-patch,plan: \
                 -l stat,stat:full,no-wrapup,wrapup,safe,standalone \
                 -l list-depends:direct,list-depends:full,list-depends \
                 -l list-externals,list-externals:only,list-no-version \
                 -l list-filter:all,list-filter:dev,list-filter:runtime \
                 -l dry-run,jobs:,plugins:,build-dir:,list-plan: \
                 -l shell,shell:use,shell:dev,shell:tests,shell:sb \
                 -l shell:sandbox,color:dark,color:light,color:no \
                 -- $SCBIOPTS 2> $OPTFILE)

if [[ $? != 0 ]]; then
    cat $OPTFILE
    echo try \"scbi --help\" for more information.
    rm -f $OPTFILE
    exit 1
fi

set -- $ALLOPTS

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            DO_HELP=yes
            break
            ;;
        -v|--version)
            DO_VERSION=yes
            break
            ;;
        -f|--force)
            DO_FORCE=yes
            ;;
        -q|--quiet)
            DO_QUIET=yes
            ;;
        --color:dark)
            DO_COLOR=dark
            ;;
        --color:light)
            DO_COLOR=light
            ;;
        --color:no)
            DO_COLOR=no
            ;;
        -a|--create-archive)
            DO_ARCHIVE=yes
            ;;
        -e|--env)
            ENV_NAME="$2"
            shift
            ;;
        --archive)
            ARCHIVE_CACHE=no
            ;;
        -t|--target)
            SCBI_TARGET=$2; shift
            SCBI_TARGET_SPECIFIED=yes
            ;;
        -S|--no-setup)
            DO_SETUP=no
            ;;
        -W|--no-wrapup)
            DO_WRAPUP=no
            ;;
        -w|--wrapup)
            do-clear-steps
            DO_WRAPUP=forced
            ;;
        -I|--no-install)
            DO_INSTALL=no
            ;;
        -u|--update)
            DO_UPDATE=yes
            ;;
        -s|--setup)
            do-clear-steps
            DO_SETUP=forced
            ;;
        --shell:sb|--shell:sandbox)
            DO_SHELL=yes
            ;;
        --shell:dev)
            DO_SHELL=yes-dev
            ;;
        --shell:tests)
            DO_SHELL=yes-tests
            ;;
        --shell:use)
            DO_SHELL=yes-nocd
            ;;
        --shell)
            DO_SHELL=yes-nocd
            ;;
        -c|--config)
            do-clear-steps
            DO_CONFIG=forced
            ;;
        -b|--build)
            do-clear-steps
            DO_BUILD=forced
            ;;
        --build-target)
            BUILD_SCBI_TARGET=$2; shift
            ;;
        -d|--deps)
            DEPS=yes
            ;;
        --deps:warning)
            DEPS=yes
            DO_WARNING_EXTERNAL=yes
            ;;
        -i|--install)
            do-clear-steps
            DO_INSTALL=forced
            ;;
        -l|--log|--log:yes)
            SCBI_DLOG=yes
            ;;
        --log:no)
            SCBI_DLOG=no
            ;;
        --log:on-failure)
            SCBI_DLOG=on-failure
            ;;
        -p|--purge)
            DO_PURGE=yes
            ;;
        --purge:only)
            DO_PURGE=only
            ;;
        -n|--no-patch)
            DO_PATCH=no
            ;;
        --prefix)
            SCBI_DEFAULT_PREFIX=no
            SCBI_PREFIX=$2; shift
            ;;
        --module-ref)
            DO_MOD_VER=full
            shift
            ;;
        --module-ref:version)
            DO_MOD_VER=ver
            shift
            ;;
        --module-ref:variant)
            DO_MOD_VER=var
            shift
            ;;
        --module-ref:full)
            DO_MOD_VER=full
            shift
            ;;
        -j|--jobs)
            SCBI_JOBS=$2; shift
            SCBI_HALF_JOBS=$SCBI_JOBS
            ;;
        --plan)
            SCBI_PLAN_CL=$2; shift
            ;;
        --stat:full)
            DO_STAT=yes;
            ;;
        --stat)
            DO_STAT=info-only;
            ;;
        --list-depends:direct)
            DO_DEPS=yes-direct;
            DO_QUIET=yes;
            ;;
        --list-depends:full)
            DO_DEPS=yes;
            DO_QUIET=yes;
            ;;
        --list-depends)
            DO_DEPS=yes;
            DO_QUIET=yes;
            ;;
        --list-externals:only)
            DO_EXT=yes-only;
            DO_QUIET=yes;
            ;;
        --list-externals)
            DO_EXT=yes;
            DO_QUIET=yes;
            ;;
        --list-no-version)
            DO_LIST_VER=no
            ;;
        --list-filter:all)
            SCBI_FILTER=all;
            ;;
        --list-filter:dev)
            SCBI_FILTER=dev;
            ;;
        --list-filter:runtime)
            SCBI_FILTER=runtime;
            ;;
        --list-plan)
            DO_PLAN=yes;
            ;;
        --dry-run)
            DRY_RUN=yes;
            ;;
        --safe)
            SAFE_MODE=yes;
            ;;
        --standalone)
            DO_STANDALONE=yes;
            ;;
        --plugins)
            SCBI_PLUGINS=$2; shift
            if [[ ! -d "$SCBI_PLUGINS" ]] || \
                   [[ -z "$(ls $SCBI_PLUGINS/[0-9]* 2> /dev/null)" ]];
            then
                echo "$0: no plugins found in $SCBI_PLUGINS"
                exit 1
            fi
            ;;
        --build-dir)
            CMDLINE_BUILD_DIR=$2; shift
            ;;
        --clean-install)
            DO_CLEAN_INSTALL=yes
            ;;
        --store)
            DO_STORE=yes
            shift 2
            STORE_KEY="$1"
            STORE_VALUE="$2"

            [[ -n $3 ]] &&
                echo "$0: unexpected parameters for store command" &&
                exit 1
            shift 2
            ;;
        (--)
            ;;
        (*)
            SCBI_MODULES+="${SCBI_MODULES:+ }$1"
            ;;
        (-*)
            echo "$0: error - unrecognized option $1" 1>&2; exit 1
            ;;
    esac
    shift
done

if [[ $DO_EXT != no && $DO_DEPS == no ]]; then
    DO_DEPS=yes
fi

if [[ $DO_COLOR == dark ]]; then
    SCBI_CBOLD=$(tput bold)
    SCBI_CTEXT=$(tput setaf 15)
    SCBI_CCLEAR=$(tput sgr0)
    SCBI_CRED=$SCBI_CBOLD$(tput setaf 9)
    SCBI_CBLUE=$SCBI_CBOLD$(tput setaf 12)
    SCBI_CGREEN=$SCBI_CBOLD$(tput setaf 10)
elif [[ $DO_COLOR == light ]]; then
    SCBI_CBOLD=$(tput bold)$(tput setaf 239)
    SCBI_CTEXT=$(tput setaf 0)
    SCBI_CCLEAR=$(tput sgr0)
    SCBI_CRED=$SCBI_CBOLD$(tput setaf 1)
    SCBI_CBLUE=$SCBI_CBOLD$(tput setaf 4)
    SCBI_CGREEN=$SCBI_CBOLD$(tput setaf 2)
fi

trap clean-up EXIT

#  Load module definitions

[[ ! -d "$SCBI_PLUGINS" ]] || [[ -z "$(ls $SCBI_PLUGINS/[0-9]* 2> /dev/null)" ]] &&
    SCBI_PLUGINS=$HOME/.config/scbi

[[ ! -d "$SCBI_PLUGINS" ]] &&
    echo "$0: cannot find module definition files" && exit 1

#  Load user's environment if any now that SCBI_PLUGINS is set

load-module-env $ENV_NAME

#  Build the steps to be conducted

[[ $DO_SETUP   != no ]] && STEPS="$STEPS setup"
[[ $DO_CONFIG  != no ]] && STEPS="$STEPS config"
[[ $DO_BUILD   != no ]] && STEPS="$STEPS build"
[[ $DO_INSTALL != no ]] && STEPS="$STEPS install"
[[ $DO_TEST    != no ]] && STEPS="$STEPS tests"
[[ $DO_WRAPUP  != no ]] && STEPS="$STEPS wrapup"

#  If we have specified a build directory on command line, set it now
#  that the env is loaded (takes precedence).

if [[ -n $CMDLINE_BUILD_DIR ]]; then
    export SCBI_BDIR=$CMDLINE_BUILD_DIR
fi

#  Then load any global settings, not overriding user's ones

for setup in $SCBI_PLUGINS/[0-9]*; do
    source $setup
done

#  Then load any OS dependent runtime module

[[ -f $SCBI_PLUGINS/_os_$SCBI_OS_MODULE ]] &&
    {
        SCBI_OS_MODULE_FILE=$SCBI_PLUGINS/_os_$SCBI_OS_MODULE
        source $SCBI_OS_MODULE_FILE
    }

#  Handle store command

if [[ $DO_STORE = yes ]]; then
    scbi-store "$STORE_KEY" "$STORE_VALUE"
    exit $?
fi

#  Nothing to build, display usage

if [[ $DO_VERSION = yes ]]; then
    echo "SCBI : $SCBI_VERSION"
    for file in $(ls $SCBI_PLUGINS/.scbi*version.txt 2> /dev/null); do
        cat $file
    done
    exit 0
fi

#  If a plan passed on the command line ensure that it is used instead
#  of any other possibly set in the environment file.

[[ -n $SCBI_PLAN_CL ]] && SCBI_PLAN=$SCBI_PLAN_CL

[[ -z $SCBI_MODULES ]] &&
    [[ $DO_SHELL != no ]] &&
    [[ $DO_RUN != no ]] &&
    [[ $DO_STAT == no ]] &&
    echo "error: shell/run commands need a plug-in, see scbi --help" && exit 0

[[ -z $SCBI_MODULES ]] && [[ $DO_STAT == no ]] && [[ $DO_MOD_VER == no ]] &&
    usage && exit 0

[[ $DO_HELP == yes ]] && usage && exit 0

[[ $DO_STAT != no ]] &&
    display-stat

[[ -z $SCBI_MODULES ]] || [[ $DO_STAT == yes ]] &&
    display-modules && display-plans

[[ $DO_STAT == yes ]] &&
    display-log-stat

#  Load build plan if any

if [[ -n $SCBI_PLAN ]]; then
    load-module-plan $SCBI_PLAN
    [[ $? -ne 0 ]] &&
        echo "error: cannot load module plan $SCBI_PLAN" &&
        exit 1
fi

#  Setup module reference specified on the command line. The module
#  reference on the command line must overwrite the actual build plan.

for module in $SCBI_MODULES; do
    set-module-ref $module
done

if [[ $DO_MOD_VER == no ]]; then
    rewrite-module-plan
else
    rewrite-module-plan > /dev/null
fi
[[ $? == 1 ]] && exit 1

if [[ $DO_DEPS != no ]]; then
    for module in $SCBI_MODULES; do
        for-all-modules-with-meta-ext register-depends-callback $module
    done

    if [[ $? = 0 ]]; then
        {
            for MOD in "${MODULE_LIST[@]}"; do
                echo "${MOD}"
            done
        } | sort | uniq

        exit 0
    fi

    exit 1
fi

#  Prepare log dir and archive dir

mkdir -p $SCBI_LOGS/$TODAY
mkdir -p $SCBI_ARCHIVES

if [[ $DRY_RUN == yes ]]; then
    DO_PURGE=no
    DO_INSTALL=no
    DO_ARCHIVE=no
    DO_UPDATE=no
    DO_FORCE=no
    DO_CLEAN_INSTALL=no
    STEPS=""
fi

#  If a run is requested

if [[ $DO_RUN == yes ]]; then
    run-command $SCBI_TARGET "$SCBI_MODULES" "$DO_RUN_CMD"
    exit 0
fi

#  If a shell is requested

if [[ $DO_SHELL == yes-nocd ]]; then
    run-shell $SCBI_TARGET "$SCBI_MODULES" no
    exit 0
fi

if [[ $DO_SHELL =~ yes ]]; then
    run-shell $SCBI_TARGET "$SCBI_MODULES" $DO_SHELL
    exit 0
fi

#  If we want to display a module version from a module plan, do it now

if [[ $DO_MOD_VER != no ]]; then
    for module in $SCBI_MODULES; do
        display-module-ref $module $DO_MOD_VER
    done
    exit 0
fi

if [[ $DO_PLAN == yes ]]; then
    display-build-plan
    exit 0
fi

#  Copy the runtime for replay with {config,build,install}.cmd scripts

cp $SCBI_PLUGINS/0_runtime $SCBI_BDIR/.scbi.runtime

#  Some more helpers that cannot be put in 0_runtime as needed in scbi
#  script very early (before plug-in dir is set).
{
    echo
    echo "###### helpers"
    echo
    for fct in check-tool check-tools check-tools-abort; do
        echo "function $(declare -f $fct)"
        echo
    done
} >> $SCBI_BDIR/.scbi.runtime

#  Run script for all modules

for module in $SCBI_MODULES; do
    handle-module "@root" $module || exit 1
done

if [[ $DO_STANDALONE == yes ]]; then
    create-standalone-package
fi
