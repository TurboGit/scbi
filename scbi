#!/bin/bash
#
#  SCBI - (C) Pascal Obry - 2007-2019
#

SCBI_VERSION=2.0

############################## check-tool

function check-tool()
{
    if [ -z "$(which $1)" ]; then
        return 1
    fi
    return 0
}

############################## check-tools

function check-tools()
{
    local res=0

    while [ "$1" != "" ]; do
        check-tool $1
        res=$(expr $res + $?)
        shift
    done
    return $res
}

# check for tools used by scbi itself
check-tools gcc python3 rsync sed
if [ $? != 0 ]; then
    echo Required tools gcc python3 rsync sed missing, please install
    exit 1
fi

CDPATH=

#  Environment
SCBI_HOST=$(gcc -dumpmachine | sed -e 's/-pc//;s/-unknown//')
SCBI_TARGET=$SCBI_HOST
SCBI_TARGET_SPECIFIED=no
ENV_NAME=

#  General script setup
DLOG=on-failure
SCBI_DEFS="$PWD"/scripts.d
SCBI_JOBS=$(grep -c ^processor /proc/cpuinfo 2>/dev/null || sysctl -n hw.ncpu)
SCBI_MAKE_JOBS=$(expr $SCBI_JOBS / 2)
# SCBI_MAKE_JOBS is for makefiles

#  Modules to be handled and already handled
MODULES=
HANDLED=$(mktemp)

#  Actions setup
PURGE=no
NSTEPS=
SCBI_PREFIX=
SCBI_DEFAULT_PREFIX=yes
DOINSTALL=yes
DOUPDATE=no
DOTEST=no
DOARCHIVE=no
DOFORCE=no
DOSTAT=no
DODEPS=no
DEPS=no
ISOOT=yes
PATCH=yes
STEPS="setup config build install wrapup"
BUILD_SCBI_TARGET=
SCBI_PLAN=
TAR_CACHE=yes
DRY_RUN=no

############################## check-handled
#
# check whether a module has already been handled

function check-handled()
{
    local module=$1

    grep "^$module" $HANDLED &> /dev/null

    if [ $? = 1 ]; then
        echo $module >> $HANDLED
        return 0
    else
        return 1
    fi
}

############################## clean-up
#
# clean-up before exit

function clean-up()
{
    rm -f $HANDLED
    rm -f $SCBI_LINE_SEP
}

############################## load-module-env
#
# load an environment description, this cannot be in 5_tools as an
# envrionment script must be loaded before any other.

function load-module-env()
{
    local ENV=$PWD/.scbi-env$1

    # if not found in current directory look in definitions install dir

    if [ ! -f $ENV ]; then
        # look for it in parent directory too
        ENV=$PWD/../.scbi-env$1

        if [ ! -f $ENV ]; then
            ENV=$SCBI_DEFS/.env$1
        fi
    fi

    if [ -f $ENV ]; then
        source $ENV
    elif [ ! -z $1 ]; then
        echo build environment .env$1 not found
        exit 1
    fi
}

############################## module-wrapper
#
# called for each module and step

function module-wrapper()
{
    local PREFIX=$1
    local module=$2
    local variant=$3
    local step=$4

    if [ $step = "build" -a "$BUILD_SCBI_TARGET" != "" ]; then
        mstep=build-$BUILD_SCBI_TARGET
    else
        mstep=$step
    fi

    # global logs
    log=$SCBI_LOGS/$TODAY/$SCBI_TARGET-$module-$variant-$mstep.log

    # local log for last module command
    mlog=$SCBI_BDIR/$module/$SCBI_TARGET-$variant/.log/$mstep.log
    clog=$SCBI_BDIR/$module/$SCBI_TARGET-$variant/.log/$mstep.cmd

    ilog $module $mstep starting

    (
        cd $SCBI_BDIR/$module >> $log 2>&1

        #  Go to build directory

        if [[ "$step" =~ (pre-|post-)*(setup|wrapup)$ ]]; then
            cd $SCBI_BDIR/$module
        else
            cd $SCBI_BDIR/$module/build/build
        fi

        #  Record run command

        (
            show-command $module-$mstep $PREFIX $SCBI_TARGET 2&> $clog
        )

        #  Call module step

        if [[ $DLOG = yes || "$step" = "tests" ]]; then
            $module-$mstep $PREFIX $SCBI_TARGET 2>&1 | tee -a $log | tee $mlog
        else
            $module-$mstep $PREFIX $SCBI_TARGET 2>&1 | tee $mlog >> $log
        fi
        #  We want the status of the first command and not the tee ones
        res=${PIPESTATUS[0]}

        #  Check for errors

        if [ $res != 0 ]; then
            if [ $DLOG = on-failure ]; then
                tail -100 $log
            fi
            elog $module $mstep failed with error $res
            return $res
        else
            ilog $module $mstep completed
            return 0
        fi
    )
}

############################## module-variant-wrapper
#
# called for each module, variant and step, switch to proper step to call
# depending on the existence of the variant.

function module-variant-wrapper()
{
    local PREFIX=$1
    local module=$2
    local variant=$3
    local step=$4

    if [ "$SCBI_HOST" != "$SCBI_TARGET" ]; then
        fn-exists $module-$variant-cross-$step

        if [[ $? = 0 ]]; then
            module-wrapper $PREFIX $module \
                           $variant $variant-cross-$step || exit 1
            return $?
        else
            fn-exists $module-cross-$step

            if [[ $? = 0 ]]; then
                module-wrapper $PREFIX $module \
                               $variant cross-$step || exit 1
                return $?
            fi
        fi
    fi

    fn-exists $module-$variant-$step

    if [[ $? = 0 ]]; then
        module-wrapper $PREFIX $module $variant $variant-$step || exit 1

    else
        fn-exists $module-$step

        if [[ $? = 0 ]]; then
            module-wrapper $PREFIX $module $variant $step || exit 1
        fi
    fi
}

############################## usage

function usage()
{
    echo
    echo SCBI $VERSION
    echo
    echo $0 [options] module1 [module2 ... modulen]

    echo ""
    echo "   modulen  <name>           build from repository main branch"
    echo "   modulen  <name>/<variant> build <variant> from repository version"
    echo "   modulen  <name>:<branch>  build from repository version <branch>"
    echo "   modulen  <name>:#<ver>    build from tarbal version <ver>"
    echo "   modulen  <name>:dev       build from user's repository current branch"
    echo ""
    echo "   -h | --help          this help message"
    echo "   -e | --env=<name>    environment file ~/.scbi-<name>"
    echo "      | --enable-<name> enable feature name"
    echo "   -t | --target=<name> specify the target to build for ($SCBI_TARGET)"
    echo "   -S | --no-setup      skip setup"
    echo "   -I | --no-install    skip install"
    echo "   -u | --update        do update"
    echo "   -s | --setup         do setup"
    echo "   -c | --config        do config"
    echo "   -b | --build         do build"
    echo "   -i | --install       do install"
    echo "      | --tar           check for tar only if explicitly specified"
    echo "      | --tests         run the testsuite, build if necessary"
    echo "      | --tests-only    run the testsuite"
    echo "   -d | --deps          check/build dependencies"
    echo "   -a | --archive       build binary archive"
    echo "   -v | --verbose       display full log"
    echo "   -l | --no-log        never display log"
    echo "   -f | --force         force rebuild, do not check build id"
    echo "   -p | --purge         remove builds directories before building"
    echo "   -P | --purge-only    only remove builds directories"
    echo "      | --list-depends  recursivelly list module's dependencies"
    echo "      | --list-depends-with-meta"
    echo "                        as above, taking into account meta modules"
    echo "      | --dry-run       only list modules handled"
    echo "      | --plan          add a build plan for modules"
    echo "      | --stat          display some status of current setup"
    echo "   -n | --no-patch      do not apply patches"
    echo "   -j | --jobs=<n>      max compilation jobs \$SCBI_JOBS"
}

############################## handle-modue-env
#
# call module ENV, checking for variant

SCBI_ENV_MODULE=

function handle-module-env()
{
    local modref=$1
    local ENV=$2

    #  Get module information

    local module_info=( $(get-module-ref $modref) )

    local module=${module_info[0]}
    local variant=${module_info[1]}

    # Then setup the current module

    if [ -d $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install ]; then
        cd $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install
    elif [ -d $SCBI_BDIR/$module/$SCBI_TARGET-$variant ]; then
        cd $SCBI_BDIR/$module/$SCBI_TARGET-$variant
    else
        cd $SCBI_BDIR/$module
    fi

    fn-exists $module-$variant-$ENV

    if [ $? = 0 ]; then
        if [ ! -z $SCBI_ENV_MODULE ]; then
            echo >> $SCBI_ENV_MODULE
            echo "# $module" >> $SCBI_ENV_MODULE
        fi
        $module-$variant-$ENV $SCBI_BDIR/$module/build/install $SCBI_TARGET
    else
        fn-exists $module-$ENV

        if [ $? = 0 ]; then
            if [ ! -z $SCBI_ENV_MODULE ]; then
                echo >> $SCBI_ENV_MODULE
                echo "# $module" >> $SCBI_ENV_MODULE
            fi
            $module-$ENV $SCBI_BDIR/$module/build/install $SCBI_TARGET
        fi
    fi
}

############################## display-env-callback
# used for --list-depends and --list-depends-with-meta

function display-env-callback()
{
    local MODULE=$1
    local MODREF=$2
    local IS_ROOT=$3

    echo $MODREF
}

############################## handle-env
#
# recursively set the environment for the module based on the dependencies

function handle-env-callback()
{
    local MODULE=$1
    local MODREF=$2
    local IS_ROOT=$3

    handle-module-env $MODREF env
}

function handle-env()
{
    local modref=$1

    #  Get module information

    local module_info=( $(get-module-ref $modref) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    if [ -d $SCBI_BDIR/$module/$SCBI_TARGET-$variant ]; then
        SCBI_ENV_MODULE=$SCBI_BDIR/$module/$SCBI_TARGET-$variant/.log/env.cmd
        rm -f $SCBI_ENV_MODULE
    fi

    for-all-modules handle-env-callback $modref

    SCBI_ENV_MODULE=
}

############################## handle-depends
#
# check for module dependencies, handle them if build scripts found for
# them. Also check for distrib packages if exists.

function handle-depends()
{
    local modref=$1

    local module_info=( $(get-module-ref $modref) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    #  If we want latest version, just handle this module

    if [ "$kind" = "DEV" ]; then
        handle-module $1
        return
    fi

    cd $SCBI_ROOT

    #  If module not found, check for a possible distrib package

    if [ ! -f $SCBI_DEFS/$module ]; then
        check-pkg $module:$ref

        if [ $? = 0 ]; then
            return 0
        else
            echo No description for module $module &&
            echo And not found in the distrib  &&
            exit 1
        fi
    fi

    #  Check if the proper version is installed

    load-module $module

    fn-exists $module-version
    if [[ $? = 0 ]]; then
        pushd $(mktemp -d) > /dev/null 2>&1

        mver=$($module-version $SCBI_PREFIX $SCBI_TARGET)

        [ "${PWD:0:4}" = "/tmp" ] && rm -r $(pwd)

        popd > /dev/null 2>&1
    else
        mver=$VERSION_OK
    fi

    #  Clean-up the version number (only digits and a single dot)

    mver=$(get-version-number $mver)

    cd $SCBI_ROOT

    [ "$ref" = "NONE" ] && ref=0

    [ $DOFORCE = yes ] && rm -f $SCBI_BDIR/$module/build/build-id

    #  Check build id, only rebuild if mismatch

    diff -q $SCBI_BDIR/$module/build-id \
            $SCBI_BDIR/$module/build/build-id > /dev/null 2>&1

    if [[ $? != 0 \
              || "$mver" = "" \
              || "$mver" = $VERSION_ERROR \
              || $ref > $mver ]];
    then
        if [ $DRY_RUN == no ]; then
            ilog $module need building $module, \
                 current version $(display-version $mver) | tee -a $log
        fi
        handle-module $modref
    else
        ilog $module $modref found
    fi
}

############################## handle-sources
#
#  get the module sources from a tar or a vcs
#

function handle-sources()
{
    local modref=$1

    #  Get module information

    local module_info=( $(get-module-ref $modref) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    #  Check if a given tar exists even if a standard branch ref has
    #  been provided. This is an optimization to used a local tar
    #  instead of a repository branch.

    if [ $kind == BRANCH -a "$TAR_CACHE" == "yes" ]; then
        check-tar-exists $module $ref
        [ $? == 0 ] && kind=VERSION
    fi

    #  If building from tarball, extract it now

    if [ $kind == VERSION ]; then
        fn-exists $module-tar

        if [[ ! $? = 0 ]]; then
            echo "error: $module-tar function not defined, cannot get tarball"
            exit 1
        fi

        #  We need to extract the tarball if the version does not match
        #  the one currently extracted.

        if [ -f source-id ]; then
            if [ "$(cat source-id)" != "tar-$ref" ]; then
                rm -fr tarsrc
            fi
        fi

        if [ $DOUPDATE = yes -o ! -d tarsrc -o ! -f tar ]; then
            ilog $module get sources from tar

            get-tar $module $ref >> $log 2>&1

            if [[ ! $? = 0 ]]; then
                ilog $module cannot get/find tar sources
                exit 1
            fi

            #  Compute and store the version id of the sources + compiler.
            #  That is when the compiler is changed when want to rebuild
            #  the software.
            get-build-id $SCBI_PREFIX $SCBI_TARGET \
                         $modref tar-$ref > build-id-$variant
        fi

        echo -n tar-$ref > source-id

        #  We set the link for the source so that no module will have to
        #  do it.

        ln -s tarsrc src

    else
        # Get sources from repository

        fn-exists $module-vcs

        if [[ $? = 0 ]]; then
            vcs=( $($module-vcs) )
            VCS_NAME=${vcs[2]}
            VCS_URL=${vcs[3]}

            REPO=$(basename $VCS_URL .git)

            if [ $kind = DEV ]; then
                local SCBI_VCS_REPO=

                case $VCS_NAME in
                    git)
                        SCBI_VCS_REPO=$SCBI_GIT_REPO
                        ;;
                    svn|subversion)
                        SCBI_VCS_REPO=$SCBI_SVN_REPO
                        ;;
                    hg)
                        SCBI_VCS_REPO=$SCBI_HG_REPO
                        ;;
                    *)
                        elog $module unsupported VCS $VCS_NAME
                        exit 1
                esac

                if [ -d $SCBI_VCS_REPO/$REPO ]; then
                    ln -s $SCBI_VCS_REPO/$REPO vcs

                    #  Compute and store the version id of the sources +
                    #  compiler. That is when the compiler is changed we
                    #  want to rebuild the software.

                    echo -n $ref > source-id

                    vcs-build-id $SCBI_PREFIX $SCBI_TARGET $modref $(pwd)/vcs \
                                 > build-id-$variant

                else
                    ilog $module cannot find local dev repository:
                    ilog $module $SCBI_VCS_REPO/$REPO
                    exit 1
                fi

            else
                if [ -f source-id ]; then
                    if [ "$(cat source-id)" != "vcs-$ref" ]; then
                        # a different version is needed
                        DOUPDATE=yes
                    fi
                fi

                if [ $DOUPDATE = yes -o ! -d ../.vcs/$REPO ]; then
                    ilog $module get sources from $VCS_NAME

                    get-vcs $module $kind $ref

                    if [[ ! $? = 0 ]]; then
                        exit 1
                    fi
                else
                    ln -s ../.vcs/$REPO vcs
                fi

                echo -n vcs-$ref > source-id

                #  Compute and store the version id of the sources +
                #  compiler. That is when the compiler is changed we
                #  want to rebuild the software.

                vcs-build-id $SCBI_PREFIX $SCBI_TARGET $modref $(pwd)/vcs \
                             > build-id-$variant
            fi

            ln -s vcs src

        else
            #  No VCS, not TAR, just rebuild the sources
            get-build-id $SCBI_PREFIX $SCBI_TARGET $modref "$(date)" \
                         > build-id-$variant
        fi

        #  If get-vcs is not defined then the $module-setup routine is in
        #  charge of creating/populating the src directory.
    fi
}

############################## handle-meta-module

function handle-meta-module()
{
    local metamodule=$1
    local variant=$2

    # check for plan

    fn-exists $metamodule-$variant-plan

    if [[ $? = 0 ]]; then
        SCBI_PLAN=$($metamodule-$variant-plan)
        load-module-plan $SCBI_PLAN
    else
        fn-exists $metamodule-plan
        if [[ $? = 0 ]]; then
            SCBI_PLAN=$($metamodule-plan)
            load-module-plan $SCBI_PLAN
        fi
    fi

    # check for setup

    line-sep
    ilog $metamodule Metamodule $metamodule-$variant setup | tee -a $log
    module-variant-wrapper $SCBI_BDIR/install \
                           $metamodule $variant setup || exit 1
    ilog $metamodule End metamodule $metamodule-$variant setup | tee -a $log
    line-sep

    fn-exists $metamodule-$variant-modules

    if [[ $? = 0 ]]; then
        FCT=$metamodule-$variant-modules
    else
        FCT=$metamodule-modules
    fi

    for module in $($FCT); do
        handle-module $module
    done

    # check for wrapup

    line-sep
    ilog $metamodule Metamodule $metamodule-$variant wrapup | tee -a $log
    module-variant-wrapper $SCBI_BDIR/install \
                           $metamodule $variant wrapup || exit 1
    ilog $metamodule End metamodule $metamodule-$variant wrapup | tee -a $log
    line-sep
}

############################## handle-module

function handle-module()
{
    local modref=$1

    #  Get module information

    local module_info=( $(get-module-ref $modref) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    log=$SCBI_LOGS/$TODAY/$SCBI_TARGET-$module-$variant-report.log

    #  Check if we have already handled this module

    check-handled $module+$variant
    if [[ $? = 1 ]]; then
        if [ $DRY_RUN == no ]; then
            ilog $module skip $module, already handled
        fi
        return
    fi

    cd $SCBI_ROOT

    [ ! -f $SCBI_DEFS/$module ] &&
        echo No description for module $module &&
        exit 1

    #  Then load module setup

    load-module $module

    #  Create module build directory

    mkdir -p $SCBI_BDIR/$module/$SCBI_TARGET-$variant/.log > $log 2>&1
    fct=$SCBI_BDIR/$module/$SCBI_TARGET-$variant/.log/fct.cmd

    echo "function add-to-var()"                      > $fct
    echo "{"                                         >> $fct
    echo '    local VAR=$1'                          >> $fct
    echo '    local DIR=$2'                          >> $fct
    echo '    export $VAR="${DIR}${!VAR:+:}${!VAR}"' >> $fct
    echo "}"                                         >> $fct

    #  Check if meta-module, if so call handle-module for each one

    fn-exists $module-$variant-modules

    if [[ $? = 0 ]]; then
        (
            handle-meta-module $module $variant
        )
        return
    else
        fn-exists $module-modules
        if [[ $? = 0 ]]; then
            (
                handle-meta-module $module $variant
            )
            return
        fi
    fi

    # Check for depends if any, and handle them if any

    if [ $DEPS = yes ]; then
        fn-exists $module-$variant-depends

        if [[ $? = 0 ]]; then
            (
                for module in $($module-$variant-depends); do
                    handle-depends $module
                done
            )
            if [[ ! $? = 0 ]]; then
                exit 1
            fi
            [ $DRY_RUN == no ] && line-sep
        else
            fn-exists $module-depends

            if [[ $? = 0 ]]; then
                (
                    for module in $($module-depends); do
                        handle-depends $module
                    done
                )
                if [[ ! $? = 0 ]]; then
                    exit 1
                fi
                [ $DRY_RUN == no ] && line-sep
            fi
        fi
    fi

    if [ $DRY_RUN == yes ]; then
        echo $modref
        return 0
    fi

    clog $module

    #  If purge is asked, first remove current build structure

    if [ $PURGE = yes -o $PURGE = only ]; then
        ilog $module Purging $module for $SCBI_TARGET/$variant
        [ -d $SCBI_BDIR/$module ] &&
            module-purge $SCBI_BDIR/$module $module $variant $SCBI_TARGET
    fi

    #  If purge-only, stop there

    [ $PURGE = only ] && exit 0

    if [ $ref == NONE ]; then
        DISPREF=master
    else
        DISPREF=$ref
    fi

    line-sep
    ilog $module Building $module-$variant \($DISPREF\) | tee -a $log

    if [ $SCBI_HOST == $SCBI_TARGET ]; then
        ilog $module native $SCBI_TARGET | tee -a $log
    else
        ilog $module cross $SCBI_TARGET | tee -a $log
    fi

    ilog $module steps : $STEPS | tee -a $log

    #  Create the build root directory if needed, note that we do check here
    #  even if already created when entering this routine. This is because
    #  in case of a purge the build directory could have been removed.

    [ -d $SCBI_BDIR/$module/$SCBI_TARGET-$variant ] ||
        mkdir $SCBI_BDIR/$module/$SCBI_TARGET-$variant

    #  Set module environment if defined

    (
        #  Set cross-env if needed

        if [ "$SCBI_HOST" != "$SCBI_TARGET" ]; then
            target-env $SCBI_BDIR/install $SCBI_TARGET
        fi

        #  Setup the build environment for the current module

        handle-module-env $modref build-env

        #  And then setup recursively the environment to use dependencies

        handle-env $modref

        #  Log module enviroment

        ENVLOG=$SCBI_LOGS/$TODAY/$SCBI_TARGET-$module-$variant-env.log

        echo "==================== env " > $ENVLOG
        env >> $ENVLOG

        [ ! -z $(which gprls) ] &&
            (
                echo "==================== gprls " >> $ENVLOG
                gprls -v 2>&1 >> $ENVLOG
            )

        [ ! -z $(which gcc) ] &&
            (
                echo "==================== gcc " >> $ENVLOG
                gcc -v &>> $ENVLOG
            )

        #  We need to remove the link/sources to ensure proper setting by
        #  the module.

        [ -d $SCBI_BDIR/$module ] && cd $SCBI_BDIR/$module && rm -fr src vcs

        handle-sources $modref

        [ ! $? = 0 ] && exit 1

        #  Check if envrionment is to be done for out-of-tree build

        fn-exists $module-out-of-tree

        [ $? = 0 ] && [ $($module-out-of-tree) = "false" ] && ISOOT=false

        #  Call module routines

        #  If force build, remove the current build id

        [ $DOFORCE = yes ] && rm -f build/build-id

        #  Check build id, only rebuild if mismatch

        diff -q build-id-$variant \
             $SCBI_BDIR/$module/$SCBI_TARGET-$variant/build-id > /dev/null 2>&1

        if [ $? = 0 ]; then
            ilog $module no build needed, versions match

            STEPS=""

            # make sure the current build softlink is pointing to
            # the variant. this is needed as the setup won't be
            # done.

            [ -h build ] && rm -f build
            ln -s $SCBI_TARGET-$variant build

            # if testing is expected, at least do that

            if [ $DOTEST = true ]; then
                STEPS="$STEPS tests"
            fi
        fi

        for step in $STEPS; do
            ########## PRE module

            #  Apply any generic step (module-setup, module-purge)

            fn-exists module-pre-$step

            if [[ $? = 0 ]]; then
                cd $SCBI_BDIR/$module

                if [ $DLOG = yes ]; then
                    module-pre-$step $SCBI_BDIR/$module/build/install $module \
                                     $variant $SCBI_TARGET $ISOOT | tee $log 2>&1
                else
                    module-pre-$step $SCBI_BDIR/$module/build/install $module \
                                     $variant $SCBI_TARGET $ISOOT >> $log 2>&1
                fi
            fi
            res=$?

            if [ $res != 0 ]; then
                if [ $DLOG = on-failure ]; then
                    tail -100 $log
                fi
                elog $module generic module pre-$step failed with error $res
                return $res
            fi

            #  Apply module specific step if any

            module-variant-wrapper $SCBI_BDIR/$module/build/install $module \
                                   $variant pre-$step || exit 1

            ########## module

            module-variant-wrapper $SCBI_BDIR/$module/build/install $module \
                                   $variant $step || exit 1

            #  Apply any generic step (module-setup, module-purge)

            fn-exists module-$step

            if [[ $? = 0 ]]; then
                cd $SCBI_BDIR/$module

                if [ $DLOG = yes ]; then
                    module-$step $SCBI_BDIR/$module/build/install $module \
                                 $variant $SCBI_TARGET $ISOOT | tee $log 2>&1
                else
                    module-$step $SCBI_BDIR/$module/build/install $module \
                                 $variant $SCBI_TARGET $ISOOT >> $log 2>&1
                fi
            fi
            res=$?

            if [ $res != 0 ]; then
                if [ $DLOG = on-failure ]; then
                    tail -100 $log
                fi
                elog $module generic module $step failed with error $res
                return $res
            fi

            ########## POST module

            module-variant-wrapper $SCBI_BDIR/$module/build/install $module \
                                   $variant post-$step || exit 1

            fn-exists module-post-$step

            if [[ $? = 0 ]]; then
                cd $SCBI_BDIR/$module

                if [ $DLOG = yes ]; then
                    module-post-$step $SCBI_BDIR/$module/build/install $module \
                                      $variant $SCBI_TARGET $ISOOT | tee $log 2>&1
                else
                    module-post-$step $SCBI_BDIR/$module/build/install $module \
                                      $variant $SCBI_TARGET $ISOOT >> $log 2>&1
                fi
            fi
            res=$?

            if [ $res != 0 ]; then
                if [ $DLOG = on-failure ]; then
                    tail -100 $log
                fi
                elog $module generic module post-$step failed with error $res
                return $res
            fi

            [ $step == install ] && echo -n $variant > install-id || true
        done
    ) || exit 1

    #  Create binary archive if needed

    if [ $DOARCHIVE = yes ]; then
        cd $SCBI_BDIR/$module/build >> $log 2>&1
        tar cf $module-bin.tar --directory=install .
        bzip2 -9 $module-bin.tar
    fi

    local _IDIR=""

    fn-exists $module-$variant-prefix

    if [ $? = 0 -a "$SCBI_DEFAULT_PREFIX" = "yes" ]; then
        _IDIR=$($module-$variant-prefix $SCBI_BDIR/$module/build/install $SCBI_TARGET)
    else
        fn-exists $module-prefix
        if [ $? = 0 -a "$SCBI_DEFAULT_PREFIX" = "yes" ]; then
            _IDIR=$($module-prefix $SCBI_BDIR/$module/build/install $SCBI_TARGET)
        else
            _IDIR=$SCBI_PREFIX
        fi
    fi

    if [ $_IDIR == NONE ]; then
        ilog $module skip global install

    elif [ "$DOINSTALL" = "yes" -a -d $SCBI_BDIR/$module/build/install ]; then
        ilog $module copy install into ..${_IDIR/$SCBI_BDIR/}

        #  Finaly copy to given prefix
        SUDO=""

        if [ ! -d ${_IDIR} ]; then
            mkdir -p ${_IDIR} &> /dev/null
            [ ! $? = 0 ] && SUDO=sudo
        fi

        if [ ! -w ${_IDIR} ]; then
            SUDO=sudo
        fi

        $SUDO mkdir -p ${_IDIR}/
        $SUDO rsync -a --force \
              $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install/. \
              ${_IDIR}/. > $log 2>&1
    fi || elog $module fail to copy to ${_IDIR}

    ilog $module End building $module-$variant
    line-sep
}

############################## body

# first we check for --enable-* options

SCBIOPTS=""

while [ $# -gt 0 ]; do
    case $1 in
        --enable-*)
            VAR=${1/--enable-/}
            export SCBI_${VAR/-/_}_SET=true
            ;;
        *)
            SCBIOPTS="$SCBIOPTS $1"
            ;;
    esac
    shift
done

set -- $(getopt -q -u -o t:j:adefSIuscbilnpPvwWh \
    -l target:,no-setup,no-install,update,setup,config,build,build-target:,install,no-log,purge,purge-only,verbose,prefix:,tests,tests-only,help,deps,archive,force,env:,no-patch:,plan:,stat,tar,list-depends,list-depends-with-meta,dry-run,jobs:,no-wrapup,wrapup -- $(echo $SCBIOPTS))

while [ $# -gt 0 ]; do
    case $1 in
        -h|--help)
            break
            ;;
        -f|--force)
            DOFORCE=yes
            ;;
        -a|--archive)
            DOARCHIVE=yes
            ;;
        -e|--env)
            ENV_NAME="-$2"
            shift
            ;;
        --tar)
            TAR_CACHE=no
            ;;
        -t|--target)
            SCBI_TARGET=$2; shift
            SCBI_TARGET_SPECIFIED=yes
            ;;
        -S|--no-setup)
            STEPS=${STEPS/setup/}
            ;;
        -W|--no-wrapup)
            STEPS=${STEPS/wrapup/}
            ;;
        -w|--wrapup)
            NSTEPS="$NSTEPS wrapup"
            ;;
        -I|--no-install)
            DOINSTALL=no
            ;;
        -u|--update)
            DOUPDATE=yes
            ;;
        -s|--setup)
            NSTEPS="$NSTEPS setup"
            ;;
        -c|--config)
            NSTEPS="$NSTEPS config"
            ;;
        -b|--build)
            NSTEPS="$NSTEPS build"
            ;;
        --build-target)
            BUILD_SCBI_TARGET=$2; shift
            ;;
        -d|--deps)
            DEPS=yes
            ;;
        -i|--install)
            NSTEPS="$NSTEPS install"
            DOINSTALL=yes
            ;;
        -l|--no-log)
            DLOG=no
            ;;
        --tests)
            NSTEPS="$NSTEPS setup config build install tests wrapup"
            DOTEST=true
            ;;
        --tests-only)
            NSTEPS="$NSTEPS tests"
            DOTEST=true
            ;;
        -v|--verbose)
            DLOG=yes
            ;;
        -p|--purge)
            PURGE=yes
            ;;
        -n|--no-patch)
            PATCH=no
            ;;
        --prefix)
            SCBI_DEFAULT_PREFIX=no
            SCBI_PREFIX=$2; shift
            ;;
        -P|--purge-only)
            PURGE=only
            ;;
        -j|--jobs)
            SCBI_JOBS=$2; shift
            ;;
        --plan)
            SCBI_PLAN=$2; shift
            ;;
        --stat)
            DOSTAT=yes;
            ;;
        --list-depends)
            DODEPS=yes;
            ;;
        --list-depends-with-meta)
            DODEPS=yes-meta;
            ;;
        --dry-run)
            DRY_RUN=yes;
            ;;
        (--)
            ;;
        (*)
            MODULES="$MODULES $1"
            ;;
        (-*)
            echo "$0: error - unrecognized option $1" 1>&2; exit 1
            ;;
    esac
    shift
done

trap clean-up EXIT

#  Load module definitions

[ ! -d "$SCBI_DEFS" -o -z "$(ls $SCBI_DEFS/[0-9]* 2> /dev/null)" ] &&
    SCBI_DEFS=$HOME/.config/scbi

[ ! -d "$SCBI_DEFS" ] && echo $0: cannot find module definition files && exit 1

#  Load user's environment if any now that SCBI_DEFS is set

load-module-env $ENV_NAME

#  If we have explicitly specified some steps, use them

if [ "$NSTEPS" != "" ]; then
    STEPS=$NSTEPS
fi

#  Then load any global settings, not overriding user's ones

for setup in $SCBI_DEFS/[0-9]*; do
    source $setup
done

#  Load build plan if any

[ ! -z $SCBI_PLAN ] && load-module-plan $SCBI_PLAN

#  Nothing to build, display usage

[ "$MODULES" = "" -a $DOSTAT == no ] && usage

[ $DOSTAT == yes ] && display-stat

[ "$MODULES" = "" -o $DOSTAT == yes ] && display-modules && display-plans

[ $DOSTAT == yes ] && display-log-stat

if [ $DODEPS == yes ]; then
    for module in $MODULES; do
        for-all-modules display-env-callback $module
    done
    exit 0
elif [ $DODEPS == yes-meta ]; then
    for module in $MODULES; do
        for-all-modules-with-meta display-env-callback $module
    done
    exit 0
fi

#  Prepare log dir and tarball dir

mkdir -p $SCBI_LOGS/$TODAY
mkdir -p $SCBI_TAR

if [ $DRY_RUN == yes ]; then
    PURGE=no
    DOINSTALL=no
    DOARCHIVE=no
    DOUPDATE=no
    DOFORCE=no
    STEPS=""
fi

#  Run script for all modules

for module in $MODULES; do
    handle-module $module
done
