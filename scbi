#!/bin/bash
#
#  For all modules the following function can be implemented and are called
#  in this specific order:
#
#    update   not done by default, to update repository
#    setup    to setup build structure
#    config   to configure, ./configure or other steps
#    build    to build, make
#    install  to install
#

CDPATH=

HOST=$(gcc -dumpmachine | sed -e 's/-pc//;s/-unknown//')
TARGET=$HOST
MODULES=
DLOG=on-failure
DEFS="$PWD"/scripts.d
PURGE=no
NSTEPS=
TARGET_SPECIFIED=no
JOBS=0
TARVERSION=

STEPS="setup config build install"

############################## fn-exists

function fn-exists()
{
    declare -f $1 > /dev/null
}

############################## module-wrapper

function module-wrapper()
{
    module=$1
    step=$2
    log=$LOGS/$TARGET-$module-$step.log

    ilog $module $step starting

    mkdir -p $BDIR/$module > $log 2>&1
    cd $BDIR/$module  >> $log 2>&1

    if [[ $DLOG = yes || "$step" = "tests" ]]; then
	$module-$step $PREFIX $TARGET | tee $log 2>&1
    else
	$module-$step $PREFIX $TARGET >> $log 2>&1
    fi
    res=$?

    if [ $res != 0 ]; then
	if [ $DLOG = on-failure ]; then
	    tail -100 $log
	fi
	elog $module $step failed with error $res
	return $res
    else
        #  Apply any generic step
        fn-exists module-$step
        if [[ $? = 0 ]]; then
            if [ $DLOG = yes ]; then
                module-$step $PREFIX $TARGET | tee $log 2>&1
            else
                module-$step $PREFIX $TARGET >> $log 2>&1
            fi
        fi
        res=$?

        if [ $res != 0 ]; then
	    if [ $DLOG = on-failure ]; then
	        tail -100 $log
	    fi
	    elog generic module $step failed with error $res
	    return $res
        else
	    ilog $module $step completed
	    return 0
        fi
    fi
}

############################## usage

function usage()
{
    local k=0

    echo
    echo $0 [tSIscbilv] module1 [module2 ... modulen]

    echo "   -t | --target name  specify the target to build for ($TARGET)"
    echo "   -S | --no-setup     skip setup"
    echo "   -I | --no-install   skip install"
    echo "   -a | --ar version   use sources tarball version-module-src.tar.gz"
    echo "   -u | --update       do update"
    echo "   -s | --setup        do setup"
    echo "   -c | --config       do config"
    echo "   -b | --build        do build"
    echo "   -i | --install      do install"
    echo "   -r | --tests        run the testsuite"
    echo "   -v | --verbose      display full log"
    echo "   -l | --no-log       never display log"
    echo "   -p | --purge        remove builds directories before building"
    echo "   -P | --purge-only   only remove builds directories"
    echo "   -j | --jobs         max compilation jobs"

    echo
    echo -n modules:

    for module in $DEFS/[^0-9]*; do
	echo -n " $(basename $module)"
	k=$(expr $k + 1)
	[ $k == 7 ] && k=0 && echo && echo -n "        "
    done
    echo

    exit 1
}

############################## module-wrapper

function handle-module()
{
    module=$1
    log=$LOGS/$TARGET-$module-report.log

    cd $ROOT

    [ ! -f $DEFS/$module ] &&
    echo No description for module $module &&
    exit 1

    #  Then load module setup

    source $DEFS/$module

    #  Check meta-modules

    fn-exists $module-modules
    if [[ $? = 0 ]]; then
        for module in $($module-modules); do
            handle-module $module
        done
        return
    fi

    clog $module

    #  If purge is asked, first remove current build structure

    if [ $PURGE = yes -o $PURGE = only ]; then
	ilog build Purging $module
        [ -d $BDIR/$module ] && cd $BDIR/$module && module-purge $PREFIX $TARGET
    fi

    [ $PURGE = only ] && exit 0

    ilog build Building $module for target $TARGET | tee -a $log
    ilog build steps : $STEPS | tee -a $log

    #  Log current enviroment

    env > $LOGS/$TARGET-$module-env.log
    echo "===============================================" \
	>> $LOGS/$TARGET-$module-env.log
    gnat ls -v >> $LOGS/$TARGET-$module-env.log 2> /dev/null
    which gcc >> $LOGS/$TARGET-$module-env.log 2> /dev/null

    #  If building from tarball, extract it now

    if [ ! -z $TARVERSION ]; then
        [ ! -f $TARBALL/$TARVERSION-$module-src.tar.gz ] &&
        echo Tarball $TARBALL/$TARVERSION-$module-src.tar.gz not found. &&
        exit 1

	ilog build Extract tarball $TARVERSION-$module-src.tar.gz

        [ ! -d $BDIR/$module ] && mkdir -p $BDIR/$module > $log 2>&1

        cd $BDIR/$module
        ( rm -fr src && mkdir -p src ) > $log 2>&1
        cd src

        tar xf $TARBALL/$TARVERSION-$module-src.tar.gz
        topdir=$(ls -d *)

        if [ -d "$topdir" ]; then
            mv $topdir/* .
            rmdir $topdir
            cd ..
        else
            echo Error, no top directory found.
            exit 1
        fi

        # We set the link for the source so that no module will have to do it

        rm -f src_cp
        ln -s src src_cp
    else
        # We need to remove the link/sources to ensure proper setting by the
        # module.
        [ -d $BDIR/$module ] && cd $BDIR/$module && rm -fr src src_cp
    fi

    #  Call module routines

    for step in $STEPS; do
	fn-exists $module-$step
	if [[ $? = 0 ]]; then
	    module-wrapper $module $step || exit 1
	fi
    done
    echo
}

############################## body

set -- $(getopt -u -o t:a:SIuscbilpPvr \
    -l ar:,target:,no-setup,no-install,update,setup,config,build,install,no-log,purge,purge-only,verbose,prefix:,tests -- "$@")

while [ $# -gt 0 ]; do
    case $1 in
	-t|--target)
	    TARGET=$2; shift
            TARGET_SPECIFIED=yes
	    ;;
	-S|--no-setup)
	    STEPS=${STEPS/setup/}
	    ;;
	-I|--no-install)
	    STEPS=${STEPS/install/}
	    ;;
        -a|--ar)
            TARVERSION=$2; shift
            ;;
	-u|--update)
	    NSTEPS="$NSTEPS update"
	    STEPS="update $STEPS"
	    ;;
	-s|--setup)
	    NSTEPS="$NSTEPS setup"
	    ;;
	-c|--config)
	    NSTEPS="$NSTEPS config"
	    ;;
	-b|--build)
	    NSTEPS="$NSTEPS build"
	    ;;
	-i|--install)
	    NSTEPS="$NSTEPS install"
	    ;;
	-l|--no-log)
	    DLOG=no
	    ;;
	-r|--tests)
	    NSTEPS="$NSTEPS tests"
	    ;;
	-v|--verbose)
	    DLOG=yes
	    ;;
	-p|--purge)
	    PURGE=yes
	    ;;
	--prefix)
	    PREFIX=$2; shift
	    ;;
	-P|--purge-only)
	    PURGE=only
	    ;;
        -j|--jobs)
            JOBS=$2; shift
            ;;
	(--)
	    ;;
	(*)
	    MODULES="$MODULES $1"
	    ;;
	(-*)
	    echo "$0: error - unrecognized option $1" 1>&2; exit 1
	    ;;
    esac
    shift
done

[ ! -d "$DEFS" ] && DEFS=$HOME/.scbi.d

[ ! -d "$DEFS" ] && echo $0: cannot find module definition files && exit 1

rm -f "$DEFS"/*~

[ "$MODULES" = "" ] && usage

#  If we have explicitly specified some steps, use them

if [ "$NSTEPS" != "" -a "$NSTEPS" != " update" ]; then
    STEPS=$NSTEPS
fi

#  Load user's settings if any

[ -f $HOME/.scbi ] && source $HOME/.scbi

#  Then load any global settings, not overriding user's ones

for setup in $DEFS/[0-9]*; do
    source $setup
done

#  Prepare log dir

mkdir -p $LOGS

#  Run script for all modules

for module in $MODULES; do
    handle-module $module
done
