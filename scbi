#!/bin/bash
#
#  This is a script to build applications from sources. The simplest usage is:
#
#     $ scbi darktable
#
#  To build an application called darktable. An application can be given a
#  variant build:
#
#     $ scbi darktable/debug
#
#  And eventually a branch (in the repository) or a version for the tarball.
#
#     $ scbi darktable/debug:release-2.4.x
#
#  To differenciate a version from a branch, the version string starts with '#'.
#
#  Finally darktable is a module for which a set of function is given in the
#  darktable source file.
#
#  For all modules the following function can be implemented and are called
#  in this specific order:
#
#    <module>-vcs      parameter: NONE, return: array
#                      describe the VCS to get the sources
#                        1st item: protocole (git, svn)
#                        2nd item: URL
#
#    <module>-tar      parameter: $VERSION, return: array
#                      describe a way to get the sources as tarball
#                        1st item: protocole (scp, none)
#                        2st item: URL
#                        3st item: archive name (with $VERSION)
#
#    <module>-version  parameter: $PREFIX $TARGET, return: <installed version>
#                      returns the current version of the installed tool
#                      It can returns $VERSION_OK or $VERSION_ERROR if it
#                      is not possible to get the real version.
#
#    <module>-depends  parameter: NONE, return: array
#                      list all modules required. these are either
#                      source module handled by this script or a distrib
#                      package. each module is <name>:<version>
#
#    <module>-env      parameter: $PREFIX $TARGET, return NONE
#                      set environment to use when calling the routines
#                      (setup, config, build, install, tests).
#
#    <module>-setup    parameter: $PREFIX $TARGET, return NONE
#                      to setup build structure (optional)
#                      also: pre-setup / post-setup
#
#    <module>-config   parameter: $PREFIX $TARGET, return NONE
#                      to configure, ./configure or other steps
#                      also: pre-config / post-config
#
#    <module>-build    parameter: $PREFIX $TARGET, return NONE
#                      to build, make
#                      also: pre-build / post-build
#
#    <module>-install  parameter: $PREFIX $TARGET, return NONE
#                      to install (in $PREFIX)
#                      also: pre-install / post-install
#
#    <module>-prefix   parameter: $PREFIX $TARGET, return string
#                      the directory to install, default $BDIR/install
#
#    <module>-tests    parameter: $PREFIX $TARGET, return NONE
#                      to pass automatic tests
#
#  Note that all steps above are optional. And empty module will just do
#  nothing. For setup, config, build, install it may exists version pre/post
#  which may be used for complex module handling. The order is the following:
#
#     1. module-pre-<step>      - the generic pre step handled internally
#     2. <module>-pre-<step>    - done before step
#     3. <module>-<step>        - default step is done before generic one
#     4. module-<step>          - the generic step handled internally
#     5. <module>-post-<step>   - done after step
#     6. module-post-<step>     - the generic post step handled internally
#
#  The following steps (2, 4 and 5 above) can have variants and/or cross
#  hooks:
#
#     <module>-<variant>[-cross]-depends
#     <module>-<variant>[-cross]-env
#     <module>-<variant>[-cross]-setup
#     <module>-<variant>[-cross]-config
#     <module>-<variant>[-cross]-build
#     <module>-<variant>[-cross]-install
#     <module>-<variant>[-cross]-prefix
#
#  The steps routines (for 2, 4 and 5) are checked in the following order and
#  the first found is called:
#
#     <module>-<variant>-cross-<step>
#     <module>-cross-<step>
#     <module>-<variant>-<step>
#     <module>-<step>
#
#  It is possible to build from a tarball, the tar must be placed into the
#  TARBALL directory.
#
#  After the sources are setup, it is possible to apply some local patches.
#  the patches must be placed into the PATCHES directory and named:
#
#     <module>-<numeric-id>-<some-name>.patch
#
#  patches are applied using <numeric-id> ordering.
#
#  The final step is to install into the final location, the copy is done
#  by default.
#
#  Variables:
#  ----------
#
#  ROOT       : default root directory to use
#  BDIR       : the modules build root directory ($ROOT/builds)
#  GREPO      : directory with local Git repositories ($ROOT/repositories/git)
#  SREPO      : directory with local Svn repositories ($ROOT/repositories/svn)
#  TARBALL    : directory where downloaded tarball are stores ($BDIR/tar)
#  PREFIX     : directory where module are to be installed ($BDIR/install)
#  HOST       : current host (gcc -dumpmachine)
#  TARGET     : current target ($HOST)
#  DEFS       : where module scripts are to be found
#               ($PWD/.scripts.d $HOME/.config/scbi)
#
#  Structure:
#  ----------
#
#  $BDIR
#    |
#    |_ .vcs
#    |    |_ <module>             # module checkout, all sources
#    |
#    |_ .patches
#    |
#    |_ .tar
#    |    |_ <module>-<version>-src.tar.gz
#    |
#    |_ <module>
#         |_ build                # symlink to current/latest target build dir
#         |_ build-id-<variant>   # build id to check for changes
#         |_ src                  # symlink to sources (vcs or tarball)
#         |_ tarsrc               # extract of tarball
#         |_ source-id            # version of the source (tar or vcs)
#         |_ install-id           # version of the installed module
#         |_ vcs                  # sources
#         |_ <target>-<variant>
#                |
#                |_ build         # build directory
#                |_ build-id      # sha1 to identify the build
#                |_ install       # installation directory
#                |_ manifest      # list of all files in install above
#                |_ src           # rsync of ../src
#
#  vcs : is either a copy of .vcs/<module> or a symlib to user's local checkout
#  src : is either a link to [vcs] or [tarsrc]

CDPATH=

#  Environment
HOST=$(gcc -dumpmachine | sed -e 's/-pc//;s/-unknown//')
TARGET=$HOST
TARGET_SPECIFIED=no
ENV_NAME=

#  General script setup
DLOG=on-failure
DEFS="$PWD"/scripts.d
JOBS=0
MJOBS=4
# MJOBS is for makefiles

#  Modules to be handled and already handled
MODULES=
HANDLED=""

#  Actions setup
PURGE=no
NSTEPS=
PREFIX=
DEFAULT_PREFIX=yes
DOINSTALL=yes
DOUPDATE=no
DOTEST=no
DOARCHIVE=no
DOFORCE=no
DEPS=no
ISOOT=no
PATCH=yes
STEPS="setup config build install"
BUILD_TARGET=
PLAN=

############################## check-handled
#
# check wether a module has already been handled

function check-handled()
{
    local module=$1
    local res=0

    if [ "${HANDLED/,$module,/}" = "$HANDLED" ]; then
        HANDLED="$HANDLED,$module,"
        return 0
    else
        return 1
    fi
}

############################## module-wrapper
#
# called for each module and step

function module-wrapper()
{
    local PREFIX=$1
    local module=$2
    local variant=$3
    local step=$4

    log=$LOGS/$TARGET-$module-$variant-$step.log

    if [ $step = "build" -a "$BUILD_TARGET" != "" ]; then
        mstep=build-$BUILD_TARGET
    else
        mstep=$step
    fi

    ilog $module $mstep starting

    (
        cd $BDIR/$module >> $log 2>&1

        #  Set cross-env is needed

        if [ "$HOST" != "$TARGET" ]; then
            target-env $BDIR/install $TARGET
        fi

        #  And setup any module environment

        fn-exists $module-$variant-env

        if [ $? = 0 ]; then
            $module-$variant-env $BDIR/$module/build/install $TARGET
        else
            fn-exists $module-env

            if [ $? = 0 ]; then
                $module-env $BDIR/$module/build/install $TARGET
            fi
        fi

        #  Go to build directory

        if [ "$step" = "setup" ]; then
            cd $BDIR/$module
        else
            cd $BDIR/$module/build/build
        fi

        #  Call module step

        if [[ $DLOG = yes || "$step" = "tests" ]]; then
	    $module-$step $PREFIX $TARGET | tee $log 2>&1
        else
	    $module-$mstep $PREFIX $TARGET >> $log 2>&1
        fi
        res=$?

        #  Check for errors

        if [ $res != 0 ]; then
	    if [ $DLOG = on-failure ]; then
	        tail -100 $log
	    fi
	    elog $module $mstep failed with error $res
	    return $res
        else
	    ilog $module $mstep completed
	    return 0
        fi
    )
}

############################## module-variant-wrapper
#
# called for each module, variant and step, switch to proper step to call
# depending on the existence of the variant.

function module-variant-wrapper()
{
    local PREFIX=$1
    local module=$2
    local variant=$3
    local step=$4

    if [ "$HOST" != "$TARGET" ]; then
        fn-exists $module-$variant-cross-$step

        if [[ $? = 0 ]]; then
	    module-wrapper $BDIR/$module/build/install $module \
                           $variant $variant-cross-$step || exit 1
            return 0
        else
            fn-exists $module-cross-$step

            if [[ $? = 0 ]]; then
	        module-wrapper $BDIR/$module/build/install $module \
                               $variant cross-$step || exit 1
                return 0
            fi
        fi
    fi

    fn-exists $module-$variant-$step

    if [[ $? = 0 ]]; then
	module-wrapper $BDIR/$module/build/install $module \
                       $variant $variant-$step || exit 1

    else
        fn-exists $module-$step

        if [[ $? = 0 ]]; then
	    module-wrapper $BDIR/$module/build/install $module \
                           $variant $step || exit 1
        fi
    fi
}

############################## usage

function usage()
{
    echo
    echo $0 [options] module1 [module2 ... modulen]

    echo ""
    echo "   modulen  <name>/<variant> build <variant> from repository version"
    echo "   modulen  <name>:<branch>  build from repository version <branch>"
    echo "   modulen  <name>:#<ver>    build from tarbal version <ver>"
    echo "   modulen  <name>:dev       build from user's repository current branch"
    echo "   modulen  <name>           build from repository main branch"
    echo ""
    echo "   -h | --help          this help message"
    echo "   -e | --env=<name>    environment file ~/.scbi-<name>"
    echo "   -t | --target=<name> specify the target to build for ($TARGET)"
    echo "   -S | --no-setup      skip setup"
    echo "   -I | --no-install    skip install"
    echo "   -u | --update        do update"
    echo "   -s | --setup         do setup"
    echo "   -c | --config        do config"
    echo "   -b | --build         do build"
    echo "   -i | --install       do install"
    echo "      | --tests         run the testsuite, build if necessary"
    echo "      | --tests-only    run the testsuite"
    echo "   -d | --deps          check/build dependencies"
    echo "   -a | --archive       build binary archive"
    echo "   -v | --verbose       display full log"
    echo "   -l | --no-log        never display log"
    echo "   -f | --force         force rebuild, do not check build id"
    echo "   -p | --purge         remove builds directories before building"
    echo "   -P | --purge-only    only remove builds directories"
    echo "      | --plan          add a build plan for modules"
    echo "   -n | --no-patch      do not apply patches"
    echo "   -j | --jobs=<n>      max compilation jobs"

    echo
    echo -n modules:

    local linelen=0

    for module in $DEFS/[^0-9]*; do
        bn=$(basename $module)
        linelen=$(expr $linelen + ${#bn} + 1)
        if [ $linelen -gt 70 ]; then
            echo
            echo -n "        "
            linelen=${#bn}
        fi
	echo -n " $bn"
    done
    echo

    exit 1
}

############################## handle-env
#
# recursively set the environment for the module based on the dependencies

function handle-env()
{
    local modref=$1

    #  Get module information

    local module_info=( $(get-module-ref $modref) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    #  Then load module

    if [ -f $DEFS/$module ]; then
        source $DEFS/$module

        # setup depends recursively if any

        fn-exists $module-$variant-depends

        if [ $? = 0 ]; then
            for dmodule in $($module-$variant-depends); do
                handle-env $dmodule
            done
        else
            fn-exists $module-depends

            if [ $? = 0 ]; then
                for dmodule in $($module-depends); do
                    handle-env $dmodule
                done
            fi
        fi

        # then setup the current module

        if [ -d $BDIR/$module/$TARGET-$variant/install ]; then
            cd $BDIR/$module/$TARGET-$variant/install
        else
            cd $BDIR/$module/$TARGET-$variant
        fi

        fn-exists $module-$variant-env

        if [ $? = 0 ]; then
            $module-$variant-env $BDIR/$module/build/install $TARGET
        else
            fn-exists $module-env

            if [ $? = 0 ]; then
                $module-env $BDIR/$module/build/install $TARGET
            fi
        fi
    fi
}

############################## handle-depends
#
# check for module dependencies, handle them if build scripts found for
# them. Also check for distrib packages if exists.

function handle-depends()
{
    local modref=$1

    local module_info=( $(get-module-ref $modref) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    #  If we want latest version, just handle this module

    if [ "$kind" = "DEV" ]; then
        handle-module $1
        return
    fi

    cd $ROOT

    #  If module not found, check for a possible distrib package

    if [ ! -f $DEFS/$module ]; then
        check-pkg $module:$ref

        if [ $? = 0 ]; then
            return 0
        else
            echo No description for module $module &&
            echo And not found in the distrib  &&
            exit 1
        fi
    fi

    #  Check if the proper version is installed

    source $DEFS/$module

    fn-exists $module-version
    if [[ $? = 0 ]]; then
        pushd $(mktemp -d) > /dev/null 2>&1

        mver=$($module-version $PREFIX $TARGET)

        [ "${PWD:0:4}" = "/tmp" ] && rm -r $(pwd)

        popd > /dev/null 2>&1
    else
        mver=$VERSION_OK
    fi

    #  Clean-up the version number (only digits and a single dot)

    mver=$(get-version-number $mver)

    cd $ROOT

    [ "$ref" = "NONE" ] && ref=0

    [ $DOFORCE = yes ] && rm -f $BDIR/$module/build/build-id

    #  Check build id, only rebuild if mismatch

    diff -q $BDIR/$module/build-id $BDIR/$module/build/build-id > /dev/null 2>&1

    if [[ $? != 0 \
              || "$mver" = "" \
              || "$mver" = $VERSION_ERROR \
              || $ref > $mver ]];
    then
        echo
        ilog build need building $module, \
             current version $(display-version $mver) | tee -a $log
        handle-module $modref
    else
        ilog build $modref found
    fi
}

############################## handle-sources
#
#  get the module sources from a tar or a vcs
#

function handle-sources()
{
    local modref=$1

    #  Get module information

    local module_info=( $(get-module-ref $modref) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    #  If building from tarball, extract it now

    if [ $kind == VERSION ]; then
        fn-exists $module-tar

        if [[ ! $? = 0 ]]; then
            echo "error: $module-tar function not defined, cannot get tarball"
            exit 1
        fi

        #  We need to extract the tarball if the version does not match
        #  the one currently extracted.

        if [ -f source-id ]; then
            if [ "$(cat source-id)" != "tar-$ref" ]; then
                rm -fr tarsrc
            fi
        fi

        echo -n tar-$ref > source-id

        if [ $DOUPDATE = yes -o ! -d tarsrc  ]; then
	    ilog build get sources from tar

            vid=$(get-tar $module $ref >> $log 2>&1)

            if [[ ! $? = 0 ]]; then
                ilog build cannot get/find tar sources
                exit 1
            fi

            #  Compute and store the version id of the sources + compiler.
            #  That is when the compiler is changed when want to rebuild
            #  the software.
            get-build-id $PREFIX $TARGET $vid > build-id-$variant
        fi

        #  We set the link for the source so that no module will have to
        #  do it.

        ln -s tarsrc src

    else
        # Get sources from repository

        fn-exists $module-vcs

        if [[ $? = 0 ]]; then
            if [ $kind = DEV ]; then
                if [ -d $GREPO/$module ]; then
                    ln -s $GREPO/$module vcs

                    #  Compute and store the version id of the sources +
                    #  compiler. That is when the compiler is changed we
                    #  want to rebuild the software.

                    vcs-build-id $PREFIX $TARGET $module $(pwd)/vcs \
                                 > build-id-$variant

                    echo -n $ref > source-id

                else
                    ilog build cannot find local dev repository:
                    ilog build $GREPO/$module
                    exit 1
                fi

            else
                vcs=( $($module-vcs) )
                VCS_NAME=${vcs[0]}
                VCS_URL=${vcs[1]}

                REPO=$(basename $VCS_URL .git)

                if [ -f source-id ]; then
                    if [ "$(cat source-id)" != "vcs-$ref" ]; then
                        # a different version is needed
                        DOUPDATE=yes
                    fi
                fi

                echo -n vcs-$ref > source-id

                if [ $DOUPDATE = yes -o ! -d ../.vcs/$REPO ]; then
	            ilog build get sources from $VCS_NAME

                    get-vcs $VCS_NAME $VCS_URL $module $kind $ref

                    if [[ ! $? = 0 ]]; then
                        exit 1
                    fi
                else
                    ln -s ../.vcs/$REPO vcs
                fi

                #  Compute and store the version id of the sources +
                #  compiler. That is when the compiler is changed we
                #  want to rebuild the software.

                vcs-build-id $PREFIX $TARGET $module $(pwd)/vcs \
                             > build-id-$variant
            fi

            ln -s vcs src

        else
            #  No VCS, not TAR, just rebuild the sources
            get-build-id $PREFIX $TARGET $module "$(date)" \
                         > build-id-$variant
        fi

        #  If get-vcs is not defined then the $module-setup routine is in
        #  charge of creating/populating the src directory.
    fi
}

############################## handle-module

function handle-module()
{
    local modref=$1

    #  Get module information

    local module_info=( $(get-module-ref $modref) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    log=$LOGS/$TARGET-$module-$variant-report.log

    #  Check if we have already handled this module

    check-handled $module+$variant
    if [[ $? = 1 ]]; then
        return
    fi

    cd $ROOT

    [ ! -f $DEFS/$module ] &&
        echo No description for module $module &&
        exit 1

    #  Then load module setup

    source $DEFS/$module

    #  Create module build directory

    mkdir -p $BDIR/$module/$TARGET-$variant > $log 2>&1

    #  Check if meta-module, if so call handle-module for each one

    fn-exists $module-$variant-modules

    if [[ $? = 0 ]]; then
        (
            for module in $($module-$variant-modules); do
                handle-module $module
            done
        )
        return
    else
        fn-exists $module-modules
        if [[ $? = 0 ]]; then
            (
                for module in $($module-modules); do
                    handle-module $module
                done
            )
            return
        fi
    fi

    # Check for depends if any, and handle them if any

    if [ $DEPS = yes ]; then
        fn-exists $module-$variant-depends

        if [[ $? = 0 ]]; then
            (
                for module in $($module-$variant-depends); do
                    handle-depends $module
                done
            )
            if [[ ! $? = 0 ]]; then
                exit 1
            fi
            echo
        else
            fn-exists $module-depends

            if [[ $? = 0 ]]; then
                (
                    for module in $($module-depends); do
                        handle-depends $module
                    done
                )
                if [[ ! $? = 0 ]]; then
                    exit 1
                fi
                echo
            fi
        fi
    fi

    clog $module

    #  If purge is asked, first remove current build structure

    if [ $PURGE = yes -o $PURGE = only ]; then
	ilog build Purging $module for $TARGET/$variant
        [ -d $BDIR/$module ] &&
            module-purge $BDIR/$module $module $variant $TARGET
    fi

    #  If purge-only, stop there

    [ $PURGE = only ] && exit 0

    ilog build Building $module-$variant | tee -a $log
    ilog build target $TARGET | tee -a $log
    ilog build steps : $STEPS | tee -a $log

    #  Create the build root directory if needed, note that we do check here
    #  even if already created when entering this routine. This is because
    #  in case of a purge the build directory could have been removed.

    [ -d $BDIR/$module/$TARGET-$variant ] || mkdir $BDIR/$module/$TARGET-$variant

    #  Set module environment if defined

    (
        handle-env $modref

        #  Log module enviroment

        ENVLOG=$LOGS/$TARGET-$module-$variant-env.log

        echo "==================== env " > $ENVLOG
        env >> $ENVLOG

        [ ! -z $(which gprls) ] &&
            (
                echo "==================== gprls " >> $ENVLOG
                gprls -v 2>&1 >> $ENVLOG
            )

        [ ! -z $(which gcc) ] &&
            (
                echo "==================== gcc " >> $ENVLOG
                gcc -v &>> $ENVLOG
            )

        #  We need to remove the link/sources to ensure proper setting by
        #  the module.

        [ -d $BDIR/$module ] && cd $BDIR/$module && rm -fr src vcs

        handle-sources $modref

        #  Check if envrionment is to be done for out-of-tree build

        fn-exists $module-out-of-tree

        [ $? = 0 ] && [ $($module-out-of-tree) = "true" ] && ISOOT=yes

        #  Call module routines

        #  If force build, remove the current build id

        [ $DOFORCE = yes ] && rm -f build/build-id

        #  Check build id, only rebuild if mismatch

        diff -q build-id-$variant \
             $BDIR/$module/$TARGET-$variant/build-id > /dev/null 2>&1

        if [ $? = 0 ]; then
	    ilog build no build needed, versions match

            STEPS=""

            # if install variant changed, do install

            if [ $(cat install-id) != $variant ]; then
                STEPS="install"
                DOINSTALL=yes

                # then make sure the current build softlink is
                # pointing to the variant. this is needed as the setup
                # won't be done.

                cd $BDIR/$module
                [ -h build ] && rm -f build
                ln -s $TARGET-$variant build
            fi

            # if testing is expected, at least do that

            if [ $DOTEST = true ]; then
                STEPS="$STEPS tests"
            fi
        fi

        for step in $STEPS; do
            ########## PRE module

            #  Apply any generic step (module-setup, module-purge)

            fn-exists module-pre-$step

            if [[ $? = 0 ]]; then
                cd $BDIR/$module

                if [ $DLOG = yes ]; then
                    module-pre-$step $BDIR/$module/build/install $module \
                                     $variant $TARGET $ISOOT | tee $log 2>&1
                else
                    module-pre-$step $BDIR/$module/build/install $module \
                                     $variant $TARGET $ISOOT >> $log 2>&1
                fi
            fi
            res=$?

            if [ $res != 0 ]; then
	        if [ $DLOG = on-failure ]; then
	            tail -100 $log
	        fi
	        elog generic module pre-$step failed with error $res
	        return $res
            fi

            #  Apply module specific step if any

            module-variant-wrapper $BDIR/$module/build/install $module \
                                   $variant pre-$step || exit 1

            ########## module

            module-variant-wrapper $BDIR/$module/build/install $module \
                                   $variant $step || exit 1

            #  Apply any generic step (module-setup, module-purge)

            fn-exists module-$step

            if [[ $? = 0 ]]; then
                cd $BDIR/$module

                if [ $DLOG = yes ]; then
                    module-$step $BDIR/$module/build/install $module \
                                 $variant $TARGET $ISOOT | tee $log 2>&1
                else
                    module-$step $BDIR/$module/build/install $module \
                                 $variant $TARGET $ISOOT >> $log 2>&1
                fi
            fi
            res=$?

            if [ $res != 0 ]; then
	        if [ $DLOG = on-failure ]; then
	            tail -100 $log
	        fi
	        elog generic module $step failed with error $res
	        return $res
            fi

            ########## POST module

            module-variant-wrapper $BDIR/$module/build/install $module \
                                   $variant post-$step || exit 1

            fn-exists module-post-$step

            if [[ $? = 0 ]]; then
                cd $BDIR/$module

                if [ $DLOG = yes ]; then
                    module-post-$step $BDIR/$module/build/install $module \
                                      $variant $TARGET $ISOOT | tee $log 2>&1
                else
                    module-post-$step $BDIR/$module/build/install $module \
                                      $variant $TARGET $ISOOT >> $log 2>&1
                fi
            fi
            res=$?

            if [ $res != 0 ]; then
	        if [ $DLOG = on-failure ]; then
	            tail -100 $log
	        fi
	        elog generic module post-$step failed with error $res
	        return $res
            fi

            [ $step == install ] && echo -n $variant > install-id || true
        done
    ) || exit 1

    #  Create binary archive if needed

    if [ $DOARCHIVE = yes ]; then
        cd $BDIR/$module/build >> $log 2>&1
        tar cf $module-bin.tar --directory=install .
        bzip2 -9 $module-bin.tar
    fi

    #  Finaly copy to given prefix
    SUDO=""

    fn-exists $module-$variant-prefix

    if [ $? = 0 -a "$DEFAULT_PREFIX" = "yes" ]; then
        IDIR=$($module-$variant-prefix)
    else
        fn-exists $module-prefix
        if [ $? = 0 -a "$DEFAULT_PREFIX" = "yes" ]; then
            IDIR=$($module-prefix)
        else
            IDIR=$PREFIX
        fi
    fi

    if [ ! -w $IDIR ]; then
        SUDO=sudo
    fi

    if [ "$DOINSTALL" = "yes" -a -d $BDIR/$module/build/install ]; then
	ilog build copy install into ..${IDIR/$BDIR/}
        $SUDO mkdir -p $IDIR/
        $SUDO rsync -a $BDIR/$module/$TARGET-$variant/install/. $IDIR/. > $log 2>&1
    fi || elog fail to copy to $IDIR

    echo
}

############################## body

set -- $(getopt -u -o t:adefSIuscbilnpPvh \
    -l target:,no-setup,no-install,update,setup,config,build,build-target:,install,no-log,purge,purge-only,verbose,prefix:,tests,tests-only,help,deps,archive,force,env,no-patch:,plan: -- "$@")

while [ $# -gt 0 ]; do
    case $1 in
	-h|--help)
            usage
            exit
	    ;;
	-f|--force)
            DOFORCE=yes
	    ;;
	-a|--archive)
            DOARCHIVE=yes
	    ;;
	-e|--env)
            ENV_NAME="-$2"
            if [ ! -f $HOME/.config/scbi/.scbi${ENV_NAME} ]; then
                echo "error: scbi environment $2 not found"
                exit 1
            fi
            shift
	    ;;
	-t|--target)
	    TARGET=$2; shift
            TARGET_SPECIFIED=yes
	    ;;
	-S|--no-setup)
	    STEPS=${STEPS/setup/}
	    ;;
	-I|--no-install)
            DOINSTALL=no
	    ;;
	-u|--update)
            DOUPDATE=yes
	    ;;
	-s|--setup)
	    NSTEPS="$NSTEPS setup"
	    ;;
	-c|--config)
	    NSTEPS="$NSTEPS config"
	    ;;
	-b|--build)
	    NSTEPS="$NSTEPS build"
	    ;;
	--build-target)
            BUILD_TARGET=$2; shift
	    ;;
	-d|--deps)
	    DEPS=yes
	    ;;
	-i|--install)
	    NSTEPS="$NSTEPS install"
            DOINSTALL=yes
	    ;;
	-l|--no-log)
	    DLOG=no
	    ;;
	--tests)
	    NSTEPS="$NSTEPS setup config build install tests"
            DOTEST=true
	    ;;
	--tests-only)
	    NSTEPS="$NSTEPS tests"
            DOTEST=true
	    ;;
	-v|--verbose)
	    DLOG=yes
	    ;;
	-p|--purge)
	    PURGE=yes
	    ;;
	-n|--no-patch)
	    PATCH=no
	    ;;
	--prefix)
            DEFAULT_PREFIX=no
	    PREFIX=$2; shift
	    ;;
	-P|--purge-only)
	    PURGE=only
	    ;;
        -j|--jobs)
            JOBS=$2; shift
            ;;
        --plan)
            PLAN=$2; shift
            ;;
	(--)
	    ;;
	(*)
	    MODULES="$MODULES $1"
	    ;;
	(-*)
	    echo "$0: error - unrecognized option $1" 1>&2; exit 1
	    ;;
    esac
    shift
done

#  Nothing to build

[ "$MODULES" = "" ] && usage

#  Load user's settings if any

[ -f $HOME/.config/scbi/.scbi${ENV_NAME} ] &&
    source $HOME/.config/scbi/.scbi${ENV_NAME}

#  Load module definitions

[ ! -d "$DEFS" ] && DEFS=$HOME/.config/scbi

[ ! -d "$DEFS" ] && echo $0: cannot find module definition files && exit 1

#  If we have explicitly specified some steps, use them

if [ "$NSTEPS" != "" ]; then
    STEPS=$NSTEPS
fi

#  Then load any global settings, not overriding user's ones

for setup in $DEFS/[0-9]*; do
    source $setup
done

#  Load build plan if any

[ ! -z $PLAN ] && load-module-plan $PLAN

#  Prepare log dir

mkdir -p $LOGS

#  Run script for all modules

for module in $MODULES; do
    handle-module $module
done
