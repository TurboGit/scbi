#!/bin/bash
#
#  SCBI - (C) Pascal Obry - 2007-2019
#
#  SCBI stands for Setup Config Build Install
#
#  The goal is to automate the build procedures from sources. The main
#  features are:
#
#     - Allow recursive build of dependencies
#     - Building from a VCS (currently supported Git and SVN)
#     - Supports build variants
#     - Supports for cross compilation
#     - Building a specific branch or tag (Git only)
#     - Building from a tarball
#     - Building from a user's checkout for easy debug
#     - Support for build plan (modules with specific variant and/or version)
#     - All setup, source copy and installation is transparent, users just need
#       to fill functions to configure, build and install (generally just
#       calling configure autotool or cmake and make)
#
#  SCBI is a set of main scripts, the builds driver and a module for
#  each tool to handle.
#
#  The simplest usage is:
#
#     $ scbi darktable
#
#  To build an application called darktable. An application can be given a
#  variant build (whatever it means, like a debug build):
#
#     $ scbi darktable/debug
#
#  And eventually a branch (in the repository) or a version for the tarball.
#
#     $ scbi darktable/debug:release-2.4.x
#     $ scbi darktable/debug#2.6.0
#
#  To differenciate a tar version from a branch, the version string
#  starts with '#'.
#
#  The darktable module provides a set of function for each build
#  process step. Like building or configuring and also to retrieve the
#  VCS reference from which to get the sources.
#
#  For all modules the following function can be implemented and are called
#  in this specific order:
#
#    <module>-vcs       parameter: NONE, return: array
#                       describe the VCS to get the sources
#                         1st item: protocole (git, svn)
#                         2nd item: URL
#
#    <module>-tar       parameter: $VERSION, return: array
#                       describe a way to get the sources as tarball
#                         1st item: proxy name (proxy-$name)
#                         2nd item: protocole (scp, none)
#                         3rd item: URL (none)
#                         4st item: archive name (with $VERSION)
#
#    <module>-version   parameter: $PREFIX $TARGET, return: <installed version>
#                       returns the current version of the installed tool
#                       It can returns $VERSION_OK or $VERSION_ERROR if it
#                       is not possible to get the real version.
#
#    <module>-depends   parameter: NONE, return: array
#                       list all modules required. these are either
#                       source module handled by this script or a distrib
#                       package. A dependent module can be given a variant
#                       and/or version.
#
#    <module>-env       parameter: $PREFIX $TARGET, return NONE
#                       set environment to use this module as a dependency
#
#    <module>-build-env parameter: $PREFIX $TARGET, return NONE
#                       set environment to use when calling the routines
#                       (setup, config, build, install, tests).
#
#    <module>-setup     parameter: $PREFIX $TARGET, return NONE
#                       to setup build structure (optional)
#                       also: pre-setup / post-setup
#
#    <module>-config    parameter: $PREFIX $TARGET, return NONE
#                       to configure, ./configure or other steps
#                       also: pre-config / post-config
#
#    <module>-build     parameter: $PREFIX $TARGET, return NONE
#                       to build, make
#                       also: pre-build / post-build
#
#    <module>-install   parameter: $PREFIX $TARGET, return NONE
#                       to install (in $PREFIX)
#                       also: pre-install / post-install
#
#    <module>-wrapup    parameter: $PREFIX $TARGET, return NONE
#                       to wrapup build structure (optional)
#                       also: pre-wrapup / post-wrapup
#
#    <module>-prefix    parameter: $PREFIX $TARGET, return string
#                       the directory to install, default $BDIR/install
#
#    <module>-tests     parameter: $PREFIX $TARGET, return NONE
#                       to pass automatic tests
#
#  Note that all steps above are optional. And empty module will just do
#  nothing. For setup, config, build, install it may exists version pre/post
#  which may be used for complex module handling. The order is the following:
#
#     1. module-pre-<step>      - the generic pre step handled internally
#     2. <module>-pre-<step>    - done before step
#     3. <module>-<step>        - default step is done before generic one
#     4. module-<step>          - the generic step handled internally
#     5. <module>-post-<step>   - done after step
#     6. module-post-<step>     - the generic post step handled internally
#
#  The following steps (2, 4 and 5 above) can have variants and/or cross
#  hooks:
#
#     <module>-<variant>[-cross]-depends
#     <module>-<variant>[-cross]-env
#     <module>-<variant>[-cross]-setup
#     <module>-<variant>[-cross]-config
#     <module>-<variant>[-cross]-build
#     <module>-<variant>[-cross]-install
#     <module>-<variant>[-cross]-prefix
#
#  The steps routines (for 2, 4 and 5) are checked in the following order and
#  the first found is called:
#
#     <module>-<variant>-cross-<step>
#     <module>-cross-<step>
#     <module>-<variant>-<step>
#     <module>-<step>
#
#  It is possible to build from a tarball, the tar must be placed into the
#  TARBALL directory.
#
#  Patches
#  -------
#
#  After the sources are setup, it is possible to apply some local patches.
#  the patches must be placed into the PATCHES directory and named:
#
#     <module>-<numeric-id>-<some-name>.patch
#
#  patches are applied using <numeric-id> ordering.
#
#  The final step is to install into the final location, the copy is done
#  by default.
#
#  Build Plan
#  ----------
#
#  The build plan is a file listing all or parts of the modules to be
#  compiled with a given variant and/or version. This makes it
#  possible to have a specific build with precise versions for all
#  dependencies.
#
#  Super Module
#  ------------
#
#  Finally a module can be defined as a super-module. That is, it
#  lists the set of modules to build. In this case, the module just
#  define the function:
#
#     <module>-modules
#
#  This function is a single echo with the name of all modules to
#  handle. This makes it possible to build multiple projects/modules
#  not directly related. It is in fact equivalent to calling scbi with
#  all the modules listed as arguments.
#
#  A super module can have the following optional function definitions:
#
#     <module>-setup    parameter: $PREFIX $TARGET, return NONE
#                       to setup build structure (optional)
#                       PREFIX is the global install directory
#
#     <module>-wrapup   parameter: $PREFIX $TARGET, return NONE
#                       to setup build structure (optional)
#                       PREFIX is the global install directory
#
#     <module>-plan     parameter: $PREFIX $TARGET, return string
#                       the name of the build plan to use
#                       PREFIX is the global install directory
#
#  Variables:
#  ----------
#
#  SCBI_ROOT  : default root directory to use
#  BDIR       : the modules build root directory ($SCBI_ROOT/builds)
#  GIT_REPO   : directory with local Git repositories
#               ($SCBI_ROOT/repositories/git)
#  SVN_REPO   : directory with local Svn repositories
#               ($SCBI_ROOT/repositories/svn)
#  TARBALL    : directory where downloaded tarball are stores ($BDIR/.tar)
#  PREFIX     : directory where module are to be installed ($BDIR/install)
#  HOST       : current host (gcc -dumpmachine)
#  TARGET     : current target ($HOST)
#  DEFS       : where module scripts are to be found
#               ($PWD/.scripts.d $HOME/.config/scbi)
#
#  Structure:
#  ----------
#
#  $BDIR
#    |
#    |_ .vcs
#    |    |_ <module>             # module checkout, all sources
#    |
#    |_ .patches
#    |
#    |_ .tar
#    |    |_ <module>-<version>-src.tar.gz
#    |
#    |_ <module>
#         |_ build                # symlink to current/latest target build dir
#         |_ build-id-<variant>   # build id to check for changes
#         |_ src                  # symlink to sources (vcs or tarball)
#         |_ tar                  # link to extracted tarball
#         |_ tarsrc               # extract of tarball
#         |_ source-id            # version of the source (tar or vcs)
#         |_ install-id           # version of the installed module
#         |_ vcs                  # sources
#         |_ <target>-<variant>
#                |
#                |_ build         # build directory
#                |_ build-id      # sha1 to identify the build
#                |_ install       # installation directory
#                |_ manifest      # list of all files in install above
#                |_ src           # rsync of ../src
#
#  vcs : is either a copy of .vcs/<module> or a symlib to user's local checkout
#  src : is either a link to [vcs] or [tarsrc]

VERSION=2.0

CDPATH=

#  Environment
HOST=$(gcc -dumpmachine | sed -e 's/-pc//;s/-unknown//')
TARGET=$HOST
TARGET_SPECIFIED=no
ENV_NAME=

#  General script setup
DLOG=on-failure
DEFS="$PWD"/scripts.d
JOBS=0
MJOBS=4
# MJOBS is for makefiles

#  Modules to be handled and already handled
MODULES=
HANDLED=$(mktemp)

#  Actions setup
PURGE=no
NSTEPS=
PREFIX=
DEFAULT_PREFIX=yes
DOINSTALL=yes
DOUPDATE=no
DOTEST=no
DOARCHIVE=no
DOFORCE=no
DOSTAT=no
DODEPS=no
DEPS=no
ISOOT=no
PATCH=yes
STEPS="setup config build install wrapup"
BUILD_TARGET=
PLAN=
TAR_CACHE=no
DRY_RUN=no

############################## check-handled
#
# check whether a module has already been handled

function check-handled()
{
    local module=$1

    grep "^$module" $HANDLED &> /dev/null

    if [ $? = 1 ]; then
        echo $module >> $HANDLED
        return 0
    else
        return 1
    fi
}

############################## clean-up
#
# clean-up before exit

function clean-up()
{
    rm -f $HANDLED
}

############################## module-wrapper
#
# called for each module and step

function module-wrapper()
{
    local PREFIX=$1
    local module=$2
    local variant=$3
    local step=$4

    if [ $step = "build" -a "$BUILD_TARGET" != "" ]; then
        mstep=build-$BUILD_TARGET
    else
        mstep=$step
    fi

    # global logs
    log=$LOGS/$TODAY/$TARGET-$module-$variant-$mstep.log

    # local log for last module command
    mlog=$BDIR/$module/$TARGET-$variant/.log/$mstep.log
    clog=$BDIR/$module/$TARGET-$variant/.log/$mstep.cmd

    ilog $module $mstep starting

    (
        cd $BDIR/$module >> $log 2>&1

        #  Go to build directory

        if [ "$step" = "setup" -o "$step" = "wrapup" ]; then
            cd $BDIR/$module
        else
            cd $BDIR/$module/build/build
        fi

        #  Record run command

        (
            show-command $module-$mstep $PREFIX $TARGET 2&> $clog
        )

        #  Call module step

        if [[ $DLOG = yes || "$step" = "tests" ]]; then
	    $module-$mstep $PREFIX $TARGET 2>&1 | tee -a $log | tee $mlog
        else
	    $module-$mstep $PREFIX $TARGET 2>&1 | tee $mlog >> $log
        fi
        res=$?

        #  Check for errors

        if [ $res != 0 ]; then
	    if [ $DLOG = on-failure ]; then
	        tail -100 $log
	    fi
	    elog $module $mstep failed with error $res
	    return $res
        else
	    ilog $module $mstep completed
	    return 0
        fi
    )
}

############################## module-variant-wrapper
#
# called for each module, variant and step, switch to proper step to call
# depending on the existence of the variant.

function module-variant-wrapper()
{
    local PREFIX=$1
    local module=$2
    local variant=$3
    local step=$4

    if [ "$HOST" != "$TARGET" ]; then
        fn-exists $module-$variant-cross-$step

        if [[ $? = 0 ]]; then
	    module-wrapper $PREFIX $module \
                           $variant $variant-cross-$step || exit 1
            return $?
        else
            fn-exists $module-cross-$step

            if [[ $? = 0 ]]; then
	        module-wrapper $PREFIX $module \
                               $variant cross-$step || exit 1
                return $?
            fi
        fi
    fi

    fn-exists $module-$variant-$step

    if [[ $? = 0 ]]; then
	module-wrapper $PREFIX $module $variant $variant-$step || exit 1

    else
        fn-exists $module-$step

        if [[ $? = 0 ]]; then
	    module-wrapper $PREFIX $module $variant $step || exit 1
        fi
    fi
}

############################## usage

function usage()
{
    echo
    echo SCBI $VERSION
    echo
    echo $0 [options] module1 [module2 ... modulen]

    echo ""
    echo "   modulen  <name>           build from repository main branch"
    echo "   modulen  <name>/<variant> build <variant> from repository version"
    echo "   modulen  <name>:<branch>  build from repository version <branch>"
    echo "   modulen  <name>:#<ver>    build from tarbal version <ver>"
    echo "   modulen  <name>:dev       build from user's repository current branch"
    echo ""
    echo "   -h | --help          this help message"
    echo "   -e | --env=<name>    environment file ~/.scbi-<name>"
    echo "   -t | --target=<name> specify the target to build for ($TARGET)"
    echo "   -S | --no-setup      skip setup"
    echo "   -I | --no-install    skip install"
    echo "   -u | --update        do update"
    echo "   -s | --setup         do setup"
    echo "   -c | --config        do config"
    echo "   -b | --build         do build"
    echo "   -i | --install       do install"
    echo "      | --tar           check for tar before using repository"
    echo "      | --tests         run the testsuite, build if necessary"
    echo "      | --tests-only    run the testsuite"
    echo "   -d | --deps          check/build dependencies"
    echo "   -a | --archive       build binary archive"
    echo "   -v | --verbose       display full log"
    echo "   -l | --no-log        never display log"
    echo "   -f | --force         force rebuild, do not check build id"
    echo "   -p | --purge         remove builds directories before building"
    echo "   -P | --purge-only    only remove builds directories"
    echo "      | --list-depends  recursivelly list module's dependencies"
    echo "      | --dry-run       only list modules handled"
    echo "      | --plan          add a build plan for modules"
    echo "      | --stat          display some status of current setup"
    echo "   -n | --no-patch      do not apply patches"
    echo "   -j | --jobs=<n>      max compilation jobs \$JOBS"
}

############################## handle-modue-env
#
# call module ENV, checking for variant

function handle-module-env()
{
    local modref=$1
    local ENV=$2

    #  Get module information

    local module_info=( $(get-module-ref $modref) )

    local module=${module_info[0]}
    local variant=${module_info[1]}

    # Then setup the current module

    if [ -d $BDIR/$module/$TARGET-$variant/install ]; then
        cd $BDIR/$module/$TARGET-$variant/install
    elif [ -d $BDIR/$module/$TARGET-$variant ]; then
        cd $BDIR/$module/$TARGET-$variant
    else
        cd $BDIR/$module
    fi

    fn-exists $module-$variant-$ENV

    if [ $? = 0 ]; then
        $module-$variant-$ENV $BDIR/$module/build/install $TARGET
    else
        fn-exists $module-$ENV

        if [ $? = 0 ]; then
            $module-$ENV $BDIR/$module/build/install $TARGET
        fi
    fi
}

############################## handle-env
#
# recursively set the environment for the module based on the dependencies

function handle-env()
{
    local modref=$1

    #  Get module information

    local module_info=( $(get-module-ref $modref) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    [ $DODEPS == yes ] && echo $modref

    #  Then load module

    if [ -f $DEFS/$module ]; then
        source $DEFS/$module

        # Setup depends recursively if any

        fn-exists $module-$variant-depends

        if [ $? = 0 ]; then
            [ $DODEPS == yes ] &&
                for dmodule in $($module-$variant-depends); do
                    echo "   $dmodule"
                done

            for dmodule in $($module-$variant-depends); do
                handle-env $dmodule
            done
        else
            fn-exists $module-depends

            if [ $? = 0 ]; then
                [ $DODEPS == yes ] &&
                    for dmodule in $($module-depends); do
                        echo "   $dmodule"
                    done

                for dmodule in $($module-depends); do
                    handle-env $dmodule
                done
            fi
        fi

        [ $DODEPS == no ] && handle-module-env $modref env
    fi
}

############################## handle-depends
#
# check for module dependencies, handle them if build scripts found for
# them. Also check for distrib packages if exists.

function handle-depends()
{
    local modref=$1

    local module_info=( $(get-module-ref $modref) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    #  If we want latest version, just handle this module

    if [ "$kind" = "DEV" ]; then
        handle-module $1
        return
    fi

    cd $SCBI_ROOT

    #  If module not found, check for a possible distrib package

    if [ ! -f $DEFS/$module ]; then
        check-pkg $module:$ref

        if [ $? = 0 ]; then
            return 0
        else
            echo No description for module $module &&
            echo And not found in the distrib  &&
            exit 1
        fi
    fi

    #  Check if the proper version is installed

    source $DEFS/$module

    fn-exists $module-version
    if [[ $? = 0 ]]; then
        pushd $(mktemp -d) > /dev/null 2>&1

        mver=$($module-version $PREFIX $TARGET)

        [ "${PWD:0:4}" = "/tmp" ] && rm -r $(pwd)

        popd > /dev/null 2>&1
    else
        mver=$VERSION_OK
    fi

    #  Clean-up the version number (only digits and a single dot)

    mver=$(get-version-number $mver)

    cd $SCBI_ROOT

    [ "$ref" = "NONE" ] && ref=0

    [ $DOFORCE = yes ] && rm -f $BDIR/$module/build/build-id

    #  Check build id, only rebuild if mismatch

    diff -q $BDIR/$module/build-id $BDIR/$module/build/build-id > /dev/null 2>&1

    if [[ $? != 0 \
              || "$mver" = "" \
              || "$mver" = $VERSION_ERROR \
              || $ref > $mver ]];
    then
        if [ $DRY_RUN == no ]; then
            echo
            ilog $module need building $module, \
                 current version $(display-version $mver) | tee -a $log
        fi
        handle-module $modref
    else
        ilog $module $modref found
    fi
}

############################## handle-sources
#
#  get the module sources from a tar or a vcs
#

function handle-sources()
{
    local modref=$1

    #  Get module information

    local module_info=( $(get-module-ref $modref) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    #  Check if a given tar exists even if a standard branch ref has
    #  been provided. This is an optimization to used a local tar
    #  instead of a repository branch.

    if [ $kind == BRANCH -a "$TAR_CACHE" == "yes" ]; then
        check-tar-exists $module $ref
        [ $? == 0 ] && kind=VERSION
    fi

    #  If building from tarball, extract it now

    if [ $kind == VERSION ]; then
        fn-exists $module-tar

        if [[ ! $? = 0 ]]; then
            echo "error: $module-tar function not defined, cannot get tarball"
            exit 1
        fi

        #  We need to extract the tarball if the version does not match
        #  the one currently extracted.

        if [ -f source-id ]; then
            if [ "$(cat source-id)" != "tar-$ref" ]; then
                rm -fr tarsrc
            fi
        fi

        echo -n tar-$ref > source-id

        if [ $DOUPDATE = yes -o ! -d tarsrc -o ! -f tar ]; then
	    ilog $module get sources from tar

            get-tar $module $ref >> $log 2>&1

            if [[ ! $? = 0 ]]; then
                ilog $module cannot get/find tar sources
                exit 1
            fi

            #  Compute and store the version id of the sources + compiler.
            #  That is when the compiler is changed when want to rebuild
            #  the software.
            get-build-id $PREFIX $TARGET $modref tar-$ref > build-id-$variant
        fi

        #  We set the link for the source so that no module will have to
        #  do it.

        ln -s tarsrc src

    else
        # Get sources from repository

        fn-exists $module-vcs

        if [[ $? = 0 ]]; then
            vcs=( $($module-vcs) )
            VCS_NAME=${vcs[0]}
            VCS_URL=${vcs[1]}

            REPO=$(basename $VCS_URL .git)

            if [ $kind = DEV ]; then
                if [ -d $GIT_REPO/$REPO ]; then
                    ln -s $GIT_REPO/$REPO vcs

                    #  Compute and store the version id of the sources +
                    #  compiler. That is when the compiler is changed we
                    #  want to rebuild the software.

                    echo -n $ref > source-id

                    vcs-build-id $PREFIX $TARGET $modref $(pwd)/vcs \
                                 > build-id-$variant

                else
                    ilog $module cannot find local dev repository:
                    ilog $module $GIT_REPO/$REPO
                    exit 1
                fi

            else
                if [ -f source-id ]; then
                    if [ "$(cat source-id)" != "vcs-$ref" ]; then
                        # a different version is needed
                        DOUPDATE=yes
                    fi
                fi

                echo -n vcs-$ref > source-id

                if [ $DOUPDATE = yes -o ! -d ../.vcs/$REPO ]; then
	            ilog $module get sources from $VCS_NAME

                    get-vcs $VCS_NAME $VCS_URL $module $kind $ref

                    if [[ ! $? = 0 ]]; then
                        exit 1
                    fi
                else
                    ln -s ../.vcs/$REPO vcs
                fi

                #  Compute and store the version id of the sources +
                #  compiler. That is when the compiler is changed we
                #  want to rebuild the software.

                vcs-build-id $PREFIX $TARGET $modref $(pwd)/vcs \
                             > build-id-$variant
            fi

            ln -s vcs src

        else
            #  No VCS, not TAR, just rebuild the sources
            get-build-id $PREFIX $TARGET $modref "$(date)" \
                         > build-id-$variant
        fi

        #  If get-vcs is not defined then the $module-setup routine is in
        #  charge of creating/populating the src directory.
    fi
}

############################## handle-module

function handle-super-module()
{
    local supermodule=$1
    local variant=$2

    # check for plan

    fn-exists $supermodule-$variant-plan

    if [[ $? = 0 ]]; then
        PLAN=$($supermodule-$variant-plan)
        echo $PLAN > /tmp/plan
        load-module-plan $PLAN
    else
        fn-exists $supermodule-plan
        if [[ $? = 0 ]]; then
            PLAN=$($supermodule-plan)
            load-module-plan $PLAN
        fi
    fi

    # check for setup

    module-variant-wrapper $BDIR/install $supermodule $variant setup || exit 1

    fn-exists $supermodule-$variant-modules

    if [[ $? = 0 ]]; then
        FCT=$supermodule-$variant-modules
    else
        FCT=$supermodule-modules
    fi

    for module in $($FCT); do
        handle-module $module
    done

    # check for wrapup

    module-variant-wrapper $BDIR/install $supermodule $variant wrapup || exit 1
}

############################## handle-module

function handle-module()
{
    local modref=$1

    #  Get module information

    local module_info=( $(get-module-ref $modref) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    log=$LOGS/$TODAY/$TARGET-$module-$variant-report.log

    #  Check if we have already handled this module

    check-handled $module+$variant
    if [[ $? = 1 ]]; then
        if [ $DRY_RUN == no ]; then
            ilog $module skip $module, already handled
        fi
        return
    fi

    cd $SCBI_ROOT

    [ ! -f $DEFS/$module ] &&
        echo No description for module $module &&
        exit 1

    #  Then load module setup

    source $DEFS/$module

    #  Create module build directory

    mkdir -p $BDIR/$module/$TARGET-$variant/.log > $log 2>&1

    #  Check if meta-module, if so call handle-module for each one

    fn-exists $module-$variant-modules

    if [[ $? = 0 ]]; then
        (
            handle-super-module $module $variant
        )
        return
    else
        fn-exists $module-modules
        if [[ $? = 0 ]]; then
            (
                handle-super-module $module $variant
            )
            return
        fi
    fi

    # Check for depends if any, and handle them if any

    if [ $DEPS = yes ]; then
        fn-exists $module-$variant-depends

        if [[ $? = 0 ]]; then
            (
                for module in $($module-$variant-depends); do
                    handle-depends $module
                done
            )
            if [[ ! $? = 0 ]]; then
                exit 1
            fi
            [ $DRY_RUN == no ] && echo
        else
            fn-exists $module-depends

            if [[ $? = 0 ]]; then
                (
                    for module in $($module-depends); do
                        handle-depends $module
                    done
                )
                if [[ ! $? = 0 ]]; then
                    exit 1
                fi
                [ $DRY_RUN == no ] && echo
            fi
        fi
    fi

    if [ $DRY_RUN == yes ]; then
        echo $modref
        return 0
    fi

    clog $module

    #  If purge is asked, first remove current build structure

    if [ $PURGE = yes -o $PURGE = only ]; then
	ilog $module Purging $module for $TARGET/$variant
        [ -d $BDIR/$module ] &&
            module-purge $BDIR/$module $module $variant $TARGET
    fi

    #  If purge-only, stop there

    [ $PURGE = only ] && exit 0

    if [ $ref == NONE ]; then
        DISPREF=master
    else
        DISPREF=$ref
    fi

    ilog $module Building $module-$variant \($DISPREF\) | tee -a $log

    if [ $HOST == $TARGET ]; then
        ilog $module native $TARGET | tee -a $log
    else
        ilog $module cross $TARGET | tee -a $log
    fi

    ilog $module steps : $STEPS | tee -a $log

    #  Create the build root directory if needed, note that we do check here
    #  even if already created when entering this routine. This is because
    #  in case of a purge the build directory could have been removed.

    [ -d $BDIR/$module/$TARGET-$variant ] ||
        mkdir $BDIR/$module/$TARGET-$variant

    #  Set module environment if defined

    (
        #  Set cross-env if needed

        if [ "$HOST" != "$TARGET" ]; then
            target-env $BDIR/install $TARGET
        fi

        #  Setup the build environment for the current module

        handle-module-env $modref build-env

        #  And then setup recursively the environment to use dependencies

        handle-env $modref

        #  Log module enviroment

        ENVLOG=$LOGS/$TODAY/$TARGET-$module-$variant-env.log

        echo "==================== env " > $ENVLOG
        env >> $ENVLOG

        [ ! -z $(which gprls) ] &&
            (
                echo "==================== gprls " >> $ENVLOG
                gprls -v 2>&1 >> $ENVLOG
            )

        [ ! -z $(which gcc) ] &&
            (
                echo "==================== gcc " >> $ENVLOG
                gcc -v &>> $ENVLOG
            )

        #  We need to remove the link/sources to ensure proper setting by
        #  the module.

        [ -d $BDIR/$module ] && cd $BDIR/$module && rm -fr src vcs

        handle-sources $modref

        #  Check if envrionment is to be done for out-of-tree build

        fn-exists $module-out-of-tree

        [ $? = 0 ] && [ $($module-out-of-tree) = "true" ] && ISOOT=yes

        #  Call module routines

        #  If force build, remove the current build id

        [ $DOFORCE = yes ] && rm -f build/build-id

        #  Check build id, only rebuild if mismatch

        diff -q build-id-$variant \
             $BDIR/$module/$TARGET-$variant/build-id > /dev/null 2>&1

        if [ $? = 0 ]; then
	    ilog $module no build needed, versions match

            STEPS=""

            # if install variant changed, do install

            if [ $(cat install-id) != $variant ]; then
                # make sure the current build softlink is pointing to
                # the variant. this is needed as the setup won't be
                # done.

                cd $BDIR/$module
                [ -h build ] && rm -f build
                ln -s $TARGET-$variant build
            fi

            # if testing is expected, at least do that

            if [ $DOTEST = true ]; then
                STEPS="$STEPS tests"
            fi
        fi

        for step in $STEPS; do
            ########## PRE module

            #  Apply any generic step (module-setup, module-purge)

            fn-exists module-pre-$step

            if [[ $? = 0 ]]; then
                cd $BDIR/$module

                if [ $DLOG = yes ]; then
                    module-pre-$step $BDIR/$module/build/install $module \
                                     $variant $TARGET $ISOOT | tee $log 2>&1
                else
                    module-pre-$step $BDIR/$module/build/install $module \
                                     $variant $TARGET $ISOOT >> $log 2>&1
                fi
            fi
            res=$?

            if [ $res != 0 ]; then
	        if [ $DLOG = on-failure ]; then
	            tail -100 $log
	        fi
	        elog $module generic module pre-$step failed with error $res
	        return $res
            fi

            #  Apply module specific step if any

            module-variant-wrapper $BDIR/$module/build/install $module \
                                   $variant pre-$step || exit 1

            ########## module

            module-variant-wrapper $BDIR/$module/build/install $module \
                                   $variant $step || exit 1

            #  Apply any generic step (module-setup, module-purge)

            fn-exists module-$step

            if [[ $? = 0 ]]; then
                cd $BDIR/$module

                if [ $DLOG = yes ]; then
                    module-$step $BDIR/$module/build/install $module \
                                 $variant $TARGET $ISOOT | tee $log 2>&1
                else
                    module-$step $BDIR/$module/build/install $module \
                                 $variant $TARGET $ISOOT >> $log 2>&1
                fi
            fi
            res=$?

            if [ $res != 0 ]; then
	        if [ $DLOG = on-failure ]; then
	            tail -100 $log
	        fi
	        elog $module generic module $step failed with error $res
	        return $res
            fi

            ########## POST module

            module-variant-wrapper $BDIR/$module/build/install $module \
                                   $variant post-$step || exit 1

            fn-exists module-post-$step

            if [[ $? = 0 ]]; then
                cd $BDIR/$module

                if [ $DLOG = yes ]; then
                    module-post-$step $BDIR/$module/build/install $module \
                                      $variant $TARGET $ISOOT | tee $log 2>&1
                else
                    module-post-$step $BDIR/$module/build/install $module \
                                      $variant $TARGET $ISOOT >> $log 2>&1
                fi
            fi
            res=$?

            if [ $res != 0 ]; then
	        if [ $DLOG = on-failure ]; then
	            tail -100 $log
	        fi
	        elog $module generic module post-$step failed with error $res
	        return $res
            fi

            [ $step == install ] && echo -n $variant > install-id || true
        done
    ) || exit 1

    #  Create binary archive if needed

    if [ $DOARCHIVE = yes ]; then
        cd $BDIR/$module/build >> $log 2>&1
        tar cf $module-bin.tar --directory=install .
        bzip2 -9 $module-bin.tar
    fi

    fn-exists $module-$variant-prefix

    if [ $? = 0 -a "$DEFAULT_PREFIX" = "yes" ]; then
        IDIR=$($module-$variant-prefix $BDIR/$module/build/install $TARGET)
    else
        fn-exists $module-prefix
        if [ $? = 0 -a "$DEFAULT_PREFIX" = "yes" ]; then
            IDIR=$($module-prefix $BDIR/$module/build/install $TARGET)
        else
            IDIR=$PREFIX
        fi
    fi

    if [ "$DOINSTALL" = "yes" -a -d $BDIR/$module/build/install ]; then
	ilog $module copy install into ..${IDIR/$BDIR/}

        #  Finaly copy to given prefix
        SUDO=""

        if [ ! -d $IDIR ]; then
	    mkdir -p $IDIR &> /dev/null
	    [ ! $? = 0 ] && SUDO=sudo
	fi

        if [ ! -w $IDIR ]; then
            SUDO=sudo
        fi

        $SUDO mkdir -p $IDIR/
        $SUDO rsync -a $BDIR/$module/$TARGET-$variant/install/. $IDIR/. > $log 2>&1
    fi || elog $module fail to copy to $IDIR

    ilog $module End building $module-$variant

    echo
}

############################## body

set -- $(getopt -u -o t:adefSIuscbilnpPvh \
    -l target:,no-setup,no-install,update,setup,config,build,build-target:,install,no-log,purge,purge-only,verbose,prefix:,tests,tests-only,help,deps,archive,force,env:,no-patch:,plan:,stat,tar,list-depends,dry-run -- "$@")

while [ $# -gt 0 ]; do
    case $1 in
	-h|--help)
            break
	    ;;
	-f|--force)
            DOFORCE=yes
	    ;;
	-a|--archive)
            DOARCHIVE=yes
	    ;;
	-e|--env)
            ENV_NAME="-$2"
            if [ ! -f $HOME/.config/scbi/.env${ENV_NAME} ]; then
                echo "error: scbi environment $2 not found"
                exit 1
            fi
            shift
	    ;;
	--tar)
	    TAR_CACHE=yes
	    ;;
	-t|--target)
	    TARGET=$2; shift
            TARGET_SPECIFIED=yes
	    ;;
	-S|--no-setup)
	    STEPS=${STEPS/setup/}
	    ;;
	-W|--no-wrapup)
	    STEPS=${STEPS/wrapup/}
	    ;;
	-I|--no-install)
            DOINSTALL=no
	    ;;
	-u|--update)
            DOUPDATE=yes
	    ;;
	-s|--setup)
	    NSTEPS="$NSTEPS setup"
	    ;;
	-c|--config)
	    NSTEPS="$NSTEPS config"
	    ;;
	-b|--build)
	    NSTEPS="$NSTEPS build"
	    ;;
	--build-target)
            BUILD_TARGET=$2; shift
	    ;;
	-d|--deps)
	    DEPS=yes
	    ;;
	-i|--install)
	    NSTEPS="$NSTEPS install"
            DOINSTALL=yes
	    ;;
	-l|--no-log)
	    DLOG=no
	    ;;
	--tests)
	    NSTEPS="$NSTEPS setup config build install tests wrapup"
            DOTEST=true
	    ;;
	--tests-only)
	    NSTEPS="$NSTEPS tests"
            DOTEST=true
	    ;;
	-v|--verbose)
	    DLOG=yes
	    ;;
	-p|--purge)
	    PURGE=yes
	    ;;
	-n|--no-patch)
	    PATCH=no
	    ;;
	--prefix)
            DEFAULT_PREFIX=no
	    PREFIX=$2; shift
	    ;;
	-P|--purge-only)
	    PURGE=only
	    ;;
        -j|--jobs)
            JOBS=$2; shift
            ;;
        --plan)
            PLAN=$2; shift
            ;;
        --stat)
            DOSTAT=yes;
            ;;
        --list-depends)
            DODEPS=yes;
            ;;
        --dry-run)
            DRY_RUN=yes;
            ;;
	(--)
	    ;;
	(*)
	    MODULES="$MODULES $1"
	    ;;
	(-*)
	    echo "$0: error - unrecognized option $1" 1>&2; exit 1
	    ;;
    esac
    shift
done

trap clean-up EXIT

#  Load user's settings if any

[ -f $HOME/.config/scbi/.env${ENV_NAME} ] &&
    source $HOME/.config/scbi/.env${ENV_NAME}

#  Load module definitions

[ ! -d "$DEFS" -o -z "$(ls $DEFS/[0-9]* 2> /dev/null)" ] &&
    DEFS=$HOME/.config/scbi

[ ! -d "$DEFS" ] && echo $0: cannot find module definition files && exit 1

#  If we have explicitly specified some steps, use them

if [ "$NSTEPS" != "" ]; then
    STEPS=$NSTEPS
fi

#  Then load any global settings, not overriding user's ones

for setup in $DEFS/[0-9]*; do
    source $setup
done

#  Load build plan if any

[ ! -z $PLAN ] && load-module-plan $PLAN

#  Nothing to build, display usage

[ "$MODULES" = "" -a $DOSTAT == no ] && usage

[ $DOSTAT == yes ] && display-stat

[ "$MODULES" = "" -o $DOSTAT == yes ] && display-modules && display-plans

[ $DOSTAT == yes ] && display-log-stat

if [ $DODEPS == yes ]; then
    for module in $MODULES; do
        handle-env $module
    done
    exit 0
fi

#  Prepare log dir and tarball dir

mkdir -p $LOGS/$TODAY
mkdir -p $TARBALL

if [ $DRY_RUN == yes ]; then
    PURGE=no
    DOINSTALL=no
    DOARCHIVE=no
    DOUPDATE=no
    DOFORCE=no
    STEPS=""
fi

#  Run script for all modules

for module in $MODULES; do
    handle-module $module
done
