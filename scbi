#!/bin/bash
#
#  SCBI - (C) Pascal Obry - 2007-2021
#

shopt -s extglob

SCBI_VERSION=@VERSION@
SCBI_BINARY=$(realpath $0)

############################## check-tool

function check-tool()
{
    if [[ -z "$(command -v $1 2> /dev/null)" ]]; then
        return 1
    fi
    return 0
}

############################## check-tools

function check-tools()
{
    local res=0

    while [[ "$1" != "" ]]; do
        check-tool $1
        res=$(expr $res + $?)
        shift
    done
    return $res
}

############################## check-tools-abort

function check-tools-abort()
{
    local TOOLS="$1"

    check-tools $TOOLS

    [[ $? != 0 ]] &&
        echo Required tools ${TOOLS} missing, please install &&
        exit 1
}

CDPATH=

#  Environment

#  Setup host & Check for tools used by scbi itself

SCBI_IS_WINDOWS=no
SCBI_OS_MODULE=

check-tools-abort rsync sed diff

if [[ $(uname -a) =~ Cygwin ]]; then
    SCBI_IS_WINDOWS=yes
    SCBI_HOST=x86_64-cygwin
    SCBI_OS_MODULE=windows
elif [[ $(uname -a) =~ Msys ]]; then
    SCBI_IS_WINDOWS=yes
    SCBI_HOST=x86_64-mingw64
    SCBI_OS_MODULE=windows
else
    SCBI_HOST=$(gcc -dumpmachine | sed -e 's/-pc//;s/-unknown//')
    check-tools-abort gcc
fi

SCBI_TARGET=$SCBI_HOST
SCBI_TARGET_SPECIFIED=no
ENV_NAME=${SCBI_DEFAULT_ENV:+-$SCBI_DEFAULT_ENV}

#  General script setup
SCBI_DLOG=on-failure
SCBI_DEFS="$PWD"/scripts.d
SCBI_JOBS=$(grep -c ^processor /proc/cpuinfo 2>/dev/null || sysctl -n hw.ncpu)
SCBI_HALF_JOBS=$(( $SCBI_JOBS / 2 ))

#  Modules to be handled and already handled
MODULES=
HANDLED=$(mktemp)
LAST_MODULE=

#  Actions setup
DO_PURGE=no
NSTEPS=
SCBI_PREFIX=
SCBI_DEFAULT_PREFIX=yes
DO_INSTALL=yes
DO_UPDATE=no
DO_TEST=no
DO_ARCHIVE=no
DO_FORCE=no
DO_MOD_VER=no
DO_STAT=no
DO_DEPS=no
DO_EXT=no
DO_CLEAN_INSTALL=no
DO_LIST_VER=yes
DO_PLAN=no
DO_VERBOSE=no
DO_STORE=no
DEPS=no
ISOOT=yes
DO_PATCH=yes
STEPS="setup config build install wrapup"
BUILD_SCBI_TARGET=
SCBI_PLAN=
SCBI_PLAN_CL=
TAR_CACHE=yes
DRY_RUN=no
SAFE_MODE=no
DO_STANDALONE=no
SCBI_FILTER=all
CMDLINE_BUILD_DIR=
DO_HELP=no
DO_VERSION=no
DO_SHELL=no
DO_RUN=no
DO_RUN_CMD=

############################## check-handled
#
# check whether a module has already been handled

function check-handled()
{
    local module=$1

    grep "^$module" $HANDLED &> /dev/null

    if [[ $? = 1 ]]; then
        echo $module >> $HANDLED
        return 0
    else
        return 1
    fi
}

############################## clean-up
#
# clean-up before exit

function clean-up()
{
    rm -f $HANDLED
    rm -f $SCBI_LINE_SEP
}

############################## load-module-env
#
# load an environment description, this cannot be in 5_tools as an
# envrionment script must be loaded before any other.

function load-module-env()
{
    local ENV=$PWD/.scbi-env$1

    # if not found in current directory look in definitions install dir

    if [[ ! -f $ENV ]]; then
        # look for it in parent directory too
        ENV=$PWD/../.scbi-env$1

        if [[ ! -f $ENV ]]; then
            # look for it in $HOME directory too
            ENV=$HOME/.scbi-env$1

            if [[ ! -f $ENV ]]; then
                ENV=$SCBI_DEFS/.env$1
            fi
        fi
    fi

    if [[ -f $ENV ]]; then
        source $ENV
    elif [[ ! -z $1 ]]; then
        echo build environment .env$1 not found
        exit 1
    fi
}

############################## module-wrapper
#
# called for each module and step

function module-wrapper()
{
    local PREFIX=$1
    local module=$2
    local variant=$3
    local step=$4
    local pvariant=""
    local dvariant=""

    #  set variant parameter if different than default

    if [[ "$variant" != "default" ]]; then
        pvariant=$variant
    fi

    #  set variant display if not part of step and not default

    if [[ ${step/$variant/} == $step && "$variant" != "default" ]]; then
        dvariant=" [${variant//./ }]"
    fi

    if [[ $step = "build" && "$BUILD_SCBI_TARGET" != "" ]]; then
        mstep=build-$BUILD_SCBI_TARGET
    else
        mstep=$step
    fi

    #  global logs
    log=$SCBI_LOGS/$TODAY/$SCBI_TARGET-$module-$variant-$mstep.log

    #  local log for last module command
    mlog=$SCBI_BDIR/$module/$SCBI_TARGET-$variant/.log/$mstep.log
    clog=$SCBI_BDIR/$module/$SCBI_TARGET-$variant/.log/$mstep.cmd

    ilog $module $mstep$dvariant starting

    (
        cd $SCBI_BDIR/$module >> $log 2>&1

        #  Go to build directory

        if [[ "$step" =~ (pre-|post-)*(setup|wrapup)$ ]]; then
            cd $SCBI_BDIR/$module
        elif [[ -d $SCBI_BDIR/$module/$SCBI_TARGET-$variant/build ]]; then
            cd $SCBI_BDIR/$module/$SCBI_TARGET-$variant/build
        else
            #  a native module has no sources for example
            cd $SCBI_BDIR/$module
        fi

        #  Record run command

        (
            show-command $module $module-$mstep \
                         $PREFIX $SCBI_TARGET $variant 2&> $clog
        )

        #  Call module step

        local res=0

        if [[ $SCBI_DLOG = yes ]] || [[ "$step" = "tests" ]]; then
            $module-$mstep $PREFIX $SCBI_TARGET $pvariant 2>&1 \
                | tee -a $log | tee $mlog
            #  We want the status of the first command and not the tee ones
            res=${PIPESTATUS[0]}
        else
            $module-$mstep $PREFIX $SCBI_TARGET $pvariant 2>&1 \
                | tee $mlog >> $log
            #  We want the status of the first command and not the tee ones
            res=${PIPESTATUS[0]}
        fi

        #  Check for errors

        if [[ $res -ne 0 ]]; then
            if [[ $SCBI_DLOG = on-failure ]] && [[ "$step" != "tests" ]]; then
                tail -100 $mlog
            fi
            elog $module $mstep failed with error $res
            return $res
        else
            ilog $module $mstep$dvariant completed
            return 0
        fi
    )
    return $?
}

############################## module-variant-wrapper
#
# called for each module, variant and step, switch to proper step to call
# depending on the existence of the variant.

function module-variant-wrapper()
{
    local PREFIX=$1
    local module=$2
    local variant=$3
    local step=$4

    local FCT=$(get-hook $module $variant $step)

    if [[ ! -z $FCT ]]; then
        module-wrapper $PREFIX $module \
                       $variant ${FCT#"${module}-"} || exit 1
        return $?
    fi
}

############################## usage

function usage()
{
    echo
    echo SCBI $SCBI_VERSION
    echo
    echo $0 [options] module1 [module2 ... modulen]

    echo ""
    echo "   modulen  <name>           build from repository main branch"
    echo "   modulen  <name>/<variant> build <variant> from repository version"
    echo "   modulen  <name>:<branch>  build from repository version <branch>"
    echo "   modulen  <name>:#<ver>    build from tarbal version <ver>"
    echo "   modulen  <name>:dev       build from user's repository current branch"
    echo ""
    echo "   -h | --help             this help message"
    echo "   -t | --prefix=<dir>     the global install directory"
    echo "      | --build-dir=<dir>  the root build directory."
    echo "   -e | --env=<name>       environment file ~/.scbi-<name>"
    echo "      | --plan=<name>      a build plan for modules"
    echo "      | --enable-<name>    enable feature name"
    echo "   -t | --target=<name>    the target to build for ($SCBI_TARGET)"
    echo "      | --plugins=<dir>    specify the modules/plugins directory"
    echo "      | --store KEY [VAL]  set or retrieved private store data"
    echo "   -j | --jobs=<n>         max compilation jobs \$SCBI_JOBS"
    echo "   -v | --verbose          display full log"
    echo "   -S | --no-setup         skip setup"
    echo "   -I | --no-install       skip install"
    echo "   -u | --update           do update"
    echo "   -s | --setup            do setup"
    echo "   -c | --config           do config"
    echo "   -b | --build            do build"
    echo "   -i | --install          do install"
    echo "      | --clean-install    clean installation directory"
    echo "      | --tar              check for tar only if explicitly specified"
    echo "      | --tests            run the testsuite, build if necessary"
    echo "      | --tests-only       run the testsuite"
    echo "   -d | --deps             check/build dependencies"
    echo "   -a | --archive          build binary archive"
    echo "      | --standalone       create a standalone source archive"
    echo "   -l | --log:n            log display control yes|no|on-failure"
    echo "   -f | --force            force rebuild, do not check build id"
    echo "   -p | --purge            remove builds directories before building"
    echo "   -P | --purge-only       only remove builds directories"
    echo "      | --shell:n          start a shell with module's environment"
    echo "      | --run:\"cmd arg\"    run command in module's environment"
    echo "      | --list-depends:n   list module's dependencies (direct, full)"
    echo "      | --list-externals:n list module's external dependencies"
    echo "      | --list-no-version  do not display modules/externals version"
    echo "      | --list-filter:n    filter depends/external for dev or runtime"
    echo "      | --list-plan        list current current plan"
    echo "      | --module-version   display version of specific module"
    echo "      | --dry-run          only list modules handled"
    echo "      | --stat             display some status of current setup"
    echo "   -n | --no-patch         do not apply patches"
}

############################## handle-modue-env
#
# call module ENV, checking for variant

SCBI_ENV_MODULE=

function handle-module-env()
{
    local FORMODULE=$1
    local MODREF=$2
    local ENV=$3

    #  Get module information

    local module_info=( $(get-module-ref $MODREF $FORMODULE) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local ref=${module_info[3]}

    [[ $ref = "skip" ]] && return 0

    #  For a build environment we call the hook from the build directory
    #  otherwise we call for the install directory.

    if [[ $ENV = "build-env" ]]; then
        ENV_DIR=build
    else
        ENV_DIR=install
    fi

    #  Then setup the current module

    if [[ -d $SCBI_BDIR/$module/$SCBI_TARGET-$variant/$ENV_DIR ]]; then
        cd $SCBI_BDIR/$module/$SCBI_TARGET-$variant/$ENV_DIR
    elif [[ -d $SCBI_BDIR/$module/$SCBI_TARGET-$variant ]]; then
        cd $SCBI_BDIR/$module/$SCBI_TARGET-$variant
    elif [[ -d $SCBI_BDIR/$module ]]; then
        cd $SCBI_BDIR/$module
    else
        cd $SCBI_BDIR
    fi

    if [[ ! -z $SCBI_ENV_MODULE ]]; then
        echo >> $SCBI_ENV_MODULE
        echo "# $module" >> $SCBI_ENV_MODULE
    fi

    _internal_call-variant-hooks \
        $module $ENV \
        $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install $SCBI_TARGET $variant
}

############################## register-depends-callback
# used for --list-depends and --list-external

declare -a MODULE_LIST

function register-depends-callback()
{
    local FORMODULE=$1
    local MODREF=$2
    local LEVEL=$3
    local IS_BUILD_DEPENDS=$4
    local IS_EXT=$5
    local IS_META=$6

    local SELEXT=false
    local SELBUILD=false
    local SELECTED=false

    if [[ $DO_EXT != no ]] || [[ $IS_EXT == false ]]; then
        SELEXT=true
    fi

    if [[ $SCBI_FILTER == all ]] || [[ $SCBI_FILTER == dev ]]; then
        SELBUILD=true
    fi

    if [[ $SELBUILD == $IS_BUILD_DEPENDS ]] || [[ $SCBI_FILTER == all ]]; then
        SELECTED=true
    fi

    if [[ $DO_DEPS == yes-direct ]] && [[ $LEVEL -ne 1 ]]; then
        SELECTED=false
    fi

    if [[ $DO_EXT == yes-only ]] && [[ $IS_EXT == false ]]; then
        SELECTED=false
    fi

    if [[ $SELEXT == true ]] && [[ $SELECTED == true ]]; then
        if [[ "$SCBI_FILTER" == "run" ]] &&
               [[ "${MODREF: -4}" == "-dev" ]];
        then
            MOD=$(get-lib-for-dev $MODREF)
        else
            MOD=$MODREF
        fi

        #  Do we need the version of the module

        if [[ $DO_LIST_VER == yes ]]; then
            local module_info=( $(get-module-ref $MODREF $FORMODULE) )

            local module=${module_info[0]}
            local ref=${module_info[3]}

            if [[ $ref == NONE ]]; then
                if [[ $IS_EXT == true ]]; then
                    local V=$(get-pkg-version $module)
                    if [[ -z $V ]]; then
                        MOD="$module"
                    else
                        MOD="$module:$V"
                    fi
                else
                    MOD="$module"
                fi
            else
                MOD="$module:$ref"
            fi
        fi

        MODULE_LIST+=($MOD)
    fi
}

############################## handle-env
#
# recursively set the environment for the module based on the dependencies

function handle-env-callback()
{
    local FORMODULE=$1
    local MODREF=$2
    local LEVEL=$3
    local IS_BUILD_DEPENDS=$4
    local IS_EXT=$5
    local IS_META=$6

    handle-module-env $FORMODULE $MODREF env
}

function handle-env()
{
    local FORMODULE=$1
    local MODREF=$2

    #  Get module information

    local module_info=( $(get-module-ref $MODREF $FORMODULE) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    if [[ -d $SCBI_BDIR/$module/$SCBI_TARGET-$variant ]]; then
        SCBI_ENV_MODULE=$SCBI_BDIR/$module/$SCBI_TARGET-$variant/.log/env.cmd
        rm -f $SCBI_ENV_MODULE

        #  Exports all environment variables starting with SCBI_

        env | grep "^SCBI_" | while read DEF; do
            echo "export $DEF" >> $SCBI_ENV_MODULE
        done
    fi

    for-all-modules handle-env-callback $MODREF

    SCBI_ENV_MODULE=
}

############################## handle-depends
#
# check for module dependencies, handle them if build scripts found for
# them. Also check for distrib packages if exists.

function handle-depends()
{
    local FORMODULE=$1
    local MODREF=$2

    local module_info=( $(get-module-ref $MODREF $FORMODULE) )

    if [[ ! -z ${module_info[4]} ]]; then
        module_info[1]=""
        module_info[2]=""
        module_info[3]=""
        elog ${module_info[@]}
        exit 1
    fi

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    #  If we want latest version, just handle this module

    if [[ "$kind" = "DEV" ]]; then
        handle-module $FORMODULE $MODREF
        return
    fi

    cd $SCBI_ROOT

    local formodule_info=( $(get-module-ref $FORMODULE) )
    fmodule=${formodule_info[0]}
    fvariant=${formodule_info[1]}

    #  If module not found, check for a possible distrib package

    if [[ ! -f $SCBI_DEFS/$module ]]; then
        MES=$(check-pkg $module:$ref)

        if [[ $? = 0 ]]; then
            return 0
        else
            local MNAME=$fmodule
            [[ $fvariant != "default" ]] && MNAME="$MNAME/$fvariant"

            echo "dependencies error building $MNAME"

            for dmodule in $(get-all-depends $fmodule $fvariant build-depends); do
                [[ ! -f $SCBI_DEFS/$dmodule ]] && check-pkg $dmodule
            done

            for dmodule in $(get-all-depends $fmodule $fvariant depends); do
                [[ ! -f $SCBI_DEFS/$dmodule ]] && check-pkg $dmodule
            done

            exit 1
        fi
    fi

    #  Check if the proper version is installed

    load-module $MODREF

    fn-exists $module-version
    if [[ $? = 0 ]]; then
        pushd $(mktemp -d) > /dev/null 2>&1

        mver=$($module-version $SCBI_PREFIX $SCBI_TARGET)

        [[ "${PWD:0:4}" = "/tmp" ]] && rm -r $(pwd)

        popd > /dev/null 2>&1
    else
        mver=$VERSION_OK
    fi

    #  Clean-up the version number (only digits and a single dot)

    mver=$(get-version-number $mver)

    cd $SCBI_ROOT

    case "$kind" in
        NONE)
            SID="vcs-$ref"
            ;;
        TAR)
            SID="tar-$ref"
            ;;
    esac

    if [[ -f source-id ]]; then
        if [[ "$(cat source-id)" == $SID ]]; then
            rsid=0;
        else
            rsid=1;
        fi
    else
        rsid=1;
    fi

    [[ "${ref^^}" = "NONE" ]] && ref=0

    [[ $DO_FORCE = yes ]] &&
        rm -f $SCBI_BDIR/$module/$SCBI_TARGET-$variant/build-id

    #  Check build id, only rebuild if mismatch

    diff -q $SCBI_BDIR/$module/build-id-$variant \
            $SCBI_BDIR/$module/$SCBI_TARGET-$variant/build-id > /dev/null 2>&1
    rbid=$?

    check-versions $ref ">" $mver
    cver=$?

    if [[ $rbid -gt 0 \
              || $rsid -gt 0 \
              || "$mver" = "" \
              || "$mver" = $VERSION_ERROR \
              || $cver == 1 ]];
    then
        if [[ $DRY_RUN == no ]] && [[ $DO_VERBOSE = yes ]]; then
            ilog $module need building $module, \
                 current version $(display-version $mver) | tee -a $log
        fi
        handle-module $fmodule $MODREF
    else
        ilog $module $MODREF found
    fi
}

############################## handle-sources
#
#  get the module sources from a tar or a vcs
#

function handle-sources()
{
    local FORMODULE=$1
    local MODREF=$2

    #  Get module information

    local module_info=( $(get-module-ref $MODREF $FORMODULE) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    [[ "$variant" = "native" ]] && return 0;

    #  Check if a given tar exists even if a standard branch ref has
    #  been provided. This is an optimization to used a local tar
    #  instead of a repository branch.

    if [[ $kind == BRANCH && "$TAR_CACHE" == "yes" ]]; then
        check-tar-exists $module $variant $ref
        [[ $? == 0 ]] && kind=VERSION
    fi

    #  If building from tarball, extract it now

    if [[ $kind == VERSION ]]; then
        local tar=( $(get-tar-data $module $variant $ref) )

        if [[ ! $? = 0 ]]; then
            echo "error: $module-tar function not defined, cannot get tarball"
            exit 1
        fi

        tarsrc=${tar[4]}

        #  We need to extract the tarball if the version does not match
        #  the one currently extracted.

        if [[ -f source-id ]]; then
            if [[ "$(cat source-id)" != "tar-$ref" ]] ||
                   [[ ${tarsrc^^} = "NONE" ]];
            then
                rm -fr tarsrc
            fi
        fi

        if [[ $DO_UPDATE = yes ]] || [[ ! -d tarsrc ]] || [[ ! -f tar ]]; then
            V=${tar[0]#default}
            ilog $module get sources from tar ${V:+[$V]}

            get-tar $module $variant $ref >> $log 2>&1

            if [[ ! $? = 0 ]]; then
                ilog $module cannot get/find tar sources
                exit 1
            fi
        fi

        echo -n "tar-$ref" > source-id

        #  Compute and store the version id of the sources + compiler.
        #  That is when the compiler is changed when want to rebuild
        #  the software.
        get-build-id $SCBI_PREFIX $SCBI_TARGET \
                     $FORMODULE $MODREF tar-$ref > build-id-$variant

        #  We set the link for the source so that no module will have to
        #  do it.

        ln -s tarsrc src

    else
        #  Get sources from repository

        vcs=( $(get-vcs-data $module $variant) )
        res=$?

        local VCS_NAME=${vcs[3]}
        local VCS_URL=${vcs[4]}

        if [[ $res = 0 ]] && [[ "${VCS_NAME^^}" != "NONE" ]]; then
            REPO=$(basename $VCS_URL .git)

            if [[ $kind = DEV ]]; then
                local SCBI_VCS_REPO=

                case $VCS_NAME in
                    git)
                        SCBI_VCS_REPO=$SCBI_GIT_REPO
                        ;;
                    svn|subversion)
                        SCBI_VCS_REPO=$SCBI_SVN_REPO
                        ;;
                    hg)
                        SCBI_VCS_REPO=$SCBI_HG_REPO
                        ;;
                    *)
                        elog $module unsupported VCS $VCS_NAME
                        exit 1
                esac

                if [[ -d $SCBI_VCS_REPO/$REPO ]]; then
                    ln -s $SCBI_VCS_REPO/$REPO vcs

                    #  Compute and store the version id of the sources +
                    #  compiler. That is when the compiler is changed we
                    #  want to rebuild the software.

                    echo -n "$ref" > source-id

                    vcs-build-id $SCBI_PREFIX $SCBI_TARGET \
                                 $FORMODULE $MODREF $(pwd)/vcs \
                                 > build-id-$variant

                else
                    ilog $module cannot find local dev repository:
                    ilog $module $SCBI_VCS_REPO/$REPO
                    exit 1
                fi

            else
                if [[ ! $DO_TEST =~ "yes-only" ]]; then
                    if [[ -f source-id ]]; then
                        if [[ "$(cat source-id)" != "vcs-$ref" ]]; then
                            # a different version is needed
                            DO_UPDATE=yes
                        fi
                    else
                        DO_UPDATE=yes
                    fi
                fi

                if [[ $DO_UPDATE = yes ]] || [[ ! -d ../.vcs/$REPO ]]; then
                    V=${vcs[0]#default}
                    ilog $module get sources from $VCS_NAME ${V:+[$V]}

                    get-vcs $SCBI_PREFIX $SCBI_TARGET $MODREF

                    if [[ ! $? = 0 ]]; then
                        exit 1
                    fi
                else
                    ln -s ../.vcs/$REPO vcs
                fi

                echo -n "vcs-$ref" > source-id

                #  Compute and store the version id of the sources +
                #  compiler. That is when the compiler is changed we
                #  want to rebuild the software.

                vcs-build-id $SCBI_PREFIX $SCBI_TARGET \
                             $FORMODULE $MODREF $(pwd)/vcs \
                             > build-id-$variant
            fi

            if [[ ! -h src ]]; then
                #  Setting source reference, note that for Subversion this
                #  need to properly set the link to the directory in the vcs.
                #  This action is done by svn-branch that we call here.

                case $VCS_NAME in
                    svn|subversion)
                        svn-branch "" "" $module $ref ""
                        ;;
                    *)
                        ln -s vcs src
                        ;;
                esac
            fi

            return 0

        else
            #  No VCS, no TAR, just rebuild the sources if present
            if [[ ! -d src ]]; then
                ilog $module "no sources (vcs or tar)"

                get-build-id $SCBI_PREFIX $SCBI_TARGET \
                             $FORMODULE $MODREF "$variant" \
                             > build-id-$variant
            else
                get-build-id $SCBI_PREFIX $SCBI_TARGET \
                             $FORMODULE $MODREF "$(date)" \
                             > build-id-$variant
            fi
        fi

        #  If get-vcs is not defined then the $module-setup routine is in
        #  charge of creating/populating the src directory.
    fi
}

############################## handle-meta-module

function handle-meta-module()
{
    local metamodule=$1
    local variant=$2

    #  check for plan

    fn-exists $metamodule-$variant-plan

    if [[ $? = 0 ]]; then
        SCBI_PLAN=$($metamodule-$variant-plan)
        load-module-plan $SCBI_PLAN
    else
        fn-exists $metamodule-plan
        if [[ $? = 0 ]]; then
            SCBI_PLAN=$($metamodule-plan)
            load-module-plan $SCBI_PLAN
        fi
    fi

    #  check for dependencies

    if [[ $DEPS = yes ]]; then
        for dmodule in $(get-all-depends $metamodule $variant build-depends); do
            handle-depends $metamodule $dmodule || exit 1
        done
    fi

    #  check for setup

    line-sep
    ilog $metamodule Metamodule $metamodule-$variant setup | tee -a $log
    module-variant-wrapper $SCBI_BDIR/install \
                           $metamodule $variant setup || exit 1
    ilog $metamodule End metamodule $metamodule-$variant setup | tee -a $log
    line-sep

    local FCT=$(get-hook $metamodule $variant modules)

    for module in $($FCT $SCBI_PREFIX $SCBI_TARGET $variant); do
        handle-module $metamodule $module || exit 1
    done

    #  check for wrapup

    line-sep
    ilog $metamodule Metamodule $metamodule-$variant wrapup | tee -a $log
    module-variant-wrapper $SCBI_BDIR/install \
                           $metamodule $variant wrapup || exit 1
    ilog $metamodule End metamodule $metamodule-$variant wrapup | tee -a $log
    line-sep
}

############################## handle-module

function handle-module()
{
    local FORMODULE=$1
    local MODREF=$2

    #  Get module information

    local module_info=( $(get-module-ref $MODREF $FORMODULE) )

    if [[ ! -z ${module_info[4]} ]]; then
        module_info[1]=""
        module_info[2]=""
        module_info[3]=""
        elog ${module_info[@]}
        exit 1
    fi

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    #  If this module is marked as to be skipped

    if [[ "$ref" == "skip" ]]; then
        ilog $module skip $module, marked to be skipped
        return
    fi

    log=$SCBI_LOGS/$TODAY/$SCBI_TARGET-$module-$variant-report.log

    #  Check if we have already handled this module

    check-handled $module+$variant
    if [[ $? = 1 ]]; then
        if [[ $DRY_RUN == no ]] && [[ $DO_VERBOSE = yes ]]; then
            ilog $module skip $module, already handled
        fi
        return
    fi

    cd $SCBI_ROOT

    [[ ! -f $SCBI_DEFS/$module ]] &&
        echo "error: no description for module $module" &&
        exit 1

    #  Then load module setup

    load-module $MODREF

    #  Create module build directory

    mkdir -p $SCBI_BDIR/$module/$SCBI_TARGET-$variant/.log > $log 2>&1
    local fct=$SCBI_BDIR/$module/$SCBI_TARGET-$variant/.log/fct.cmd

    echo "function add-to-var()"                      > $fct
    echo "{"                                         >> $fct
    echo '    local VAR=$1'                          >> $fct
    echo '    local DIR=$2'                          >> $fct

    if [[ $SCBI_IS_WINDOWS == yes ]]; then
        echo '    if [[ $VAR == "PATH" ]]; then'              >> $fct
        echo '        export $VAR="${DIR}${!VAR:+:}${!VAR}"'  >> $fct
        echo '    else'                                       >> $fct
        echo '        export $VAR="${DIR}${!VAR:+;}${!VAR}"'  >> $fct
        echo '    fi'                                         >> $fct
    else
        echo '    export $VAR="${DIR}${!VAR:+:}${!VAR}"'      >> $fct
    fi

    echo "}"                                         >> $fct

    record-build-plan $module $variant

    #  Check if meta-module, if so call handle-module for each one

    fn-exists $module-$variant-modules

    if [[ $? = 0 ]]; then
        (
            handle-meta-module $module $variant
        )
        return $?
    else
        fn-exists $module-modules
        if [[ $? = 0 ]]; then
            (
                handle-meta-module $module $variant
            )
            return $?
        fi
    fi

    #  Check for depends if any, and handle them if any

    if [[ $DEPS = yes ]]; then
        #  First we check for build dependencies
        (
            for dmodule in $(get-all-depends $module $variant build-depends); do
                handle-depends $MODREF $dmodule
            done
        )
        if [[ ! $? = 0 ]]; then
            exit 1
        fi
        [[ $DRY_RUN == no ]] && line-sep

        #  And then we check for standard dependencies
        (
            for dmodule in $(get-all-depends $module $variant depends); do
                handle-depends $MODREF $dmodule
            done
        )
        if [[ ! $? = 0 ]]; then
            exit 1
        fi
        [[ $DRY_RUN == no ]] && line-sep
    fi

    if [[ $DRY_RUN == yes ]]; then
        echo "$MODREF"
        return 0
    fi

    clog $module

    #  If purge is asked, first remove current build structure

    if [[ $DO_PURGE = yes || $DO_PURGE = only ]]; then
        ilog $module Purging $module for $SCBI_TARGET/$variant
        [[ -d $SCBI_BDIR/$module ]] &&
            module-purge $SCBI_BDIR/$module $FORMODULE $module \
                         $variant $SCBI_TARGET
    fi

    if [[ $DO_CLEAN_INSTALL = yes ]]; then
        ilog $module Clean $module install for $SCBI_TARGET/$variant
        [[ -d $SCBI_BDIR/$module ]] &&
            module-clean-install \
                $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install \
                $FORMODULE $module $variant $SCBI_TARGET
        return 0
    fi

    #  If purge-only, stop there

    [[ $DO_PURGE = only ]] && return 0

    if [[ $ref == NONE ]]; then
        DISPREF=master
    else
        DISPREF=$ref
    fi

    line-sep
    ilog $module Building $module [${variant//./ }] \($DISPREF\) | tee -a $log

    if [[ $SCBI_HOST == $SCBI_TARGET ]]; then
        ilog $module native $SCBI_TARGET | tee -a $log
    else
        ilog $module cross $SCBI_TARGET | tee -a $log
    fi

    ilog $module steps : $STEPS | tee -a $log

    #  Create the build root directory if needed, note that we do check here
    #  even if already created when entering this routine. This is because
    #  in case of a purge the build directory could have been removed.

    [[ -d $SCBI_BDIR/$module/$SCBI_TARGET-$variant ]] ||
        mkdir $SCBI_BDIR/$module/$SCBI_TARGET-$variant

    #  Set module environment if defined

    (
        #  Set cross-env if needed

        if [[ "$SCBI_HOST" != "$SCBI_TARGET" ]]; then
            target-env $SCBI_BDIR/install $SCBI_TARGET
        fi

        #  Setup the build environment for the current module

        handle-module-env $FORMODULE $MODREF build-env

        #  And then setup recursively the environment to use dependencies

        handle-env $FORMODULE $MODREF

        #  Log module enviroment

        ENVLOG=$SCBI_LOGS/$TODAY/$SCBI_TARGET-$module-$variant-env.log

        echo "==================== env " > $ENVLOG
        env >> $ENVLOG

        [[ ! -z $(command -v gprls 2> /dev/null) ]] &&
            (
                echo "==================== gprls " >> $ENVLOG
                gprls -v 2>&1 >> $ENVLOG
            )

        [[ ! -z $(command -v gcc 2> /dev/null) ]] &&
            (
                echo "==================== gcc " >> $ENVLOG
                gcc -v &>> $ENVLOG
            )

        #  We need to remove the link/sources to ensure proper setting by
        #  the module.

        [[ -d $SCBI_BDIR/$module ]] && cd $SCBI_BDIR/$module && rm -fr src vcs

        handle-sources $FORMODULE $MODREF

        [[ ! $? = 0 ]] && exit 1

        #  Check if envrionment is to be done for out-of-tree build

        FCT=$(get-hook $module $variant out-of-tree)

        [[ ! -z $FCT ]] && [[ $($FCT) = "false" ]] && ISOOT=no

        #  Call module routines

        #  If force build, remove the current build id

        [[ $DO_FORCE = yes ]] && rm -f $SCBI_TARGET-$variant/build-id

        #  Check build id, only rebuild if mismatch

        #  make sure the current build softlink is pointing to
        #  the variant. this is needed as the setup won't be
        #  done.

        [[ -d build ]] && rm -fr build
        ln -s $SCBI_TARGET-$variant build

        diff -q build-id-$variant \
             $SCBI_BDIR/$module/$SCBI_TARGET-$variant/build-id > /dev/null 2>&1

        if [[ $? = 0 ]]; then
            ilog $module no build needed, versions match

            STEPS=""

            # if testing is expected, at least do that

            if [[ $DO_TEST =~ "yes" ]]; then
                STEPS="$STEPS tests"
            fi

        else
            #  If install is requested and we already have a local install
            #  directory, clean it to ensure no old versions are installed
            #  into the same location.

            if [[ $DO_INSTALL = yes ]]; then
                rm -fr $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install
                rm -f  $SCBI_BDIR/$module/install-id
                rm -f  $SCBI_BDIR/$module/install-${SCBI_TARGET}-id
            fi

            #  Build is needed, on safe mode we remove the current
            #  build directory to ensure that old configuration and/or
            #  build artifacts are not going to break new build.
            #
            #  Note that we do that only for out-of-tree build as in
            #  the build in-tree the sources are fully syncronized from
            #  src directory (deleting all non existing files in source
            #  location)

            if [[ $SAFE_MODE = yes ]] && [[ $ISOOT = yes ]]; then
                rm -fr $SCBI_BDIR/$module/$SCBI_TARGET-$variant/build
                rm -fr $SCBI_BDIR/$module/$SCBI_TARGET-$variant/build-id
            fi
        fi

        for step in $STEPS; do
            ########## PRE module

            #  Apply any generic pre-step (module-pre-setup, module-pre-purge)

            local res=0

            fn-exists module-pre-$step

            if [[ $? = 0 ]]; then
                cd $SCBI_BDIR/$module

                if [[ $SCBI_DLOG = yes ]]; then
                    module-pre-$step \
                        $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install \
                        $FORMODULE \
                        $module \
                        $variant $SCBI_TARGET $ISOOT 2>&1 \
                        | tee $log
                    res=${PIPESTATUS[0]}
                else
                    module-pre-$step \
                        $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install \
                        $FORMODULE \
                        $module \
                        $variant $SCBI_TARGET $ISOOT 2>&1 \
                        | tee -a $log
                    res=${PIPESTATUS[0]}
                fi
            fi

            if [[ $res != 0 ]]; then
                elog $module generic module pre-$step failed with error $res
                return $res
            fi

            #  Apply module specific step if any

            module-variant-wrapper \
                $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install $module \
                $variant pre-$step || exit 1

            ########## module

            module-variant-wrapper \
                $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install $module \
                $variant $step || exit 1

            #  Apply any generic step (module-setup, module-purge)

            res=0

            fn-exists module-$step

            if [[ $? = 0 ]]; then
                cd $SCBI_BDIR/$module

                if [[ $SCBI_DLOG = yes ]]; then
                    module-$step \
                        $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install \
                        $FORMODULE \
                        $module $variant $SCBI_TARGET $ISOOT 2>&1 | tee $log
                    res=${PIPESTATUS[0]}
                else
                    module-$step \
                        $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install \
                        $FORMODULE \
                        $module $variant $SCBI_TARGET $ISOOT 2>&1 | tee -a $log
                    res=${PIPESTATUS[0]}
                fi
            fi

            if [[ $res -ne 0 ]]; then
                elog $module generic module $step failed with error $res
                return $res
            fi

            ########## POST module

            module-variant-wrapper \
                $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install \
                $module $variant post-$step || exit 1

            res=0

            fn-exists module-post-$step

            if [[ $? = 0 ]]; then
                cd $SCBI_BDIR/$module

                if [[ $SCBI_DLOG = yes ]]; then
                    module-post-$step \
                        $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install \
                        $FORMODULE \
                        $module $variant $SCBI_TARGET $ISOOT \
                        2>&1 | tee $log
                    res=${PIPESTATUS[0]}
                else
                    module-post-$step \
                        $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install \
                        $FORMODULE \
                        $module $variant $SCBI_TARGET $ISOOT \
                        2>&1 | tee -a $log
                    res=${PIPESTATUS[0]}
                fi
            fi

            if [[ $res != 0 ]]; then
                elog $module generic module post-$step failed with error $res
                return $res
            fi
        done
    ) || exit 1

    #  Create binary archive if needed

    if [[ $DO_ARCHIVE = yes ]]; then
        cd $SCBI_BDIR/$module/build >> $log 2>&1
        tar cf $module-bin.tar --directory=install .
        bzip2 -9 $module-bin.tar
    fi

    local _IDIR=""

    FCT=$(get-hook $module $variant prefix)

    if [[ "$FCT" != "" ]] && [[ "$SCBI_DEFAULT_PREFIX" = "yes" ]]; then
        _IDIR=$($FCT $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install \
                     $SCBI_TARGET $variant)
    else
        _IDIR=$SCBI_PREFIX
    fi

    if [[ $_IDIR == NONE ]]; then
        ilog $module skip global install

    elif [[ "$DO_INSTALL" = "yes" ]] &&
             [[ -d $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install ]];
    then
        ilog $module copy install into ..${_IDIR/$SCBI_BDIR/}

        #  Record global install
        echo "$variant" > $SCBI_BDIR/$module/install-${SCBI_TARGET}-id
        echo ${_IDIR}  >> $SCBI_BDIR/$module/install-${SCBI_TARGET}-id

        #  Finaly copy to given prefix
        SUDO=""

        if [[ ! -d ${_IDIR} ]]; then
            mkdir -p ${_IDIR} &> /dev/null
            [[ ! $? = 0 ]] && SUDO=sudo
        fi

        if [[ ! -w ${_IDIR} ]]; then
            SUDO=sudo
        fi

        $SUDO mkdir -p ${_IDIR}/
        $SUDO rsync -a --force \
              $SCBI_BDIR/$module/$SCBI_TARGET-$variant/install/. \
              ${_IDIR}/. > $log 2>&1
    fi || elog $module fail to copy to ${_IDIR}

    ilog $module End Building $module [${variant//./ }] \($DISPREF\) \
        | tee -a $log
    line-sep
}

############################## body

# first we check for --enable-* options

SCBIOPTS=""

#  First handle specific parameters:
#    --enable-*
#    --run:"some command"

while [[ $# -gt 0 ]]; do
    case $1 in
        --enable-*)
            VAR=${1/--enable-/}
            export SCBI_${VAR/-/_}_SET=true
            ;;
        --run:*)
            DO_RUN=yes
            DO_RUN_CMD=${1/*:/}
            ;;
        *)
            SCBIOPTS="$SCBIOPTS $1"
            ;;
    esac
    shift
done

set -- $(getopt -q -u -o :t:j:adefSIuscbilnpPvwWh \
                -l store,target:,no-setup,no-install,update,setup,config \
                -l build,build-target:,install,clean-install,tar \
                -l log,log:yes,log:no,log:on-failure,purge,purge-only \
                -l verbose,prefix:,tests,tests-only,help,deps \
                -l archive,force,env:,no-patch,plan:,stat,stat:full \
                -l list-depends:direct,list-depends:full,list-depends \
                -l list-externals,list-externals:only,list-no-version \
                -l list-filter:all,list-filter:dev,list-filter:runtime \
                -l dry-run,jobs:,no-wrapup,wrapup,safe,standalone \
                -l plugins:,build-dir,list-plan:,version,module-version \
                -l shell,shell:dev,shell:sb,shell:sandbox \
                -- $(echo $SCBIOPTS))

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            DO_HELP=yes
            break
            ;;
        --version)
            DO_VERSION=yes
            break
            ;;
        -f|--force)
            DO_FORCE=yes
            ;;
        -a|--archive)
            DO_ARCHIVE=yes
            ;;
        -e|--env)
            ENV_NAME="-$2"
            shift
            ;;
        --tar)
            TAR_CACHE=no
            ;;
        -t|--target)
            SCBI_TARGET=$2; shift
            SCBI_TARGET_SPECIFIED=yes
            ;;
        -S|--no-setup)
            STEPS=${STEPS/setup/}
            ;;
        -W|--no-wrapup)
            STEPS=${STEPS/wrapup/}
            ;;
        -w|--wrapup)
            NSTEPS="$NSTEPS wrapup"
            ;;
        -I|--no-install)
            DO_INSTALL=no
            ;;
        -u|--update)
            DO_UPDATE=yes
            ;;
        -s|--setup)
            NSTEPS="$NSTEPS setup"
            ;;
        --shell:sb|--shell:sandbox)
            DO_SHELL=yes
            ;;
        --shell:dev)
            DO_SHELL=yes-dev
            ;;
        --shell)
            DO_SHELL=yes-nocd
            ;;
        -c|--config)
            NSTEPS="$NSTEPS config"
            ;;
        -b|--build)
            NSTEPS="$NSTEPS build"
            ;;
        --build-target)
            BUILD_SCBI_TARGET=$2; shift
            ;;
        -d|--deps)
            DEPS=yes
            ;;
        -i|--install)
            NSTEPS="$NSTEPS install"
            DO_INSTALL=yes
            ;;
        -l|--log|--log:yes)
            SCBI_DLOG=yes
            ;;
        --log:no)
            SCBI_DLOG=no
            ;;
        --log:on-failure)
            SCBI_DLOG=on-failure
            ;;
        --tests)
            NSTEPS="$NSTEPS setup config build install tests wrapup"
            DO_TEST=yes
            ;;
        --tests-only)
            NSTEPS="$NSTEPS tests"
            DO_TEST=yes-only
            ;;
        -v|--verbose)
            DO_VERBOSE=yes
            ;;
        -p|--purge)
            DO_PURGE=yes
            ;;
        -n|--no-patch)
            DO_PATCH=no
            ;;
        --prefix)
            SCBI_DEFAULT_PREFIX=no
            SCBI_PREFIX=$2; shift
            ;;
        --module-version)
            DO_MOD_VER=yes
            shift
            ;;
        -P|--purge-only)
            DO_PURGE=only
            ;;
        -j|--jobs)
            SCBI_JOBS=$2; shift
            SCBI_HALF_JOBS=$SCBI_JOBS
            ;;
        --plan)
            SCBI_PLAN_CL=$2; shift
            ;;
        --stat:full)
            DO_STAT=yes;
            ;;
        --stat)
            DO_STAT=info-only;
            ;;
        --list-depends:direct)
            DO_DEPS=yes-direct;
            ;;
        --list-depends:full)
            DO_DEPS=yes;
            ;;
        --list-depends)
            DO_DEPS=yes;
            ;;
        --list-externals:only)
            DO_EXT=yes-only;
            ;;
        --list-externals)
            DO_EXT=yes;
            ;;
        --list-no-version)
            DO_LIST_VER=no
            ;;
        --list-filter:all)
            SCBI_FILTER=all;
            ;;
        --list-filter:dev)
            SCBI_FILTER=dev;
            ;;
        --list-filter:runtime)
            SCBI_FILTER=runtime;
            ;;
        --list-plan)
            DO_PLAN=yes;
            ;;
        --dry-run)
            DRY_RUN=yes;
            ;;
        --safe)
            SAFE_MODE=yes;
            ;;
        --standalone)
            DO_STANDALONE=yes;
            ;;
        --plugins)
            SCBI_DEFS=$2; shift
            if [[ ! -d "$SCBI_DEFS" ]] || \
                   [[ -z "$(ls $SCBI_DEFS/[0-9]* 2> /dev/null)" ]];
            then
                echo "$0: no plugins found in $SCBI_DEFS"
                exit 1
            fi
            ;;
        --build-dir)
            CMDLINE_BUILD_DIR=$2; shift
            ;;
        --clean-install)
            DO_CLEAN_INSTALL=yes
            ;;
        --store)
            DO_STORE=yes
            shift
            shift
            STORE_KEY="$1"
            STORE_VALUE="$2"

            [[ -z $1 ]] &&
                echo "$0: missing key for store command" &&
                exit 1
            [[ ! -z $3 ]] &&
                echo "$0: unexpected parameters for store command" &&
                exit 1
            shift
            shift
            ;;
        (--)
            ;;
        (*)
            MODULES="$MODULES $1"
            LAST_MODULE=$1
            ;;
        (-*)
            echo "$0: error - unrecognized option $1" 1>&2; exit 1
            ;;
    esac
    shift
done

if [[ $DO_EXT != no && $DO_DEPS == no ]]; then
    DO_DEPS=yes
fi

trap clean-up EXIT

#  Load module definitions

[[ ! -d "$SCBI_DEFS" ]] || [[ -z "$(ls $SCBI_DEFS/[0-9]* 2> /dev/null)" ]] &&
    SCBI_DEFS=$HOME/.config/scbi

[[ ! -d "$SCBI_DEFS" ]] &&
    echo "$0: cannot find module definition files" && exit 1

#  Load user's environment if any now that SCBI_DEFS is set

load-module-env $ENV_NAME

#  If we have explicitly specified some steps, use them

if [[ "$NSTEPS" != "" ]]; then
    STEPS=$NSTEPS
fi

#  If we have specified a build directory on command line, set it now
#  that the env is loaded (takes precedence).

if [[ ! -z $CMDLINE_BUILD_DIR ]]; then
    export SCBI_BDIR=$CMDLINE_BUILD_DIR
fi

#  Then load any global settings, not overriding user's ones

for setup in $SCBI_DEFS/[0-9]*; do
    source $setup
done

#  Then load any OS dependent runtime module

[[ -f $SCBI_DEFS/_os_$SCBI_OS_MODULE ]] &&
    source $SCBI_DEFS/_os_$SCBI_OS_MODULE

#  Handle store command

if [[ $DO_STORE = yes ]]; then
    scbi-store "$STORE_KEY" "$STORE_VALUE"
    exit $?
fi

#  Nothing to build, display usage

if [[ $DO_VERSION = yes ]]; then
    echo "SCBI : $SCBI_VERSION"
    for file in $(ls $SCBI_DEFS/.scbi*version.txt 2> /dev/null); do
        cat $file
    done
    exit 0
fi

#  If a plan passed on the command line ensure that it is used instead
#  of any other possibly set in the environment file.

[[ ! -z $SCBI_PLAN_CL ]] && SCBI_PLAN=$SCBI_PLAN_CL

[[ "$MODULES" = "" ]] &&
    [[ $DO_SHELL != no ]] &&
    [[ $DO_RUN != no ]] &&
    [[ $DO_STAT == no ]] &&
    echo "error: shell/run commands need a plug-in, see scbi --help" && exit 0

[[ "$MODULES" = "" ]] && [[ $DO_STAT == no ]] && [[ $DO_MOD_VER == no ]] &&
    usage && exit 0

[[ $DO_HELP == yes ]] && usage && exit 0

[[ $DO_STAT != no ]] &&
    display-stat

[[ "$MODULES" = "" ]] || [[ $DO_STAT == yes ]] &&
    display-modules && display-plans

[[ $DO_STAT == yes ]] &&
    display-log-stat

#  Load build plan if any

if [[ ! -z $SCBI_PLAN ]]; then
    load-module-plan $SCBI_PLAN
    [[ $? -ne 0 ]] &&
        echo "error: cannot load module plan $SCBI_PLAN" &&
        exit 1
fi

#  Setup module reference specified on the command line. The module
#  reference on the command line must overwrite the actual build plan.

for module in $MODULES; do
    set-module-ref $module
done

if [[ $DO_STAT == no ]]; then
    if [[ $DO_MOD_VER == no ]]; then
        handle-auto-variant
    else
        handle-auto-variant > /dev/null
    fi
    [[ $? == 1 ]] && exit 1
fi

if [[ $DO_DEPS != no ]]; then
    for module in $MODULES; do
        for-all-modules-with-meta-ext register-depends-callback $module
    done

    if [[ $? = 0 ]]; then
        {
            for MOD in "${MODULE_LIST[@]}"; do
                echo "${MOD}"
            done
        } | sort | uniq

        exit 0
    fi

    exit 1
fi

#  Prepare log dir and tarball dir

mkdir -p $SCBI_LOGS/$TODAY
mkdir -p $SCBI_TAR

if [[ $DRY_RUN == yes ]]; then
    DO_PURGE=no
    DO_INSTALL=no
    DO_ARCHIVE=no
    DO_UPDATE=no
    DO_FORCE=no
    DO_CLEAN_INSTALL=no
    STEPS=""
fi

#  If a run is requested

if [[ $DO_RUN == yes ]]; then
    run-command $SCBI_TARGET $LAST_MODULE "$DO_RUN_CMD"
    exit 0
fi

#  If a shell is requested

if [[ $DO_SHELL == yes ]] || [[ $DO_SHELL == yes-dev ]]; then
    run-shell $SCBI_TARGET $LAST_MODULE $DO_SHELL
    exit 0
fi

if [[ $DO_SHELL == yes-nocd ]]; then
    run-shell $SCBI_TARGET $LAST_MODULE no
    exit 0
fi

#  If we want to display a module version from a module plan, do it now

if [[ $DO_MOD_VER == yes ]]; then
    for module in $MODULES; do
        display-module-version $module
    done
    exit 0
fi

if [[ $DO_PLAN == yes ]]; then
    display-build-plan
    exit 0
fi

#  Run script for all modules

for module in $MODULES; do
    handle-module "@root" $module || exit 1
done

if [[ $DO_STANDALONE == yes ]]; then
    create-standalone-package
fi
