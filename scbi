#!/bin/bash
#
#  This is a script to build applications from sources. The simplest usage is:
#
#     $ scbi darktable
#
#  To build an application called darktable. An application can be given a
#  variant build:
#
#     $ scbi darktable/debug
#
#  And eventually a branch (in the repository) or a version for the tarball.
#
#     $ scbi darktable/debug:release-2.4.x
#
#  To differenciate a version from a branch, the version string starts with '#'.
#
#  Finally darktable is a module for which a set of function is given in the
#  darktable source file.
#
#  For all modules the following function can be implemented and are called
#  in this specific order:
#
#    <module>-vcs      parameter: NONE, return: array
#                      describe the VCS to get the sources
#                        1st item: protocole (git, svn)
#                        2nd item: URL
#
#    <module>-tar      parameter: $VERSION, return: array
#                      describe a way to get the sources as tarball
#                        1st item: protocole (scp, none)
#                        2st item: URL
#                        3st item: archive name (with $VERSION)
#
#    <module>-version  parameter: $PREFIX $TARGET, return: <installed version>
#                      returns the current version of the installed tool
#                      It can returns $VERSION_OK or $VERSION_ERROR if it
#                      is not possible to get the real version.
#
#    <module>-depends  parameter: NONE, return: array
#                      list all modules required. these are either
#                      source module handled by this script or a distrib
#                      package. each module is <name>:<version>
#
#    <module>-env      parameter: $PREFIX $TARGET, return NONE
#                      set environment to use when calling the routines
#                      (setup, config, build, install, tests).
#
#    <module>-setup    parameter: $PREFIX $TARGET, return NONE
#                      to setup build structure (optional)
#                      also: pre-setup / post-setup
#
#    <module>-config   parameter: $PREFIX $TARGET, return NONE
#                      to configure, ./configure or other steps
#                      also: pre-config / post-config
#
#    <module>-build    parameter: $PREFIX $TARGET, return NONE
#                      to build, make
#                      also: pre-build / post-build
#
#    <module>-install  parameter: $PREFIX $TARGET, return NONE
#                      to install (in $PREFIX)
#                      also: pre-install / post-install
#
#    <module>-prefix   parameter: $PREFIX $TARGET, return string
#                      the directory to install, default $BDIR/install
#
#    <module>-tests    parameter: $PREFIX $TARGET, return NONE
#                      to pass automatic tests
#
#  Note that all steps above are optional. And empty module will just do
#  nothing. For setup, config, build, install it may exists version pre/post
#  which may be used for complex module handling. The order is the following:
#
#     module-pre-<step>      - the generic pre step handled internally
#     <module>-pre-<step>    - done before step
#     <module>-<step>        - default step is done before generic one
#     module-<step>          - the generic step handled internally
#     <module>-post-<step>   - done after step
#     module-post-<step>     - the generic post step handled internally
#
#  The following steps can have variants:
#
#     <module>-<variant>-depends
#     <module>-<variant>-env
#     <module>-<variant>-setup
#     <module>-<variant>-config
#     <module>-<variant>-build
#     <module>-<variant>-install
#     <module>-<variant>-prefix
#
#  It is possible to build from a tarball, the tar must be placed into the
#  TARBALL directory.
#
#  After the sources are setup, it is possible to apply some local patches.
#  the patches must be placed into the PATCHES directory and named:
#
#     <module>-<numeric-id>-<some-name>.patch
#
#  patches are applied using <numeric-id> ordering.
#
#  The final step is to install into the final location, the copy is done
#  by default.
#
#  Variables:
#  ----------
#
#  ROOT       : default root directory to use
#  BDIR       : the modules build root directory ($ROOT/builds)
#  GREPO      : directory with local Git repositories ($ROOT/repositories/git)
#  SREPO      : directory with local Svn repositories ($ROOT/repositories/svn)
#  TARBALL    : directory where downloaded tarball are stores ($BDIR/tar)
#  PREFIX     : directory where module are to be installed ($BDIR/install)
#  HOST       : current host (gcc -dumpmachine)
#  TARGET     : current target ($HOST)
#  DEFS       : where module scripts are to be found
#               ($PWD/.scripts.d $HOME/.config/scbi)

CDPATH=

#  Environment
HOST=$(gcc -dumpmachine | sed -e 's/-pc//;s/-unknown//')
TARGET=$HOST
TARGET_SPECIFIED=no
ENV_NAME=

#  General script setup
DLOG=on-failure
DEFS="$PWD"/scripts.d
JOBS=0
MJOBS=4
# MJOBS is for makefiles

#  Modules to be handled and already handled
MODULES=
HANDLED=""

#  Actions setup
PURGE=no
NSTEPS=
PREFIX=
DEFAULT_PREFIX=yes
DOINSTALL=yes
DOUPDATE=no
DOARCHIVE=no
DOFORCE=no
DEPS=no
ISOOT=no
PATCH=yes
STEPS="setup config build install"
BUILD_TARGET=

############################## fn-exists

function fn-exists()
{
    declare -f $1 > /dev/null
}

############################## fn-exists

function check-handled()
{
    local module=$1
    local res=0

    if [ "${HANDLED/,$module,/}" = "$HANDLED" ]; then
        HANDLED="$HANDLED,$module,"
        return 0
    else
        return 1
    fi
}

############################## module-wrapper

function module-wrapper()
{
    local PREFIX=$1
    local module=$2
    local variant=$3
    local step=$4

    log=$LOGS/$TARGET-$module-$step.log

    if [ $step = "build" -a "$BUILD_TARGET" != "" ]; then
        mstep=build-$BUILD_TARGET
    else
        mstep=$step
    fi

    ilog $module $mstep starting

    (
        cd $BDIR/$module >> $log 2>&1

        #  Set cross-env is needed

        if [ "$HOST" != "$TARGET" ]; then
            target-env $BDIR/install $TARGET
        fi

        #  And setup any module environment

        fn-exists $module-$variant-env

        if [ $? = 0 ]; then
            $module-$variant-env $BDIR/$module/build/install $TARGET
        else
            fn-exists $module-env

            if [ $? = 0 ]; then
                $module-env $BDIR/$module/build/install $TARGET
            fi
        fi

        #  Go to build directory

        if [ "$step" = "setup" ]; then
            cd $BDIR/$module
        else
            cd $BDIR/$module/build/build
        fi

        #  Call module step

        if [[ $DLOG = yes || "$step" = "tests" ]]; then
	    $module-$step $PREFIX $TARGET | tee $log 2>&1
        else
	    $module-$mstep $PREFIX $TARGET >> $log 2>&1
        fi
        res=$?

        #  Check for errors

        if [ $res != 0 ]; then
	    if [ $DLOG = on-failure ]; then
	        tail -100 $log
	    fi
	    elog $module $mstep failed with error $res
	    return $res
        else
	    ilog $module $mstep completed
	    return 0
        fi
    )
}

############################## module-wrapper

function module-variant-wrapper()
{
    local PREFIX=$1
    local module=$2
    local variant=$3
    local step=$4

    fn-exists $module-$variant-$step

    if [[ $? = 0 ]]; then
	module-wrapper $BDIR/$module/build/install $module \
                       $variant $variant-$step || exit 1

    else
        fn-exists $module-$step

        if [[ $? = 0 ]]; then
	    module-wrapper $BDIR/$module/build/install $module \
                           $variant $step || exit 1
        fi
    fi
}

############################## usage

function usage()
{
    local k=0

    echo
    echo $0 [options] module1 [module2 ... modulen]

    echo ""
    echo "   modulen  <name>/<variant> build <variant> from repository version"
    echo "   modulen  <name>:<branch>  build from repository version <branch>"
    echo "   modulen  <name>:#<ver>    build from tarbal version <ver>"
    echo "   modulen  <name>:dev       build from user's repository current branch"
    echo "   modulen  <name>           build from repository main branch"
    echo ""
    echo "   -h | --help          this help message"
    echo "   -e | --env=<name>    environment file ~/.scbi-<name>"
    echo "   -t | --target=<name> specify the target to build for ($TARGET)"
    echo "   -S | --no-setup      skip setup"
    echo "   -I | --no-install    skip install"
    echo "   -u | --update        do update"
    echo "   -s | --setup         do setup"
    echo "   -c | --config        do config"
    echo "   -b | --build         do build"
    echo "   -i | --install       do install"
    echo "   -r | --tests         run the testsuite"
    echo "   -d | --deps          check/build dependencies"
    echo "   -a | --archive       build binary archive"
    echo "   -v | --verbose       display full log"
    echo "   -l | --no-log        never display log"
    echo "   -f | --force         force rebuild, do not check build id"
    echo "   -p | --purge         remove builds directories before building"
    echo "   -P | --purge-only    only remove builds directories"
    echo "   -n | --no-patch      do not apply patches"
    echo "   -j | --jobs=<n>      max compilation jobs"

    echo
    echo -n modules:

    for module in $DEFS/[^0-9]*; do
	echo -n " $(basename $module)"
	k=$(expr $k + 1)
	[ $k == 7 ] && k=0 && echo && echo -n "        "
    done
    echo

    exit 1
}

############################## parse-module-ref

# Returns an array with the following information:
# ( module ["default"|variant] [DEV|VERSION|BRANCH|NONE] [branch|version|NONE] )

function parse-module-ref()
{
    # full module reference is name[/variant][:version]
    local modref="$1"

    # check for version
    local mver=($(echo $modref | tr ":" " "))

    if [ -z ${mver[1]} ]; then
        local KIND=NONE
        local version=NONE
    else
        local vb=${mver[1]:0:1}

        if [ ${mver[1]} = dev ]; then
            KIND=DEV
            local version=${mver[1]}
        elif [ $vb = '#' ]; then
            KIND=VERSION
            local version=${mver[1]:1}
        else
            KIND=BRANCH
            local version=${mver[1]}
        fi
    fi

    # check for variant
    local mvar=($(echo ${mver[0]} | tr "/" " "))

    if [ -z ${mvar[1]} ]; then
        local variant=default
    else
        local variant=${mvar[1]}
    fi

    local module=${mvar[0]}

    echo $module
    echo $variant
    echo $KIND
    echo $version
}

############################## handle-env

function handle-env()
{
    local modref=$1

    #  Get module information

    local module_info=( $(parse-module-ref $modref) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    #  Then load module

    if [ -f $DEFS/$module ]; then
        source $DEFS/$module

        # setup depends recursively if any

        fn-exists $module-$variant-depends

        if [ $? = 0 ]; then
            for dmodule in $($module-$variant-depends); do
                handle-env $dmodule
            done
        else
            fn-exists $module-depends

            if [ $? = 0 ]; then
                for dmodule in $($module-depends); do
                    handle-env $dmodule
                done
            fi
        fi

        # then setup the current module

        fn-exists $module-$variant-env

        if [ $? = 0 ]; then
            $module-$variant-env $BDIR/$module/build/install $TARGET
        else
            fn-exists $module-env

            if [ $? = 0 ]; then
                $module-env $BDIR/$module/build/install $TARGET
            fi
        fi
    fi
}


############################## handle-depends

function handle-depends()
{
    local modref=$1

    local module_info=( $(parse-module-ref $modref) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    #  If we want latest version, just handle this module

    if [ "$kind" = "DEV" ]; then
        handle-module $1
        return
    fi

    cd $ROOT

    #  If module not found, check for a possible distrib package

    if [ ! -f $DEFS/$module ]; then
        check-pkg $module:$version

        if [ $? = 0 ]; then
            return 0
        else
            echo No description for module $module &&
            echo And not found in the distrib  &&
            exit 1
        fi
    fi

    #  Check if the proper version is installed

    source $DEFS/$module

    fn-exists $module-version
    if [[ $? = 0 ]]; then
        pushd $(mktemp -d) > /dev/null 2>&1

        mver=$($module-version $PREFIX $TARGET)

        [ "${PWD:0:4}" = "/tmp" ] && rm -r $(pwd)

        popd > /dev/null 2>&1
    else
        mver=$VERSION_OK
    fi

    #  Clean-up the version number (only digits and a single dot)

    mver=$(get-version-number $mver)

    cd $ROOT

    [ "$version" = "NONE" ] && version=0

    if [[ "$mver" = "" \
                || "$mver" = $VERSION_ERROR \
                || $version > $mver ]];
    then
        echo
        ilog build need building $module, \
             current version $(display-version $mver) | tee -a $log
        handle-module $modref
    else
        ilog build $modref found
    fi
}

############################## handle-module

function handle-module()
{
    local modref=$1

    #  Get module information

    local module_info=( $(parse-module-ref $modref) )

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    log=$LOGS/$TARGET-$variant-$module-report.log

    #  Check if we have already handled this module

    check-handled $module+$variant
    if [[ $? = 1 ]]; then
        return
    fi

    cd $ROOT

    [ ! -f $DEFS/$module ] &&
        echo No description for module $module &&
        exit 1

    #  Then load module setup

    source $DEFS/$module

    #  Create module environment now

    mkdir -p $BDIR/$module/$TARGET-$variant > $log 2>&1

    #  Check meta-modules

    fn-exists $module-$variant-modules
    if [[ $? = 0 ]]; then
        (
            for module in $($module-$variant-modules); do
                handle-module $module
            done
        )
        return
    else
        fn-exists $module-modules
        if [[ $? = 0 ]]; then
            (
                for module in $($module-modules); do
                    handle-module $module
                done
            )
            return
        fi
    fi

    # Check for depends if any

    if [ $DEPS = yes ]; then
        fn-exists $module-$variant-depends
        if [[ $? = 0 ]]; then
            (
                for module in $($module-$variant-depends); do
                    handle-depends $module
                done
            )
            if [[ ! $? = 0 ]]; then
                exit 1
            fi
            echo
        else
            fn-exists $module-depends
            if [[ $? = 0 ]]; then
                (
                    for module in $($module-depends); do
                        handle-depends $module
                    done
                )
                if [[ ! $? = 0 ]]; then
                    exit 1
                fi
                echo
            fi
        fi
    fi

    clog $module

    #  If purge is asked, first remove current build structure

    if [ $PURGE = yes -o $PURGE = only ]; then
	ilog build Purging $module for $TARGET
        [ -d $BDIR/$module ] && module-purge $BDIR/$module $module $variant $TARGET
    fi

    [ $PURGE = only ] && exit 0

    ilog build Building $module-$variant | tee -a $log
    ilog build target $TARGET | tee -a $log
    ilog build steps : $STEPS | tee -a $log

    #  Create the build root directory if needed

    [ -d $BDIR/$module/$TARGET-$variant ] || mkdir $BDIR/$module/$TARGET-$variant

    #  Set module environment if defined

    (
        handle-env $modref

        #  Log module enviroment

        env > $LOGS/$TARGET-$module-$variant-env.log
        echo "===============================================" \
	     >> $LOGS/$TARGET-$module-$variant-env.log
        gnat ls -v >> $LOGS/$TARGET-$module-$variant-env.log 2> /dev/null
        which gcc >> $LOGS/$TARGET-$module-$variant-env.log 2> /dev/null

        #  We need to remove the link/sources to ensure proper setting by
        #  the module.

        [ -d $BDIR/$module ] && cd $BDIR/$module && rm -fr src vcs

        #  If building from tarball, extract it now

        if [ $kind == VERSION ]; then
            fn-exists $module-tar

            if [[ ! $? = 0 ]]; then
                echo "error: $module-tar function not defined, cannot get tarball"
                exit 1
            fi

            #  We need to extract the tarball if the version does not match
            #  the one currently extracted.

            if [ -f tarsrc-version ]; then
                if [ "$(cat tarsrc-version)" != "$version" ]; then
                    rm -fr tarsrc
                fi
            fi

            if [ $DOUPDATE = yes -o ! -d tarsrc  ]; then
	        ilog build get sources from tar

                vid=$(get-tar $module $version >> $log 2>&1)

                if [[ ! $? = 0 ]]; then
                    ilog build cannot get/find tar sources
                    exit 1
                fi

                echo -n $version > tarsrc-version

                #  Compute and store the version id of the sources + compiler.
                #  That is when the compiler is changed when want to rebuild
                #  the software.
                get-build-id $PREFIX $TARGET $vid > build-id
            fi

            #  We set the link for the source so that no module will have to
            #  do it.

            ln -s tarsrc src
        else
            # Get sources from repository

            fn-exists $module-vcs

            if [[ $? = 0 ]]; then
                if [ $kind = DEV -a -d $GREPO/$module ]; then
                    ln -s $GREPO/$module vcs

                    #  Compute and store the version id of the sources +
                    #  compiler. That is when the compiler is changed we
                    #  want to rebuild the software.

                    vcs-build-id $PREFIX $TARGET $module $(pwd)/vcs > build-id
                else
                    vcs=( $($module-vcs) )
                    VCS_NAME=${vcs[0]}
                    VCS_URL=${vcs[1]}

                    REPO=$(basename $VCS_URL .git)

                    if [ $DOUPDATE = yes -o ! -d ../.vcs/$REPO ]; then
	                ilog build get sources from $VCS_NAME

                        get-vcs $VCS_NAME $VCS_URL $module $kind $ref

                        if [[ ! $? = 0 ]]; then
                            exit 1
                        fi
                    else
                        ln -s ../.vcs/$REPO vcs
                    fi

                    #  Compute and store the version id of the sources +
                    #  compiler. That is when the compiler is changed we
                    #  want to rebuild the software.

                    vcs-build-id $PREFIX $TARGET $module $(pwd)/vcs > build-id
                fi

                ln -s vcs src

            else
                #  No VCS, not TAR, just rebuild the sources
                get-build-id $PREFIX $TARGET $module "$(date)" > build-id
            fi

            #  If get-vcs is not defined then the $module-setup routine is in
            #  charge of creating/populating the src directory.
        fi

        #  Check if envrionment is to be done for out-of-tree build

        fn-exists $module-out-of-tree

        [ $? = 0 ] && [ $($module-out-of-tree) = "true" ] && ISOOT=yes

        #  Call module routines

        #  If force build, remove the current build id

        [ $DOFORCE = yes ] && rm -f build/build-id

        #  Check build id, only rebuild if mismatch

        diff -q build-id build/build-id > /dev/null 2>&1

        if [ $? = 0 ]; then
	    ilog build no build needed, version matches

        else
            for step in $STEPS; do
                ########## PRE module

                #  Apply any generic step (module-setup, module-purge)

                fn-exists module-pre-$step

                if [[ $? = 0 ]]; then
                    cd $BDIR/$module

                    if [ $DLOG = yes ]; then
                        module-pre-$step $BDIR/$module/build/install $module \
                                         $variant $TARGET $ISOOT | tee $log 2>&1
                    else
                        module-pre-$step $BDIR/$module/build/install $module \
                                         $variant $TARGET $ISOOT >> $log 2>&1
                    fi
                fi
                res=$?

                if [ $res != 0 ]; then
	            if [ $DLOG = on-failure ]; then
	                tail -100 $log
	            fi
	            elog generic module pre-$step failed with error $res
	            return $res
                fi

                #  Apply module specific step if any

                module-variant-wrapper $BDIR/$module/build/install $module \
                                       $variant pre-$step || exit 1

                ########## module

                module-variant-wrapper $BDIR/$module/build/install $module \
                                       $variant $step || exit 1

                #  Apply any generic step (module-setup, module-purge)

                fn-exists module-$step

                if [[ $? = 0 ]]; then
                    cd $BDIR/$module

                    if [ $DLOG = yes ]; then
                        module-$step $BDIR/$module/build/install $module \
                                     $variant $TARGET $ISOOT | tee $log 2>&1
                    else
                        module-$step $BDIR/$module/build/install $module \
                                     $variant $TARGET $ISOOT >> $log 2>&1
                    fi
                fi
                res=$?

                if [ $res != 0 ]; then
	            if [ $DLOG = on-failure ]; then
	                tail -100 $log
	            fi
	            elog generic module $step failed with error $res
	            return $res
                fi

                ########## POST module

                module-variant-wrapper $BDIR/$module/build/install $module \
                                       $variant post-$step || exit 1

                fn-exists module-post-$step

                if [[ $? = 0 ]]; then
                    cd $BDIR/$module

                    if [ $DLOG = yes ]; then
                        module-post-$step $BDIR/$module/build/install $module \
                                          $variant $TARGET $ISOOT | tee $log 2>&1
                    else
                        module-post-$step $BDIR/$module/build/install $module \
                                          $variant $TARGET $ISOOT >> $log 2>&1
                    fi
                fi
                res=$?

                if [ $res != 0 ]; then
	            if [ $DLOG = on-failure ]; then
	                tail -100 $log
	            fi
	            elog generic module post-$step failed with error $res
	            return $res
                fi
            done
        fi
    ) || exit 1

    #  Create binary archive if needed

    if [ $DOARCHIVE = yes ]; then
        cd $BDIR/$module/build >> $log 2>&1
        tar cf $module-bin.tar --directory=install .
        bzip2 -9 $module-bin.tar
    fi

    #  Finaly copy to given prefix
    SUDO=""

    fn-exists $module-$variant-prefix

    if [ $? = 0 -a "$DEFAULT_PREFIX" = "yes" ]; then
        IDIR=$($module-$variant-prefix)
    else
        fn-exists $module-prefix
        if [ $? = 0 -a "$DEFAULT_PREFIX" = "yes" ]; then
            IDIR=$($module-prefix)
        else
            IDIR=$PREFIX
        fi
    fi

    if [ ! -w $IDIR ]; then
        SUDO=sudo
    fi

    if [ "$DOINSTALL" = "yes" -a -d $BDIR/$module/build/install ]; then
	ilog build copy install into ..${IDIR/$BDIR/}
        $SUDO mkdir -p $IDIR/
        $SUDO rsync -a $BDIR/$module/$TARGET-$variant/install/. $IDIR/. > $log 2>&1
    fi || elog fail to copy to $IDIR

    echo
}

############################## body

set -- $(getopt -u -o t:adefSIuscbilnpPvrh \
    -l target:,no-setup,no-install,update,setup,config,build,build-target:,install,no-log,purge,purge-only,verbose,prefix:,tests,help,deps,archive,force,env,no-patch: -- "$@")

while [ $# -gt 0 ]; do
    case $1 in
	-h|--help)
            usage
            exit
	    ;;
	-f|--force)
            DOFORCE=yes
	    ;;
	-a|--archive)
            DOARCHIVE=yes
	    ;;
	-e|--env)
            ENV_NAME="-$2"
            if [ ! -f $HOME/.config/scbi/.scbi${ENV_NAME} ]; then
                echo "error: scbi environment $2 not found"
                exit 1
            fi
            shift
	    ;;
	-t|--target)
	    TARGET=$2; shift
            TARGET_SPECIFIED=yes
	    ;;
	-S|--no-setup)
	    STEPS=${STEPS/setup/}
	    ;;
	-I|--no-install)
            DOINSTALL=no
	    ;;
	-u|--update)
            DOUPDATE=yes
	    ;;
	-s|--setup)
	    NSTEPS="$NSTEPS setup"
	    ;;
	-c|--config)
	    NSTEPS="$NSTEPS config"
	    ;;
	-b|--build)
	    NSTEPS="$NSTEPS build"
	    ;;
	--build-target)
            BUILD_TARGET=$2; shift
	    ;;
	-d|--deps)
	    DEPS=yes
	    ;;
	-i|--install)
	    NSTEPS="$NSTEPS install"
            DOINSTALL=yes
	    ;;
	-l|--no-log)
	    DLOG=no
	    ;;
	-r|--tests)
	    NSTEPS="$NSTEPS tests"
	    ;;
	-v|--verbose)
	    DLOG=yes
	    ;;
	-p|--purge)
	    PURGE=yes
	    ;;
	-n|--no-patch)
	    PATCH=no
	    ;;
	--prefix)
            DEFAULT_PREFIX=no
	    PREFIX=$2; shift
	    ;;
	-P|--purge-only)
	    PURGE=only
	    ;;
        -j|--jobs)
            JOBS=$2; shift
            ;;
	(--)
	    ;;
	(*)
	    MODULES="$MODULES $1"
	    ;;
	(-*)
	    echo "$0: error - unrecognized option $1" 1>&2; exit 1
	    ;;
    esac
    shift
done

#  Nothing to build

[ "$MODULES" = "" ] && usage

#  Load user's settings if any

[ -f $HOME/.config/scbi/.scbi${ENV_NAME} ] &&
    source $HOME/.config/scbi/.scbi${ENV_NAME}

#  Load module definitions

[ ! -d "$DEFS" ] && DEFS=$HOME/.config/scbi

[ ! -d "$DEFS" ] && echo $0: cannot find module definition files && exit 1

#  If we have explicitly specified some steps, use them

if [ "$NSTEPS" != "" ]; then
    STEPS=$NSTEPS
fi

#  Then load any global settings, not overriding user's ones

for setup in $DEFS/[0-9]*; do
    source $setup
done

#  Prepare log dir

mkdir -p $LOGS

#  Run script for all modules

for module in $MODULES; do
    handle-module $module
done
