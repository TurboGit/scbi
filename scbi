#!/bin/bash
#
#  For all modules the following function can be implemented and are called
#  in this specific order:
#
#    <module>-vcs      parameter: NONE, return: array
#                      describe the VCS to get the sources
#                        1st item: protocole (git, svn)
#                        2nd item: URL
#
#    <module>-tar      parameter: $VERSION, return: array
#                      describe a way to get the sources as tarball
#                        1st item: protocole (scp, none)
#                        2st item: URL
#                        3st item: archive name (with $VERSION)
#
#    <module>-version  parameter: $PREFIX $TARGET, return: <installed version>
#                      returns the current version of the installed tool
#                      It can returns $VERSION_OK or $VERSION_ERROR if it
#                      is not possible to get the real version.
#
#    <module>-depends  parameter: NONE, return: array
#                      list all modules required. these are either
#                      source module handled by this script or a distrib
#                      package. each module is <name>:<version>
#
#    <module>-setup    parameter: $PREFIX $TARGET, return NONE
#                      to setup build structure (optional)
#
#    <module>-config   parameter: $PREFIX $TARGET, return NONE
#                      to configure, ./configure or other steps
#
#    <module>-build    parameter: $PREFIX $TARGET, return NONE
#                      to build, make
#
#    <module>-install  parameter: $PREFIX $TARGET, return NONE
#                      to install (in $PREFIX)
#
#    <module>-tests    parameter: $PREFIX $TARGET, return NONE
#                      to pass automatic tests
#
#  Note that all steps above are optional. And empty module will just do
#  nothing.
#
#  The final step is to install into the final location, the copy is done
#  by default.

CDPATH=

#  Environment
HOST=$(gcc -dumpmachine | sed -e 's/-pc//;s/-unknown//')
TARGET=$HOST
TARGET_SPECIFIED=no

#  General script setup
DLOG=on-failure
DEFS="$PWD"/scripts.d
JOBS=0

#  Modules to be handled and already handled
MODULES=
HANDLED=""

#  Actions setup
PURGE=no
NSTEPS=
PREFIX=
DEFAULT_PREFIX=yes
DOINSTALL=yes
DOUPDATE=no
DOARCHIVE=no
DEPS=no
ISOOT=no
STEPS="setup config build install"

############################## fn-exists

function fn-exists()
{
    declare -f $1 > /dev/null
}

############################## fn-exists

function check-handled()
{
    local module=$1
    local res=0

    if [ "${HANDLED/ $module/}" = "$HANDLED" ]; then
        HANDLED="$HANDLED $module"
        return 0
    else
        return 1
    fi
}

############################## module-wrapper

function module-wrapper()
{
    local PREFIX=$1
    module=$2
    step=$3

    log=$LOGS/$TARGET-$module-$step.log

    ilog $module $step starting

    (
        cd $BDIR/$module >> $log 2>&1

        #  Set cross-env is needed

        if [ "$HOST" != "$TARGET" ]; then
            target-env $BDIR/install $TARGET
        fi

        #  Go to build directory

        if [ "$step" = "setup" ]; then
            cd $BDIR/$module
        else
            cd $BDIR/$module/build/build
        fi

        #  Call module step

        if [[ $DLOG = yes || "$step" = "tests" ]]; then
	    $module-$step $PREFIX $TARGET | tee $log 2>&1
        else
	    $module-$step $PREFIX $TARGET >> $log 2>&1
        fi
        res=$?

        #  Check for errors

        if [ $res != 0 ]; then
	    if [ $DLOG = on-failure ]; then
	        tail -100 $log
	    fi
	    elog $module $step failed with error $res
	    return $res
        else
	    ilog $module $step completed
	    return 0
        fi
    )
}

############################## usage

function usage()
{
    local k=0

    echo
    echo $0 [options] module1 [module2 ... modulen]

    echo ""
    echo "   modulen  <name>:<ver>         build from tarbal version <ver>"
    echo "   modulen  <name>:<ver>:branch  build from repository version <ver>"
    echo "   modulen  <name>:dev           build from user's repository current branch"
    echo "   modulen  <name>               build from repository main branch"
    echo ""
    echo "   -h | --help         this help message"
    echo "   -t | --target name  specify the target to build for ($TARGET)"
    echo "   -S | --no-setup     skip setup"
    echo "   -I | --no-install   skip install"
    echo "   -u | --update       do update"
    echo "   -s | --setup        do setup"
    echo "   -c | --config       do config"
    echo "   -b | --build        do build"
    echo "   -i | --install      do install"
    echo "   -r | --tests        run the testsuite"
    echo "   -d | --deps         check/build dependencies"
    echo "   -a | --archive      build binary archive"
    echo "   -v | --verbose      display full log"
    echo "   -l | --no-log       never display log"
    echo "   -p | --purge        remove builds directories before building"
    echo "   -P | --purge-only   only remove builds directories"
    echo "   -j | --jobs         max compilation jobs"

    echo
    echo -n modules:

    for module in $DEFS/[^0-9]*; do
	echo -n " $(basename $module)"
	k=$(expr $k + 1)
	[ $k == 7 ] && k=0 && echo && echo -n "        "
    done
    echo

    exit 1
}

############################## handle-depends

function handle-depends()
{
    local modref=$1

    local name_ver=($(echo $modref | tr ":" " "))

    local module=${name_ver[0]}
    local version=${name_ver[1]}
    local branch=${name_ver[2]}

    #  If we want latest version, just handle this module

    if [ "$version" = "dev" ]; then
        handle-module $1
        return
    fi

    cd $ROOT

    #  If module not found, check for a possible distrib package

    if [ ! -f $DEFS/$module ]; then
        check-pkg $module:$version

        if [ $? = 0 ]; then
            return 0
        else
            echo No description for module $module &&
            echo And not found in the distrib  &&
            exit 1
        fi
    fi

    #  Check if the proper version is installed

    source $DEFS/$module

    fn-exists $module-version
    if [[ $? = 0 ]]; then
        pushd $(mktemp -d) > /dev/null 2>&1

        mver=$($module-version $PREFIX $TARGET)

        [ "${PWD:0:4}" = "/tmp" ] && rm -r $(pwd)

        popd > /dev/null 2>&1
    else
        mver=$VERSION_OK
    fi

    #  Clean-up the version number (only digits and a single dot)

    mver=$(get-version-number $mver)

    cd $ROOT

    [ "$version" = "" ] && version=0

    if [[ "$mver" = "" \
                || "$mver" = $VERSION_ERROR \
                || $version > $mver ]];
    then
        echo
        ilog build need building $module, \
             current version $(display-version $mver) | tee -a $log
        handle-module $modref
    else
        ilog build $modref found
    fi
}

############################## handle-module

function handle-module()
{
    local modref=$1

    #  Check for module version name:version:branch

    local name_ver=($(echo $modref | tr ":" " "))

    local module=${name_ver[0]}
    local version=${name_ver[1]}
    local branch=${name_ver[2]}

    log=$LOGS/$TARGET-$module-report.log

    #  Check if we have already handled this module

    check-handled $module
    if [[ $? = 1 ]]; then
        return
    fi

    cd $ROOT

    [ ! -f $DEFS/$module ] &&
        echo No description for module $module &&
        exit 1

    #  Then load module setup

    source $DEFS/$module

    #  Create module environment now

    mkdir -p $BDIR/$module/$TARGET > $log 2>&1

    #  Check meta-modules

    fn-exists $module-modules
    if [[ $? = 0 ]]; then
        (
            for module in $($module-modules); do
                handle-module $module
            done
        )
        return
    fi

    # Check for depends if any

    if [ $DEPS = yes ]; then
        fn-exists $module-depends
        if [[ $? = 0 ]]; then
            (
                for module in $($module-depends); do
                    handle-depends $module
                done
            )
            if [[ ! $? = 0 ]]; then
                exit 1
            fi
            echo
        fi
    fi

    clog $module

    #  If purge is asked, first remove current build structure

    if [ $PURGE = yes -o $PURGE = only ]; then
	ilog build Purging $module
        [ -d $BDIR/$module ] &&
            cd $BDIR/$module &&
            module-purge $BDIR/$module/install $TARGET
    fi

    [ $PURGE = only ] && exit 0

    ilog build Building $module for target $TARGET | tee -a $log
    ilog build steps : $STEPS | tee -a $log

    #  Log current enviroment

    env > $LOGS/$TARGET-$module-env.log
    echo "===============================================" \
	>> $LOGS/$TARGET-$module-env.log
    gnat ls -v >> $LOGS/$TARGET-$module-env.log 2> /dev/null
    which gcc >> $LOGS/$TARGET-$module-env.log 2> /dev/null

    # We need to remove the link/sources to ensure proper setting by the module

    [ -d $BDIR/$module ] && cd $BDIR/$module && rm -fr src local-vcs

    #  If building from tarball, extract it now

    if [ ! -z "$version" -a "$version" != "dev" -a -z "$branch" ]; then
        fn-exists $module-tar

        if [[ ! $? = 0 ]]; then
            echo "error: $module-tar function not defined, cannot get tarball"
            exit 1
        fi

        if [ $DOUPDATE = yes -o ! -d tarsrc ]; then
	    ilog build get sources from tar

            get-tar $module $version >> $log 2>&1

            if [[ ! $? = 0 ]]; then
                exit 1
            fi
        fi

        # We set the link for the source so that no module will have to do it

        ln -s tarsrc src
    else
        # Get sources from repository

        fn-exists $module-vcs

        if [[ $? = 0 ]]; then
            vcs=( $($module-vcs) )

            if [ $DOUPDATE = yes -o ! -d vcs ]; then
	        ilog build get sources from ${vcs[0]}

                get-vcs ${vcs[0]} ${vcs[1]} $module $version

                if [[ ! $? = 0 ]]; then
                    exit 1
                fi
            fi

            if [ "$version" = "dev" -a -d $GREPO/$module ]; then
                ln -s $GREPO/$module local-vcs
            fi

            ln -s vcs src
        fi

        #  If get-vcs is not defined then the $module-setup routine is in
        #  charge of creating/populating the src directory.
    fi

    #  Check if envrionment is to be done for out-of-tree build

    fn-exists $module-out-of-tree

    [ $? = 0 ] && [ $($module-out-of-tree) = "true" ] && ISOOT=yes

    #  Call module routines

    for step in $STEPS; do
        #  Apply module specific step if any

	fn-exists $module-$step

	if [[ $? = 0 ]]; then
	    module-wrapper $BDIR/$module/build/install $module $step || exit 1
	fi

        #  Apply any generic step (module-setup, module-purge)

        fn-exists module-$step

        if [[ $? = 0 ]]; then
            cd $BDIR/$module

            if [ $DLOG = yes ]; then
                module-$step $BDIR/$module/build/install $TARGET $ISOOT \
                    | tee $log 2>&1
            else
                module-$step $BDIR/$module/build/install $TARGET $ISOOT \
                    >> $log 2>&1
            fi
        fi
        res=$?

        if [ $res != 0 ]; then
	    if [ $DLOG = on-failure ]; then
	        tail -100 $log
	    fi
	    elog generic module $step failed with error $res
	    return $res
        fi
    done

    #  Create binary archive if needed

    if [ $DOARCHIVE = yes ]; then
        cd $BDIR/$module/build >> $log 2>&1
        tar cf $module-bin.tar --directory=install .
        bzip2 -9 $module-bin.tar
    fi

    #  Finaly copy to given prefix
    SUDO=""

    fn-exists $module-prefix

    if [ $? = 0 -a "$DEFAULT_PREFIX" = "yes" ]; then
        IDIR=$($module-prefix)
    else
        IDIR=$PREFIX
    fi

    if [ ! -w $IDIR ]; then
        SUDO=sudo
    fi

    if [ "$DOINSTALL" = "yes" -a -d $BDIR/$module/build/install ]; then
	ilog build copy install into ..${IDIR/$BDIR/}
        $SUDO rsync -a $BDIR/$module/build/install/. $IDIR/. > $log 2>&1
    fi

    echo
}

############################## body

set -- $(getopt -u -o t:adSIuscbilpPvrh \
    -l target:,no-setup,no-install,update,setup,config,build,install,no-log,purge,purge-only,verbose,prefix:,tests,help,deps,archive -- "$@")

while [ $# -gt 0 ]; do
    case $1 in
	-h|--help)
            usage
            exit
	    ;;
	-a|--archive)
            DOARCHIVE=yes
	    ;;
	-t|--target)
	    TARGET=$2; shift
            TARGET_SPECIFIED=yes
	    ;;
	-S|--no-setup)
	    STEPS=${STEPS/setup/}
	    ;;
	-I|--no-install)
            DOINSTALL=no
	    ;;
	-u|--update)
            DOUPDATE=yes
	    ;;
	-s|--setup)
	    NSTEPS="$NSTEPS setup"
	    ;;
	-c|--config)
	    NSTEPS="$NSTEPS config"
	    ;;
	-b|--build)
	    NSTEPS="$NSTEPS build"
	    ;;
	-d|--deps)
	    DEPS=yes
	    ;;
	-i|--install)
	    NSTEPS="$NSTEPS install"
            DOINSTALL=yes
	    ;;
	-l|--no-log)
	    DLOG=no
	    ;;
	-r|--tests)
	    NSTEPS="$NSTEPS tests"
	    ;;
	-v|--verbose)
	    DLOG=yes
	    ;;
	-p|--purge)
	    PURGE=yes
	    ;;
	--prefix)
            DEFAULT_PREFIX=no
	    PREFIX=$2; shift
	    ;;
	-P|--purge-only)
	    PURGE=only
	    ;;
        -j|--jobs)
            JOBS=$2; shift
            ;;
	(--)
	    ;;
	(*)
	    MODULES="$MODULES $1"
	    ;;
	(-*)
	    echo "$0: error - unrecognized option $1" 1>&2; exit 1
	    ;;
    esac
    shift
done

[ ! -d "$DEFS" ] && DEFS=$HOME/.scbi.d

[ ! -d "$DEFS" ] && echo $0: cannot find module definition files && exit 1

rm -f "$DEFS"/*~

[ "$MODULES" = "" ] && usage

#  If we have explicitly specified some steps, use them

if [ "$NSTEPS" != "" ]; then
    STEPS=$NSTEPS
fi

#  Load user's settings if any

[ -f $HOME/.scbi ] && source $HOME/.scbi

#  Then load any global settings, not overriding user's ones

for setup in $DEFS/[0-9]*; do
    source $setup
done

#  Prepare log dir

mkdir -p $LOGS

#  Run script for all modules

for module in $MODULES; do
    handle-module $module
done
