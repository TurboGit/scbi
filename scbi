#!/bin/bash
#
#  SCBI - (C) Pascal Obry - 2007-2025
#

shopt -s extglob

declare -gA SCBI_INI_DB

SCBI_VERSION=@VERSION@
SCBI_BINARY=$(realpath $0)

############################## do-clear-steps

function do-clear-steps()
{
    [[ $DO_SETUP   == yes ]] && DO_SETUP=no
    [[ $DO_CONFIG  == yes ]] && DO_CONFIG=no
    [[ $DO_BUILD   == yes ]] && DO_BUILD=no
    [[ $DO_INSTALL == yes ]] && DO_INSTALL=no
    [[ $DO_WRAPUP  == yes ]] && DO_WRAPUP=no
}

############################## check-tool

function check-tool()
{
    if [[ -z "$(command -v $1 2> /dev/null)" ]]; then
        return 1
    fi
    return 0
}

############################## check-tools

function check-tools()
{
    local res=0

    while [[ -n $1 ]]; do
        check-tool $1
        res=$(($res + $?))
        shift
    done
    return $res
}

############################## check-tools-abort

function check-tools-abort()
{
    local TOOLS="$*"

    local MISSING=""

    for T in $TOOLS; do
	check-tool $T
	[[ $? != 0 ]] && MISSING+=" $T"
    done

    [[ -n $MISSING ]] &&
	{
            echo Required tools${MISSING} missing, please install
            exit 1
	}

    return 0
}

############################## get-target-dir

declare -A FLATDIR=()
FTDIR=1

function get-target-dir()
{
    local -n _REF=$1
    local MODULE=$2
    local VARIANT=$3
    local FILE=$4

    local VAL=""
    local TDF=$SCBI_BDIR/$MODULE/$SCBI_TARGET-$VARIANT

    if [[ $DO_FLAT == yes ]]; then
        local KEY=$MODULE-$VARIANT
        VAL=${FLATDIR[$KEY]}

        if [[ -n $VAL ]]; then
            true
        elif [[ -h $TDF ]]; then
            VAL=$(realpath $TDF)
            FLATDIR+=( [$KEY]="${VAL}" )
        elif [[ -f $TDF$SCBI_LNK ]]; then
            get-ln VAL $TDF
            VAL=$(realpath $SCBI_BDIR/$MODULE/$VAL)
            FLATDIR+=( [$KEY]="${VAL}" )
        else
            while [[ -d $SCBI_BDIR/$FTDIR ]]; do
                (( FTDIR++ ))
            done
            VAL=$SCBI_BDIR/$FTDIR
            mkdir -p $SCBI_BDIR/$MODULE
            rm -fr $TDF
            ln -s ../$FTDIR $TDF
            FLATDIR+=( [$KEY]="${VAL}" )
        fi

    else
        VAL=$TDF

        [[ -h $TDF ]] &&
            rm -fr $(realpath $TDF) $TDF
        [[ -f $TDF$SCBI_LNK ]] &&
            {
                local RDIR=""
                get-ln RDIR $TDF
                rm -fr $(realpath $SCBI_BDIR/$MODULE/$RDIR) $TDF$SCBI_LNK
            }
    fi

    _REF=${VAL}${FILE:+/$FILE}
}

############################## ini-load-file

function ini-load-file()
{
    local INIFILE=$1

    local cur_section=""
    local cur_key=""
    local cur_val=""

    while read -r line; do
        #  First skip comments
        if [[ "$line" =~ ^[:space:]*\#(.*) ]]; then
            continue
        elif [[ "$line" =~ ^(\[)(.*)(\])$ ]]; then
            cur_section=${BASH_REMATCH[2]}

        elif [[ "$line" =~ ^([^=]+)=([^=]+)$ ]]; then
            cur_key="${BASH_REMATCH[1]// /}"
            cur_val="${BASH_REMATCH[2]%%+ }"

            [[ -z $cur_key ]] && continue

            db_key="${cur_section}${cur_section:+.}${cur_key}"

            case "$cur_key" in
                "enable"|"modules"|"options")
                    SCBI_INI_DB[$db_key]+="$cur_val "
                    ;;
                *)
                    # section + key is the associative in bash array, the
                    # field seperator is a dot.
                    SCBI_INI_DB[$db_key]="$cur_val"
                    ;;
            esac
        fi
    done < $INIFILE
}

function ini-load-files()
{
    [[ -f $HOME/.scbi ]] && ini-load-file $HOME/.scbi
    [[ -f .scbi ]] && ini-load-file .scbi
    [[ -f $SCBI_INI_FILE ]] && ini-load-file $SCBI_INI_FILE
}

############################## ini-apply-values

SCBI_INI_MODULES=()

function ini-set-enable()
{
    local FEATURES="$1"

    for F in ${FEATURES//,/ }; do
        export SCBI_${F//-/_}_SET=true
    done
}

function ini-get-option()
{
    local SECTION=$1
    local VAR=$2

    if [[ -n ${SCBI_INI_DB[$SECTION.$VAR]} ]]; then
        eval echo "${SCBI_INI_DB[$SECTION.$VAR]}"
    elif [[ -n $SECTION ]] && [[ -n ${SCBI_INI_DB[common.$VAR]} ]]; then
        eval echo "${SCBI_INI_DB[common.$VAR]}"
    elif [[ -n ${SCBI_INI_DB[$VAR]} ]]; then
        eval echo "${SCBI_INI_DB[$VAR]}"
    else
        echo -n ""
    fi
}

function ini-apply-values()
{
    local SECTION=$1

    local sec
    local var
    local val

    #  A table of value to be read in the ini file and the
    #  corresponding SCBI variable.

    declare -A KV=(
        ["build-dir"]="SCBI_BDIR"
        ["env"]="ENV_NAME"
        ["git-repo"]="SCBI_GIT_REPO"
        ["hg-repo"]="SCBI_HG_REPO"
        ["jobs"]="SCBI_JOBS"
        ["log"]="SCBI_LOGS"
        ["patch"]="SCBI_PATCH"
        ["plan"]="SCBI_PLAN"
        ["plugins"]="SCBI_PLUGINS"
        ["prefix"]="SCBI_PREFIX"
        ["root-dir"]="SCBI_ROOT"
        ["svn-repo"]="SCBI_SVN_REPO"
        ["archives"]="SCBI_ARCHIVES"
        ["target"]="SCBI_TARGET"
    )

    for K in ${!SCBI_INI_DB[*]}; do
        if [[ "$K" =~ ^([^\.]+)\.([^\.]+)$ ]]; then
            sec=${BASH_REMATCH[1]}
            var=${BASH_REMATCH[2]}
        else
            sec=""
            var=$K
        fi
        val=""

        #  If root/common section or selected section

        local _SKIP=",setup,config,build,install,wrapup,force,modules,stat,"
        local _SKIP+="update,purge,archive,deps,safe,tar,no-patch,enable,run,"

        if ( [[ -z $sec ]] && [[ -z $SECTION ]] ) ||
               ( [[ $sec == "common" ]] && [[ -n $SECTION ]] ) ||
               [[ $SECTION == $sec ]];
        then
            #  If this is a controlled variable (known in KV table)
            if [[ -n ${KV[$var]} ]]; then
                var=${KV[$var]}
                val=$(ini-get-option "$SECTION" $K)
                #  Record this ini setting only if not already set by
                #  command line.
                [[ -z ${CMDLINE_OPTS[$var]} ]] &&
                    CMDLINE_OPTS[$var]="$val"
                [[ $var == SCBI_PREFIX ]] &&
                    SCBI_DEFAULT_PREFIX=no
            else
                #  A free variable, just assign
                var=${var//-/_}
                val=$(eval echo ${SCBI_INI_DB[$K]})
            fi

            #  Value should not be null and variable not in _SKIP list as
            #  handled below.

            if [[ -n $val ]] && [[ ${_SKIP/,$var,//} == ${_SKIP} ]]; then
                export $var=$val
            fi
        fi
    done

    #  Set features if enabled

    local FEAT=$(ini-get-option "$SECTION" enable)

    if [[ -n $FEAT ]]; then
        ini-set-enable "$FEAT"
    fi

    #  Set modules' list

    SCBI_INI_MODULES=( $(ini-get-option "$SECTION" modules) )

    #  Set options controlled with a DO_<NAME>

    for OPTS in setup config build install wrapup color \
                      quiet force update purge archive stat;
    do
        local VAR=DO_${OPTS^^}
        local O=$(ini-get-option "$SECTION" $OPTS)
        [[ -n $O ]] && export $VAR=$O
    done

    #  Set other options

    for OPTS in safe tar no-patch clear-cache; do
        local O=$(ini-get-option "$SECTION" $OPTS)
        [[ ${O^^} == YES ]] &&
            SCBI_INI_OPTIONS+=( --$OPTS )
    done

    local O="$(ini-get-option "$SECTION" deps)"
    [[ -n ${O} ]] && DEPS=$O

    #  Run option

    local O="$(ini-get-option "$SECTION" run)"
    [[ -n ${O} ]] &&
        {
            DO_RUN=yes
            DO_RUN_CMD="$O"
            SCBI_INI_SUBCMD=shell
        }

    #  Tests option

    local O="$(ini-get-option "$SECTION" tests)"
    [[ -n ${O} ]] &&
        {
            DO_TEST=yes
            [[ $O == only ]] &&
                {
                    do-clear-steps
                    DO_TEST=yes-only
                }
        }

    local O="$(ini-get-option "$SECTION" tests-list)"
    [[ -n "${O}" ]] &&
        {
            SCBI_TESTS_OPTIONS="$O"
        }

    #  Finally whatever specific options are given

    SCBI_INI_OPTIONS+=( $(ini-get-option "$SECTION" options) )
}

CDPATH=

#  Environment

#  Setup host & Check for tools used by scbi itself

SCBI_IS_WINDOWS=no
SCBI_OS_MODULE=
SCBI_OS_MODULE_FILE=

check-tools-abort rsync sed diff

if [[ $(uname -a) =~ Cygwin ]]; then
    SCBI_IS_WINDOWS=yes
    SCBI_HOST=x86_64-cygwin
    SCBI_OS_MODULE=windows
elif [[ $(uname -a) =~ Msys ]]; then
    SCBI_IS_WINDOWS=yes
    SCBI_HOST=x86_64-mingw64
    SCBI_OS_MODULE=windows
else
    check-tools-abort gcc
    SCBI_HOST=$(gcc -dumpmachine | sed -e 's/-pc//;s/-unknown//')
fi

SCBI_TARGET=$SCBI_HOST
SCBI_TARGET_SPECIFIED=no
SCBI_ENV_DIR=
ENV_NAME=${SCBI_DEFAULT_ENV:+-$SCBI_DEFAULT_ENV}

#  General script setup
SCBI_DLOG=on-failure
SCBI_PLUGINS="$PWD/scripts.d"
SCBI_JOBS=${SCBI_JOBS:-$(grep -c ^processor /proc/cpuinfo 2>/dev/null || sysctl -n hw.ncpu)}
SCBI_HALF_JOBS=${SCBI_HALF_JOBS:-$((SCBI_JOBS / 2))}

#  Modules to be handled and already handled
SCBI_MODULES=()
SCBI_HANDLED="$(mktemp -p /dev/shm/)"
SCBI_CURRENT_MODULE=

#  Actions setup
DO_PURGE=no
SCBI_PREFIX=
SCBI_DEFAULT_PREFIX=yes
DO_QUIET=no
DO_UPDATE=no
DO_ARCHIVE=no
DO_FORCE=no
DO_STAT=no
DO_FLAT=no
DO_DEPS=no
DO_CLEAN_INSTALL=no
DO_PLAN=no
DO_SUBCMD=no
DO_CLEAR_CACHE=no
DEPS=no
SCBI_ISOOT=true
DO_PATCH=yes
STEPS=""
BUILD_SCBI_TARGET=
SCBI_PLAN=
ARCHIVE_CACHE=yes
DRY_RUN=no
SAFE_MODE=no
SCBI_LNK=
DO_STANDALONE=no
DO_HELP=no
DO_VERSION=no
DO_SHELL=no
DO_RUN=no
DO_RUN_CMD=
DO_WARNING_EXTERNAL=no
SCBI_TESTS_OPTIONS=

DO_COLOR=no
SCBI_CBOLD=""
SCBI_CTEXT=""
SCBI_CCLEAR=""
SCBI_CRED=""
SCBI_CGREEN=""
SCBI_CBLUE=""

DO_SETUP=yes
DO_CONFIG=yes
DO_BUILD=yes
DO_INSTALL=yes
DO_TEST=no
DO_WRAPUP=yes

export SCBI_ROOT SCBI_BDIR SCBI_CLANG_VERSION SCBI_GTK_VERSION SCBI_PLAN
export SCBI_HOST SCBI_TARGET SCBI_PLUGINS SCBI_JOBS SCBI_HALF_JOBS
export SCBI_IS_WINDOWS SCBI_VERSION SCBI_BINARY SCBI_OS_NAME SCBI_OS_VERSION
export SCBI_CURRENT_MODULE SCBI_ENV_DIR SCBI_ISOOT
export SCBI_CBOLD SCBI_CRED SCBI_CGREEN SCBI_CBLUE SCBI_CCLEAR SCBI_CTEXT

############################## check-handled
#
# check whether a module has already been handled

function check-handled()
{
    local KEY=$1

    grep "^$KEY" $SCBI_HANDLED &> /dev/null

    if [[ $? = 1 ]]; then
        echo "$KEY" >> $SCBI_HANDLED
        return 0
    else
        return 1
    fi
}

############################## clean-up
#
# clean-up before exit

function clean-up()
{
    rm -f $SCBI_HANDLED
    rm -f $SCBI_LINE_SEP
}

############################## load-module-env
#
# load an environment description, this cannot be in 5_tools as an
# envrionment script must be loaded before any other.

function load-module-env()
{
    local ENAME=env${1:+-}$1
    local ENV=$PWD/.scbi-$ENAME

    # if not found in current directory look in definitions install dir

    if [[ ! -f $ENV ]]; then
        # look for it in parent directory too
        ENV=$PWD/../.scbi-$ENAME

        if [[ ! -f $ENV ]]; then
            # look for it in $HOME directory too
            ENV=$HOME/.scbi-$ENAME

            if [[ ! -f $ENV ]]; then
                ENV=$SCBI_PLUGINS/.$ENAME
            fi
        fi
    fi

    if [[ -f $ENV ]]; then
        SCBI_ENV_DIR=$(dirname $ENV)
        source $ENV
    elif [[ -n $1 ]]; then
        echo build environment .$ENAME not found
        exit 1
    fi
}

############################## module-wrapper
#
# called for each module and step

function module-wrapper()
{
    local PREFIX=$1
    local MODULE=$2
    local VARIANT=$3
    local STEP=$4

    local dvariant=""

    #  set variant display if not part of step and not default

    if [[ ${STEP/$VARIANT/} == $STEP && "$VARIANT" != "default" ]]; then
        dvariant=" [${VARIANT//./ }]"
    fi

    if [[ $STEP = "build" ]] && [[ -n $BUILD_SCBI_TARGET ]]; then
        mstep=build-$BUILD_SCBI_TARGET
    else
        mstep=$STEP
    fi

    #  global logs
    local log=$SCBI_LOGS/$TODAY/$SCBI_TARGET-$MODULE-$VARIANT-$mstep.log

    local TVDIR=""
    get-target-dir TVDIR $MODULE $VARIANT

    #  local log for last module command
    local mlog=$TVDIR/logs/$mstep.log
    local clog=$TVDIR/logs/$mstep.cmd

    ilog $MODULE $mstep$dvariant starting

    (
        cd $SCBI_BDIR/$MODULE >> $log 2>&1

        #  Go to build directory, if not out of tree build go to src

        local BUILDDIR=build
        [[ $SCBI_ISOOT == false ]] && BUILDDIR=src

        if [[ "$STEP" =~ (pre-|post-)*(setup|wrapup)$ ]]; then
            cd $SCBI_BDIR/$MODULE
        elif [[ -d $TVDIR/$BUILDDIR ]]; then
            cd $TVDIR/$BUILDDIR
        else
            #  a native module has no sources for example
            cd $SCBI_BDIR/$MODULE
        fi

        #  Record run command

        show-command $MODULE $MODULE-$mstep \
                     $PREFIX $SCBI_TARGET $VARIANT 2&> $clog

        #  Call module step

        local res=0

        local IS_TESTS=no
        local TEST_OPTS=

        if [[ "$STEP" =~ "tests" ]]; then
            IS_TESTS=yes
            TESTS_OPTS="$SCBI_TESTS_OPTIONS"
        fi

        if [[ $SCBI_DLOG = yes ]] || [[ "$IS_TESTS" = "yes" ]]; then
            $MODULE-$mstep $PREFIX $SCBI_TARGET $VARIANT "$TESTS_OPTS" 2>&1 \
                | tee -a $log | tee $mlog
            #  We want the status of the first command and not the tee ones
            res=${PIPESTATUS[0]}
        else
            {
                PS4="_TRACE: "
                set -o xtrace
                $MODULE-$mstep $PREFIX $SCBI_TARGET $VARIANT
                res=$?
                set +o xtrace
                return $res
            } 2>&1 | tee $mlog &>> $log
            res=${PIPESTATUS[0]}
        fi

        #  Check for errors

        if [[ $res -ne 0 ]]; then
            if [[ $SCBI_DLOG = on-failure ]] && [[ "$STEP" != "tests" ]]; then
                tail -100 $mlog | grep -v "^_[_]*TRACE: "
            fi
            elog $MODULE $mstep failed with error $res

            local RDIR=$TVDIR/logs

            case $STEP in
                *config|*build|*install|*cross-config|*cross-build|*cross-install)
                    elog $MODULE to reproduce:
                    elog $MODULE bash $RDIR/$mstep.cmd
                    elog $MODULE use bash -x option for debug
                    ;;
            esac

            return $res
        else
            ilog $MODULE $mstep$dvariant completed
            return 0
        fi
    )
    return $?
}

############################## module-variant-wrapper
#
# called for each module, variant and step, switch to proper step to call
# depending on the existence of the variant.

function _internal_module-variant-wrapper()
{
    local PREFIX=$1
    local MODULE=$2
    local VARIANT=$3
    local FCT=$4

    [[ -z $FCT ]] && return

    #  Now check that the body is not empty (default variant)
    local BODY=$(declare -f $FCT | tail --lines=-3)
    local BODY=$(echo $BODY)
    local res=0

    if [[ "$BODY" != "{ true }" ]]; then
        module-wrapper $PREFIX $MODULE \
                       $VARIANT ${FCT#"${MODULE}-"} || exit 1
        res=$?
    fi
    return $res
}

function module-variant-wrapper()
{
    local PREFIX=$1
    local MODULE=$2
    local VARIANT=$3
    local STEP=$4

    local FCT=""
    get-hook FCT $MODULE $VARIANT $STEP

    if [[ -n $FCT ]]; then
        _internal_module-variant-wrapper $PREFIX $MODULE $VARIANT $FCT
    fi
}

############################## usage

function usage()
{
    echo
    echo SCBI $SCBI_VERSION
    echo
    echo $0 [options] module1 [module2 ... modulen]

    echo ""
    echo "   modulen  <name>           build from repository main branch"
    echo "   modulen  <name>/<variant> build <variant> from repository version"
    echo "   modulen  <name>:<branch>  build from repository version <branch>"
    echo "   modulen  <name>:#<ver>    build from tarbal version <ver>"
    echo "   modulen  <name>:dev       build from user's repository current branch"
    echo ""
    echo "   -h | --help              this help message"
    echo "   -v | --version           display driver & plug-ins versions"
    echo "   -q | --quiet             do not display information log"
    echo "      | --color:[n]         use colored output (no, dark, light)"
    echo "      | --ini=<section>     load ini file given section"
    echo "   -t | --prefix=<dir>      the global install directory"
    echo "      | --build-dir=<dir>   the root build directory."
    echo "      | --flat              use a flatter directory structure"
    echo "   -e | --env=<name>        environment file ~/.scbi-<name>"
    echo "      | --plan=<name>       a build plan for modules"
    echo "      | --enable-<name>     enable feature name"
    echo "   -t | --target=<name>     the target to build for ($SCBI_TARGET)"
    echo "      | --plugins=<dir>     specify the modules/plugins directory"
    echo "   -j | --jobs=<n>          max compilation jobs, set \$SCBI_JOBS"
    echo "   -S | --no-setup          skip setup"
    echo "   -I | --no-install        skip install"
    echo "   -W | --no-wrapup         skip wrapup"
    echo "   -u | --update            do update"
    echo "   -s | --setup             do setup"
    echo "   -c | --config            do config"
    echo "   -b | --build             do build"
    echo "   -i | --install           do install"
    echo "   -w | --wrapup            do wrapup"
    echo "      | --clean-install     clean installation directory"
    echo "      | --archive           check for archive only if explicitly specified"
    echo "      | --tests[:only][=O]  run the testsuite, eventually build"
    echo "   -d | --deps[:warning]    check/build dependencies"
    echo "   -a | --create-archive    build binary archive"
    echo "      | --standalone        create a standalone source archive"
    echo "   -l | --log:n             log display control yes|no|on-failure"
    echo "   -f | --force             force rebuild, do not check build id"
    echo "   -p | --purge[:only]      remove build directory, build eventually"
    echo "      | --safe              clean-up build directory before configure"
    echo "      | --dry-run           only list modules handled"
    echo "      | --stat[:short|full] display some status of current setup"
    echo "   -n | --no-patch          do not apply patches"
    echo "      | --clear-cache       remove cached module's versions"
}

############################## handle-modue-env
#
# call module ENV, checking for variant

SCBI_ENV_MODULE=

function handle-module-env()
{
    local FORMODULE=$1
    local MODREF=$2
    local ENV=$3

    #  Get module information

    local module_info=()
    get-module-ref module_info $MODREF $FORMODULE

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local ref=${module_info[3]}

    [[ "$ref" == "skip" ]] && return 0

    if [[ -n $SCBI_ENV_MODULE ]]; then
        {
            echo
            echo "# $MODREF"
        } >> $SCBI_ENV_MODULE

        local TVDIR=""
        get-target-dir TVDIR $module $variant

        local BUILDDIR=build
        [[ $SCBI_ISOOT == false ]] && BUILDDIR=src

        SCBI_MODULES_DIR["$module"]="$TVDIR/install"
        SCBI_MODULES_DIR["${module}@src"]="$TVDIR/src"
        SCBI_MODULES_DIR["${module}@build"]="$TVDIR/$BUILDDIR"
    fi

    plugin-call-env-hooks $FORMODULE $MODREF $ENV
}

############################## handle-env
#
# recursively set the environment for the module based on the dependencies

function handle-env-callback()
{
    local FORMODULE=$1
    local MODREF=$2
    local LEVEL=$3
    local DEPENDS_KIND=$4
    local IS_EXT=$5
    local IS_META=$6
    local IS_AGGREGATED=$7

    #  Nothing to do for aggregated module as the env has already been
    #  set as part of the aggregate module.

    [[ $IS_AGGREGATED == true ]] && return

    #  Only the environment of the dependencies and not self. The env
    #  hook of a module is only used for clients and not for the module
    #  itself.

    [[ $LEVEL -ge 1 ]] ||
        [[ $DEPENDS_KIND == tests ]] ||
        is-meta-module $FORMODULE > /dev/null &&
        {
            handle-module-env $FORMODULE $MODREF env
        }
}

function handle-env()
{
    local FORMODULE=$1
    local MODREF=$2

    for-all-modules-depends-with-meta handle-env-callback $MODREF
}

function handle-build-depends-env()
{
    local FORMODULE=$1
    local MODREF=$2

    for-all-modules-build-depends-with-meta handle-env-callback $MODREF
}

function handle-tests-depends-env()
{
    local FORMODULE=$1
    local MODREF=$2

    for-all-modules-tests-depends-with-meta handle-env-callback $MODREF
}

############################## is-module-up-to-date

function is-module-up-to-date()
{
    local MODREF=$1
    local FORMODULE=$2

    local module_info=()
    get-module-ref module_info $MODREF $FORMODULE

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    load-module $MODREF

    check-archive-exists $module $variant $ref
    [[ $? == 0 ]] && kind=VERSION

    local mver=$VERSION_ERROR

    #  Get the version hook, if none present all versions are ok

    local FCT=""
    get-hook FCT $module $variant version

    if [[ -n $FCT ]]; then
        TDIR=$(mktemp -d)

        [[ $? != 0 ]] &&
            echo cannnot create a temp directory &&
            exit 1

        pushd $TDIR > /dev/null 2>&1

        mver=$( handle-build-depends-env "@root" $MODREF
                handle-module-env "@root" $MODREF env
                handle-module-env "@root" $MODREF build-env
                $FCT $SCBI_PREFIX $SCBI_TARGET
              )

        popd > /dev/null 2>&1

        rm -r $TDIR
    else
        mver=$VERSION_OK
    fi

    local SID=""

    if [[ $variant == "native" ]]; then
        #  A native variant
        SID="native-$ref"
    elif [[ -e $SCBI_BDIR/$module/src$SCBI_LNK ]]; then
        #  A VCS or TAR
        case "$kind" in
            NONE|BRANCH)
                SID="vcs-$ref"
                ;;
            VERSION)
                SID="archive-$ref"
                ;;
            DEV)
                SID="$ref"
                ;;
        esac
    else
        #  No sources
        SID="none-$ref"
    fi

    local rsid=1

    #  If we have a source-id check if the content corresponds to SID

    [[ -f $SCBI_BDIR/$module/source-id ]] &&
        [[ "$(cat $SCBI_BDIR/$module/source-id)" == $SID ]] &&
            rsid=0

    #  Clean-up the version number (only digits and a single dot)

    get-version-number mver $mver

    if [[ "${ref^^}" = "NONE" ]]; then
        ref=0
    else
        get-version-number ref $ref
    fi

    local rbid=0

    local TVDIR=""
    get-target-dir TVDIR $module $variant

    if [[ $DO_FORCE = yes ]]; then
        rm -f $TVDIR/build-id
        rbid=1
    else
        #  Check build id, only rebuild if mismatch

        diff -q $SCBI_BDIR/$module/build-id-$variant \
             $TVDIR/build-id > /dev/null 2>&1
        rbid=$?
    fi

    check-versions "$ref" ">" "$mver"
    local cver=$?

    if [[ $rbid -gt 0 ]]                  ||
           [[ $rsid -gt 0 ]]              ||
           [[ -z $mver ]]                 ||
           [[ "$mver" = $VERSION_ERROR ]] ||
           [[ $cver == 0 ]];
    then
        # Rebuild needed, $? = 1
        false
    else
        # Rebuild not needed, $? = 0
        true
    fi
}

############################## handle-depends
#
# check for module dependencies, handle them if build scripts found for
# them. Also check for distrib packages if exists.

function handle-depends()
{
    local FORMODULE=$1
    local MODREF=$2

    local module_info=()
    get-module-ref module_info $MODREF $FORMODULE

    if [[ -n ${module_info[4]} ]]; then
        module_info[1]=""
        module_info[2]=""
        module_info[3]=""
        elog ${module_info[@]}
        exit 1
    fi

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    #  Check if module exists

    local IS_MODULE=no

    [[ -f $SCBI_PLUGINS/$module ]] && local IS_MODULE=true

    #  Before anything check if we need to skip this dependency

    if [[ "$ref" == "skip" ]]; then
        if [[ $IS_MODULE == true ]]; then
            ilog $module %BModule %t$module%c marked to be skipped
        else
            ilog $module %BDependency %t$module%c marked to be skipped
        fi
        return
    fi

    #  If we want latest version, just handle this module

    if [[ "$kind" = "DEV" ]]; then
        handle-module $FORMODULE $MODREF
        return
    fi

    cd $SCBI_ROOT

    local formodule_info=()
    get-module-ref formodule_info $FORMODULE
    fmodule=${formodule_info[0]}
    fvariant=${formodule_info[1]}

    #  If module not found, check for a possible distrib package

    if [[ $IS_MODULE == no ]]; then
        MES=$(check-pkg $module:$ref)

        if [[ $? = 0 ]]; then
            return 0
        else
            local MNAME=$fmodule
            [[ $fvariant != "default" ]] && MNAME="$MNAME/$fvariant"

            local MSG="error"
            [[ $DO_WARNING_EXTERNAL == yes ]] && MSG="warning"

            echo "$MSG: missing dependencies for building $MNAME"

            local IDX=${#SCBI_MODULES_LIST[*]}
            (( IDX-- ))

            while [[ $IDX -gt 0 ]]; do
                (( IDX-- ))
                local MNAME=${SCBI_MODULES_LIST[$IDX]}
                echo "$MSG    required by $(get-module-name $MNAME)"
            done

            for dmodule in $(get-all-depends $fmodule $fvariant build-depends); do
                [[ ! -f $SCBI_PLUGINS/$dmodule ]] && check-pkg $dmodule
            done

            for dmodule in $(get-all-depends $fmodule $fvariant depends); do
                [[ ! -f $SCBI_PLUGINS/$dmodule ]] && check-pkg $dmodule
            done

            [[ $DO_TEST != no ]] &&
                {
                    for dmodule in \
                        $(get-all-depends $fmodule $fvariant tests-depends);
                    do
                        [[ ! -f $SCBI_PLUGINS/$dmodule ]] && check-pkg $dmodule
                    done
                }

            if [[ $DO_WARNING_EXTERNAL == yes ]]; then
                false
                return 0
            else
                return 1
            fi

        fi
    fi

    handle-module $fmodule $MODREF
}

############################## handle-sources
#
#  get the module sources from a tar or a vcs
#

function handle-sources()
{
    local FORMODULE=$1
    local MODREF=$2

    #  Get module information

    local module_info=()
    get-module-ref module_info $MODREF $FORMODULE

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    [[ "$variant" = "native" ]] &&
        {
            echo -n "native-$ref" > source-id
            echo "$module none native revision $ref" > source-ref
            return 0;
        }

    rm -f source-ref

    #  Check if a given archive exists even if a standard branch ref has
    #  been provided. This is an optimization to used a local archive
    #  instead of a repository branch.

    if [[ $kind == BRANCH ]] && [[ "$ARCHIVE_CACHE" == "yes" ]]; then
        check-archive-exists $module $variant $ref
        [[ $? == 0 ]] && kind=VERSION
    fi

    local HASSRC=yes

    #  If building from archive, extract it now

    if [[ $kind == VERSION ]]; then
        local tar=( $(get-archive-data $module $variant $ref) )
        local nv=${#tar[*]}

        if [[ $nv == 0 ]]; then
            echo "error: $module-archive function not defined, cannot get archive"
            exit 1
        fi

        if [[ $nv != 6 ]]; then
            local V=${tar[0]}
            if [[ $V == default ]]; then
                V=""
            else
                V+="-"
            fi
            local nv=$(( $nv - 1 ))
            echo "error: $module-${V}archive function returned $nv values, 5 expected"
            exit 1
        fi

        tarsrc=${tar[5]}

        [[ ${tarsrc^^} == NONE ]] && HASSRC=no

        #  We need to extract the archive if the version does not match
        #  the one currently extracted.

        if [[ -f source-id ]]; then
            if [[ "$(cat source-id)" != "archive-$ref" ]] ||
                   [[ $HASSRC == no ]];
            then
                rm -fr archive-src
            fi
        fi

        if [[ $HASSRC == yes ]]; then
            if [[ $DO_UPDATE = yes ]] || [[ ! -d archive-src ]] || [[ ! -e archive$SCBI_LNK ]]; then
                V=${tar[0]#default}
                ilog $module get sources from archive ${V:+[$V]}

                get-archive $module $variant $ref 2>>$log | tee -a $log
                res=${PIPESTATUS[0]}

                if [[ $res != 0 ]]; then
                    #  In case of error display log from get-archive
                    grep FAILED $log
                    ilog $module cannot get/find/extract archive sources
                    exit 1
                fi
            fi

            echo -n "archive-$ref" > source-id

            #  Compute and store the version id of the sources. This includes the
            #  tar sha1 if present to ensure a tar with the same name but different
            #  content will trigger a build.

            local archive_sha1="NONE"
            [[ -e archive-sha1$SCBI_LNK ]] &&
                {
                    get-ln sha1file archive-sha1
                    archive_sha1=$(cat $sha1file)
                    archive_sha1=${archive_sha1// */}
                }
            echo "$module archive $ref sha-1 ${archive_sha1// */}" \
                 > source-ref

            get-build-id $SCBI_PREFIX $SCBI_TARGET \
                         $FORMODULE $MODREF archive-$ref$archive_sha1 \
                         > build-id-$variant

            #  We set the link for the source so that no module will have to
            #  do it.

            ln -s archive-src src
        fi
    else
        #  Get sources from repository

        local vcs=( $(get-vcs-data $module $variant) )

        local nv=${#vcs[*]}

        if [[ $nv != 0 ]] && [[ $nv != 5 ]] && [[ $nv != 6 ]]; then
            local V=${vcs[0]}
            if [[ $V == default ]]; then
                V=""
            else
                V+="-"
            fi
            local nv=$(( $nv - 1 ))
            echo "error: $module-${V}vcs function returned $nv values, 4 or 5 expected"
            exit 1
        fi

        local VCS_NAME=${vcs[3]}
        local VCS_URL=${vcs[4]}

        if [[ $nv > 0 ]] && [[ "${VCS_NAME^^}" != "NONE" ]]; then
            REPO=$(basename $VCS_URL .git)

            if [[ $kind = DEV ]]; then
                local SCBI_VCS_REPO=""
                get-vcs-user-co-dir SCBI_VCS_REPO $module $VCS_NAME

                [[ $SCBI_VCS_REPO == NONE ]] &&
                    {
                        elog $MODULE unsupported VCS $VCS_NAME
                        exit 1
                    }

                if [[ -d $SCBI_VCS_REPO/$REPO ]]; then
                    ln -s $SCBI_VCS_REPO/$REPO vcs

                    #  Compute and store the version id of the sources +
                    #  compiler. That is when the compiler is changed we
                    #  want to rebuild the software.

                    echo -n "$ref" > source-id

                    local VCSDIR=""
                    get-ln VCSDIR vcs

                    vcs-build-id $SCBI_PREFIX $SCBI_TARGET \
                                 $FORMODULE $MODREF $VCSDIR \
                                 > build-id-$variant

                else
                    ilog $module cannot find local dev repository:
                    ilog $module $SCBI_VCS_REPO/$REPO
                    exit 1
                fi

            else
                if [[ $DO_TEST != "yes-only" ]]; then
                    if [[ -f source-id ]]; then
                        if [[ "$(cat source-id)" != "vcs-$ref" ]]; then
                            # a different version is needed
                            DO_UPDATE=yes
                        fi
                    else
                        DO_UPDATE=yes
                    fi
                fi

                if [[ $DO_UPDATE = yes ]] || [[ ! -d ../.vcs/$REPO ]]; then
                    V=${vcs[0]#default}
                    ilog $module get sources from $VCS_NAME ${V:+[$V]}

                    get-vcs $SCBI_PREFIX $SCBI_TARGET $FORMODULE $MODREF

                    if [[ $? != 0 ]]; then
                        exit 1
                    fi
                else
                    ln -s ../.vcs/$REPO vcs
                fi

                echo -n "vcs-$ref" > source-id

                #  Compute and store the version id of the sources +
                #  compiler. That is when the compiler is changed we
                #  want to rebuild the software.

                local VCSDIR=""
                get-ln VCSDIR vcs

                vcs-build-id $SCBI_PREFIX $SCBI_TARGET \
                             $FORMODULE $MODREF $VCSDIR \
                             > build-id-$variant
            fi

            if [[ ! -e src$SCBI_LNK ]]; then
                #  Setting source reference, note that for Subversion this
                #  need to properly set the link to the directory in the vcs.
                #  This action is done by svn-branch that we call here.

                case $VCS_NAME in
                    svn|subversion)
                        svn-branch "" "" $module $ref ""
                        ;;
                    *)
                        ln -s vcs src
                        ;;
                esac
            fi

            echo -n "$module " > source-ref
            get-vcs-ref $VCS_NAME $ref $(pwd)/vcs >> source-ref

            return 0

        else
            HASSRC=no
        fi

        #  If get-vcs is not defined then the $module-setup routine is in
        #  charge of creating/populating the src directory.
    fi

    [[ $HASSRC == no ]] &&
        {
            echo -n "none-$ref" > source-id
            echo $module none $variant revision $ref >> source-ref

            #  No VCS, no TAR, just rebuild the sources if present
            if [[ ! -d src ]]; then
                ilog $module "no sources (vcs or tar)"

                get-build-id $SCBI_PREFIX $SCBI_TARGET \
                             $FORMODULE $MODREF "$variant" \
                             > build-id-$variant
            else
                get-build-id $SCBI_PREFIX $SCBI_TARGET \
                             $FORMODULE $MODREF "$(date)" \
                             > build-id-$variant
            fi
        } || true
}

############################## needed-by

function needed-by()
{
    local MODULE=$1

    [[ ${#SCBI_MODULES_LIST[@]} -gt 1 ]] &&
        {
            ilog $MODULE "needed by:"
            for (( i=${#SCBI_MODULES_LIST[@]}-2 ; i>=0 ; i-- )); do
                ilog $MODULE "  ↳ ${SCBI_MODULES_LIST[$i]}"
            done
        }
}

############################## handle-meta-module

function handle-meta-module()
{
    local FORMODULE=$1
    local METAMODULE=$2
    local VARIANT=$3

    #  check for plan

    local FCT=""
    get-hook FCT $METAMODULE $VARIANT plan

    [[ -n $FCT ]] &&
        load-module-plan $($FCT $SCBI_PLAN)

    record-build-plan $METAMODULE $VARIANT

    #  check for dependencies

    [[ $DEPS == yes ]] &&
        for dmodule in $(get-all-depends $METAMODULE $VARIANT build-depends); do
            handle-depends $METAMODULE $dmodule || exit 1
        done

    #  check for setup

    local FCT_SETUP=""
    get-hook FCT_SETUP $METAMODULE $VARIANT setup

    local FCT_WRAPUP=""
    get-hook FCT_WRAPUP $METAMODULE $VARIANT wrapup

    local FCT_AGG=""
    get-hook FCT_AGG $METAMODULE $VARIANT aggregate

    line-sep
    ilog $METAMODULE %BMetamodule %t$METAMODULE%c \[%g${VARIANT//./ }%c\] setup \
        | tee -a $log

    [[ $FORMODULE != "@root" ]] &&
        needed-by $FORMODULE | tee -a $log

    _internal_module-variant-wrapper $SCBI_BDIR/install \
                                     $METAMODULE $VARIANT $FCT_SETUP || exit 1
    ilog $METAMODULE End metamodule $METAMODULE \[${VARIANT//./ }\] setup \
        | tee -a $log
    line-sep

    [[ $DEPS == yes ]] || ( [[ -z $FCT_SETUP ]] && [[ -z $FCT_WRAPUP ]] ) &&
        {
            local MDIR=$SCBI_BDIR/$METAMODULE
            rm -f $MDIR/source-ref

            local TVMDIR=""
            get-target-dir TVMDIR $METAMODULE $VARIANT

            function do-sync()
            {
                local FORMODULE=$1
                local MODREF=$2
                local LEVEL=$3
                local DEPENDS_KIND=$4
                local IS_EXT=$5
                local IS_META=$6
                local IS_AGGREGATED=$7

                local smodule_info=()
                get-module-ref smodule_info $MODREF $FORMODULE

                local module=${smodule_info[0]}
                local variant=${smodule_info[1]}

                local IDIR=""
                get-target-dir IDIR $module $variant install

                [[ -d $IDIR ]] &&
                    sync-dir $IDIR $TVMDIR/.

                cat $SCBI_BDIR/$module/source-ref \
                    >> $MDIR/source-ref
            }

            #  Clean aggregate meta module install. Do this unconditionally
            #  to cover the case of an aggregate meta module being changed
            #  to a standard meta module.

            rm -fr $TVMDIR/install

            for module in $(plugin-call-variant-hooks \
                                $METAMODULE modules \
                                $SCBI_PREFIX $SCBI_TARGET $VARIANT);
            do
                handle-module $METAMODULE $module || exit 1

                local module_info=()
                get-module-ref module_info $module $METAMODULE

                local variant=${module_info[1]}

                if [[ -n $FCT_AGG  ]]; then
                    local AGG_MODE=$($FCT_AGG $SCBI_PREFIX $TARGET $VARIANT)
                    local IDIR=""
                    get-target-dir IDIR $module $variant install

                    if [[ $AGG_MODE != no ]] && [[ -d $IDIR ]]; then
                        if [[ $AGG_MODE == recursive ]]; then
                            for-all-modules-depends-with-meta do-sync $module
                        else
                            sync-dir $IDIR $TVMDIR/.
                        fi
                    fi

                    cat $SCBI_BDIR/$module/source-ref \
                        >> $MDIR/source-ref
                fi
            done
        }

    #  check for wrapup

    line-sep
    ilog $METAMODULE %BMetamodule %t$METAMODULE%c \[%g${VARIANT//./ }%c\] wrapup \
        | tee -a $log

    [[ $FORMODULE != "@root" ]] &&
        needed-by $FORMODULE | tee -a $log

    _internal_module-variant-wrapper $SCBI_BDIR/install \
                                     $METAMODULE $VARIANT $FCT_WRAPUP || exit 1
    ilog $METAMODULE End metamodule $METAMODULE \[${VARIANT//./ }\] wrapup \
        | tee -a $log
    line-sep
}

############################## record-module-env

function record-module-env()
{
    local MODULE=$1
    local VARIANT=$2

    local ENVLOG=$SCBI_LOGS/$TODAY/$SCBI_TARGET-$MODULE-$VARIANT-env.log

    echo "==================== env " > $ENVLOG
    env >> $ENVLOG

    [[ -n $(command -v gprls 2> /dev/null) ]] &&
        {
            echo "==================== gprls " >> $ENVLOG
            gprls -v 2>&1 >> $ENVLOG
        }

    [[ -n $(command -v gcc 2> /dev/null) ]] &&
        {
            echo "==================== gcc " >> $ENVLOG
            gcc -v &>> $ENVLOG
        }
}

############################## handle-module

function handle-module()
{
    local FORMODULE=$1
    local MODREF=$2

    #  Get module information

    local module_info=()
    get-module-ref module_info $MODREF $FORMODULE

    if [[ -n ${module_info[4]} ]]; then
        module_info[1]=""
        module_info[2]=""
        module_info[3]=""
        elog ${module_info[@]}
        exit 1
    fi

    local module=${module_info[0]}
    local variant=${module_info[1]}
    local kind=${module_info[2]}
    local ref=${module_info[3]}

    SCBI_CURRENT_MODULE=$module

    #  If already handled, nothing more to do

    check-handled "$module+$variant+$ref"
    [[ $? = 1 ]] && return

    #  If this module is marked as to be skipped

    if [[ "$ref" == "skip" ]]; then
        ilog $module %BModule %t$module%c marked to be skipped
        return
    fi

    log=$SCBI_LOGS/$TODAY/$SCBI_TARGET-$module-$variant-report.log

    cd $SCBI_ROOT

    [[ ! -f $SCBI_PLUGINS/$module ]] &&
        echo "error: no description for module $module" &&
        exit 1

    #  Then load module setup

    load-module $MODREF

    #  Check if envrionment is to be done for out-of-tree build

    SCBI_ISOOT=true
    is-hook-true $module $variant out-of-tree TRUE || SCBI_ISOOT=false

    #  Check if module to be handled only if specificed on command line

    if [[ $FORMODULE != "@root" ]]; then
        is-hook-true $module $variant only-explicit-build FALSE

        if [[ $? == 0 ]]; then
            ilog $module %BModule %t$module%c built only if explitly specified
            return
        fi
    fi

    #  Create module build directory

    if [[ $variant == "default" ]]; then
        SCBI_MODULES_LIST+=( "$module" )
    else
        SCBI_MODULES_LIST+=( "$module/$variant" )
    fi

    local TVDIR=""
    get-target-dir TVDIR $module $variant

    mkdir -p $TVDIR/logs > $log 2>&1

    [[ $DO_FLAT == yes ]] && mkdir -p $SCBI_BDIR/$module

    #  Check if meta-module, if so call handle-module for each one

    is-meta-module $MODREF > /dev/null

    if [[ $? == 0 ]]; then
        (
            handle-meta-module $FORMODULE $module $variant
        )
        res=$?
        unset SCBI_MODULES_LIST[-1]
        return $res
    fi

    #  Check for depends, and handle them if any

    if [[ $DEPS = yes ]]; then
        #  First we check for build dependencies
        (
            for dmodule in $(get-all-depends $module $variant build-depends); do
                handle-depends $MODREF $dmodule || exit 1
            done

            [[ $DRY_RUN == no ]] && line-sep

            #  And then we check for standard dependencies
            for dmodule in $(get-all-depends $module $variant depends); do
                handle-depends $MODREF $dmodule || exit 1
            done

            [[ $DRY_RUN == no ]] && line-sep

            #  Finaly check for tests dependencies if needed
            [[ $DO_TEST != no ]] &&
                {
                    for dmodule in \
                        $(get-all-depends $module $variant tests-depends);
                    do
                        handle-depends $MODREF $dmodule || exit 1
                    done

                    [[ $DRY_RUN == no ]] && line-sep
                }

            return 0
        )
        [[ $? != 0 ]] && exit 1
    fi

    if [[ $DRY_RUN == yes ]]; then
        echo "$MODREF"
        unset SCBI_MODULES_LIST[-1]
        return 0
    fi

    clog $module

    #  If purge is asked, first remove current build structure

    if [[ $DO_PURGE = yes || $DO_PURGE = only ]]; then
        ilog $module %BPurging %t$module%c for $SCBI_TARGET/$variant
        [[ -d $SCBI_BDIR/$module ]] &&
            module-purge $SCBI_BDIR/$module $FORMODULE $module \
                         $variant $SCBI_TARGET
    fi

    if [[ $DO_CLEAN_INSTALL = yes ]]; then
        ilog $module Clean $module install for $SCBI_TARGET/$variant
        [[ -d $SCBI_BDIR/$module ]] &&
            module-clean-install \
                $TVDIR/install \
                $FORMODULE $module $variant $SCBI_TARGET
        unset SCBI_MODULES_LIST[-1]
        return 0
    fi

    #  If purge-only, stop there

    if [[ $DO_PURGE = only ]]; then
        unset SCBI_MODULES_LIST[-1]
        return 0
    fi

    local DISPREF=""
    get-module-display-ref DISPREF $module $variant $ref

    line-sep
    ilog $module %BBuilding %t$module%c \[%g${variant//./ }%c\] \(%g$DISPREF%c\) | tee -a $log

    [[ $FORMODULE != "@root" ]] &&
        needed-by $module | tee -a $log

    if [[ $SCBI_HOST == $SCBI_TARGET ]]; then
        ilog $module native $SCBI_TARGET | tee -a $log
    else
        ilog $module cross $SCBI_TARGET | tee -a $log
    fi

    #  Create the build root directory if needed, note that we do check here
    #  even if already created when entering this routine. This is because
    #  in case of a purge the build directory could have been removed.

    [[ -d $TVDIR ]] || mkdir -p $TVDIR

    #  Set module environment if defined

    (
        #  We need to remove the link/sources to ensure proper setting by
        #  the module.

        [[ "${ref%%:*}" == "keep" ]] &&
            {
                #  Remove config/build/install steps
                for s in setup config build install wrapup; do
                    STEPS="${STEPS/$s/}"
                done

                DO_SETUP=no
                DO_CONFIG=no
                DO_BUILD=no
                DO_INSTALL=no
                DO_WRAPUP=no
            }

        ilog $module steps : $STEPS | tee -a $log


        if [[ "${ref%%:*}" == "keep" ]]; then
            ilog $module no update, keep current build
        else
            cd $SCBI_BDIR/$module
            rm -fr src src$SCBI_LNK vcs$SCBI_LNK

            handle-sources $FORMODULE $MODREF

            [[ $? != 0 ]] && exit 1
        fi

        #  Set cross-env if needed

        if [[ "$SCBI_HOST" != "$SCBI_TARGET" ]]; then
            target-env $SCBI_BDIR/install $SCBI_TARGET
        fi

        declare -A SCBI_MODULES_DIR=()

        local IS_UPTODATE=no
        is-module-up-to-date $MODREF $FORMODULE ||
            [[ "${ref%%:*}" == "keep" ]] && IS_UPTODATE=yes

        if [[ $IS_UPTODATE == no ]] || [[ $DO_TEST != no ]]; then
            local ENVTMP="$(mktemp -p /dev/shm/)"
            SCBI_ENV_MODULE=$ENVTMP

            handle-build-depends-env $FORMODULE $MODREF

            handle-module-env $FORMODULE $MODREF build-env >> $SCBI_ENV_MODULE

            #  And then setup recursively the environment to use dependencies

            handle-env $FORMODULE $MODREF

            unset SCBI_ENV_MODULE
        fi

        #  make sure the current build softlink is pointing to
        #  the variant. this is needed as the setup won't be
        #  done.

        if [[ -d build ]]; then
            rm -fr build
        elif [[ -h build ]]; then
            rm build
        elif [[ -f build$SCBI_LNK ]]; then
            rm -f build$SCBI_LNK
        fi
        ln -s $(realpath --relative-to=$PWD $TVDIR) build

        #  Only rebuild if mismatch

        if [[ $IS_UPTODATE == yes ]]; then
            ilog $module no build needed, versions match

            STEPS=""

            # if testing is expected, at least do that

            [[ $DO_TEST != "no" ]] && STEPS="tests"

        else
            #  Record the build-plan

            record-build-plan $module $variant

            #  Log module environment

            record-module-env $module $variant

            #  Setup the build environment for the current module

            local SCBI_LOGS_DIR=$TVDIR/logs
            SCBI_ENV_MODULE=$SCBI_LOGS_DIR/env.cmd
            rm -f $SCBI_ENV_MODULE

            [[ -n $SCBI_OS_MODULE_FILE ]] &&
                {
                    echo
                    echo "# OS specific support"
                    cat $SCBI_OS_MODULE_FILE
                } >> $SCBI_ENV_MODULE

            if [[ -d $TVDIR ]]; then
                #  Exports all environment variables starting with SCBI_
                echo                          >> $SCBI_ENV_MODULE
                echo "# SCBI global settings" >> $SCBI_ENV_MODULE

                while read -r VAR; do
                    if [[ "$VAR" != "${VAR#SCBI_*}" ]]; then
                        local NAME=${VAR%=*}
                        local VALUE=${VAR#*=}
                        case $NAME in
                            SCBI_JOBS|SCBI_HALF_JOBS)
                                echo export $NAME=\${$NAME:-$VALUE}
                                ;;
                            SCBI_PLUGINS)
                                echo export $NAME=\'$SCBI_LOGS_DIR\'
                                ;;
                            *)
                                echo export $NAME=\'$VALUE\'
                                ;;
                        esac >> $SCBI_ENV_MODULE
                    fi
                done < <( env )
            fi

            cat $ENVTMP >> $SCBI_ENV_MODULE

            # Generate the SCBI_MODULES_DIR associative array
            {
                echo
                echo "# SCBI_MODULES_DIR"
                echo "declare -A SCBI_MODULES_DIR=("

                for D in ${!SCBI_MODULES_DIR[@]}; do
                    local V="${SCBI_MODULES_DIR[$D]}"
                    local V=${V/$SCBI_TARGET/\$SCBI_TARGET}
                    echo "  [\"$D\"]=\"\$SCBI_BDIR${V#$SCBI_BDIR}\""
                done

                echo ")"
            } >> $SCBI_ENV_MODULE

            unset SCBI_ENV_MODULE

            #  If install is requested and we already have a local install
            #  directory, clean it to ensure no old versions are installed
            #  into the same location.

            if [[ $DO_INSTALL != no ]]; then
                rm -fr $TVDIR/install
                rm -f  $SCBI_BDIR/$module/install-id
                rm -f  $SCBI_BDIR/$module/install-${SCBI_TARGET}-id
            fi

            #  Build is needed, on safe mode we remove the current
            #  build directory to ensure that old configuration and/or
            #  build artifacts are not going to break new build.
            #
            #  Note that we do that only for out-of-tree build as in
            #  the build in-tree the sources are fully synchronized from
            #  src directory (deleting all non existing files in source
            #  location).

            if [[ $SAFE_MODE = yes ]] &&
                   [[ $SCBI_ISOOT = true ]] &&
                   [[ $DO_BUILD == yes ]];
            then
                rm -fr $TVDIR/build$SCBI_LNK
                rm -f $TVDIR/build-id
            fi
        fi

        rm -f $ENVTMP

        local TEEOPT="-a"
        [[ $SCBI_DLOG = yes ]] && TEEOPT=""

        for step in $STEPS; do
            #  If test step (last step for a module) ensure that the
            #  module's env is loaded as tests are client of the module
            #  artifacts.

            if [[ $step == "tests" ]]; then
                handle-tests-depends-env $FORMODULE $MODREF
                handle-module-env $FORMODULE $MODREF env
            fi

            ########## PRE module

            #  Apply any generic pre-step (module-pre-setup, module-pre-purge)

            local res=0

            fn-exists module-pre-$step

            if [[ $? = 0 ]]; then
                cd $SCBI_BDIR/$module

                module-pre-$step \
                    $TVDIR/install \
                    $FORMODULE \
                    $module \
                    $variant $SCBI_TARGET $SCBI_ISOOT 2>&1 \
                    | tee $TEEOPT $log
                res=${PIPESTATUS[0]}
            fi

            if [[ $res != 0 ]]; then
                elog $module generic module pre-$step failed with error $res
                return $res
            fi

            #  Apply module specific step if any

            module-variant-wrapper \
                $TVDIR/install $module \
                $variant pre-$step || exit 1

            ########## module

            module-variant-wrapper \
                $TVDIR/install $module \
                $variant $step || exit 1

            #  Apply any generic step (module-setup, module-purge)

            res=0

            fn-exists module-$step

            if [[ $? = 0 ]]; then
                cd $SCBI_BDIR/$module

                module-$step \
                    $TVDIR/install \
                    $FORMODULE \
                    $module $variant $SCBI_TARGET $SCBI_ISOOT 2>&1 | tee $TEEOPT $log
                res=${PIPESTATUS[0]}
            fi

            if [[ $res -ne 0 ]]; then
                elog $module generic module $step failed with error $res
                return $res
            fi

            ########## POST module

            module-variant-wrapper \
                $TVDIR/install \
                $module $variant post-$step || exit 1

            res=0

            fn-exists module-post-$step

            if [[ $? = 0 ]]; then
                cd $SCBI_BDIR/$module

                module-post-$step \
                    $TVDIR/install \
                    $FORMODULE \
                    $module $variant $SCBI_TARGET $SCBI_ISOOT \
                    2>&1 | tee $TEEOPT $log
                res=${PIPESTATUS[0]}
            fi

            if [[ $res != 0 ]]; then
                elog $module generic module post-$step failed with error $res
                return $res
            fi
        done
    ) || exit 1

    #  Create binary archive if needed

    if [[ $DO_ARCHIVE = yes ]]; then
        cd $TVDIR >> $log 2>&1
        rm -f $module-bin.tar*
        tar cf $module-bin.tar --directory=install .
        bzip2 -9 $module-bin.tar
    fi

    local _IDIR=""

    local FCT=""
    get-hook FCT $module $variant prefix

    if [[ -n $FCT ]] && [[ "$SCBI_DEFAULT_PREFIX" == "yes" ]]; then
        _IDIR=$($FCT $TVDIR/install $SCBI_TARGET $variant)
    else
        _IDIR=$SCBI_PREFIX
    fi

    if [[ ${_IDIR^^} == NONE ]]; then
        ilog $module skip global install

    elif [[ "${ref%%:*}" != "keep" ]] &&
             [[ "$DO_INSTALL" != "no" ]] &&
             [[ -d $TVDIR/install ]];
    then
        local IDEST=${_IDIR/$SCBI_BDIR/<sandbox>}
        IDEST=${IDEST/$HOME/\$HOME}

        ilog $module copy install into $IDEST

        #  Record global install
        echo "$variant" > $SCBI_BDIR/$module/install-${SCBI_TARGET}-id
        echo ${_IDIR}  >> $SCBI_BDIR/$module/install-${SCBI_TARGET}-id

        #  Finaly copy to given prefix
        local SUDO=""

        if [[ ! -d ${_IDIR} ]]; then
            mkdir -p ${_IDIR} &> /dev/null
            [[ $? != 0 ]] && SUDO=sudo
        fi

        if [[ ! -w ${_IDIR} ]]; then
            SUDO=sudo
        fi

        $SUDO mkdir -p ${_IDIR}/
        $SUDO rsync -a --force \
              $TVDIR/install/. \
              ${_IDIR}/. > $log 2>&1
    fi || elog $module fail to copy to ${_IDIR}

    ilog $module End Building $module \[${variant//./ }\] \($DISPREF\) \
        | tee -a $log
    line-sep

    unset SCBI_MODULES_LIST[-1]
}

############################## setup-generic-tool-env
#
# Routine to share the env settings with sub-commands

function setup-generic-tool-env()
{
    local offset=0

    [[ $SCBI_IS_WINDOWS == yes ]] && offset=8

    if [[ $DO_COLOR == dark ]]; then
        tput setaf 7

        SCBI_CBOLD=$(tput bold)$(tput setaf 252)
        SCBI_CTEXT=$(tput setaf 15)
        SCBI_CCLEAR=$(tput sgr0)$(tput setaf 7)
        SCBI_CRED=$SCBI_CBOLD$(tput setaf $((9 - offset)))
        SCBI_CBLUE=$SCBI_CBOLD$(tput setaf $((12 - offset)))
        SCBI_CGREEN=$SCBI_CBOLD$(tput setaf $((10 - offset)))
    elif [[ $DO_COLOR == light ]]; then
        tput setaf 0

        SCBI_CBOLD=$(tput bold)$(tput setaf 239)
        SCBI_CTEXT=$(tput setaf 0)
        SCBI_CCLEAR=$(tput sgr0)
        SCBI_CRED=$SCBI_CBOLD$(tput setaf 1)
        SCBI_CBLUE=$SCBI_CBOLD$(tput setaf 4)
        SCBI_CGREEN=$SCBI_CBOLD$(tput setaf 2)
    fi

    #  Load module definitions

    [[ ! -d "$SCBI_PLUGINS" ]] ||
        [[ -z "$(ls $SCBI_PLUGINS/[0-9]* 2> /dev/null)" ]] &&
            SCBI_PLUGINS=$HOME/.config/scbi

    [[ ! -d "$SCBI_PLUGINS" ]] &&
        echo "$0: cannot find module definition files" && exit 1

    #  Load user's environment if any now that SCBI_PLUGINS is set

    load-module-env $ENV_NAME

    #  If we have specified a build directory on command line, set it now
    #  that the env is loaded (takes precedence).

    [[ -n ${CMDLINE_OPTS[SCBI_BDIR]} ]] &&
        SCBI_BDIR=${CMDLINE_OPTS[SCBI_BDIR]}

    [[ -n ${CMDLINE_OPTS[DO_FLAT]} ]] &&
        DO_FLAT=${CMDLINE_OPTS[DO_FLAT]}

    #  Then load any global settings, not overriding user's ones

    for setup in $SCBI_PLUGINS/[0-9]*; do
        source $setup
    done

    #  Then load any OS dependent runtime module

    [[ -f $SCBI_PLUGINS/_os_$SCBI_OS_MODULE ]] &&
        {
            SCBI_OS_MODULE_FILE=$SCBI_PLUGINS/_os_$SCBI_OS_MODULE
            source $SCBI_OS_MODULE_FILE
        }

    #  Nothing to build, display version

    if [[ $DO_VERSION = yes ]]; then
        echo "SCBI : $SCBI_VERSION"
        for file in $(ls $SCBI_PLUGINS/.scbi*version.txt 2> /dev/null); do
            cat $file
        done
        exit 0
    fi

    #  If a plan passed on the command line ensure that it is used instead
    #  of any other possibly set in the environment file.

    [[ -n ${CMDLINE_OPTS[SCBI_PLAN]} ]] &&
        SCBI_PLAN=${CMDLINE_OPTS[SCBI_PLAN]}

    #  Clear cache is needed

    [[ $DO_CLEAR_CACHE == yes ]] &&
        rm -fr $SCBI_BDIR/.cache

    #  Check if cache for the plan is available and is still up-to-date
    #  by getting :
    #     - Signature of the plan
    #     - Signature of the OS installation log
    #     - OS discriminants
    #     - Signature of the modules on command line
    #     - The build target

    local PLANMD5=""
    module-plan-md5 PLANMD5 "$SCBI_PLAN"

    local OSMD5=""
    get-install-md5 OSMD5

    local MSIG=""
    for M in ${SCBI_MODULES[*]}; do
        local minfo=()
        get-module-ref minfo $M
        local module=${minfo[0]}
        local variant=${minfo[1]}
        local ref=${minfo[3]}
        [[ $variant != default ]] || [[ $ref != NONE ]] &&
            MSIG+="($M/$variant/$ref)"
        [[ -f $SCBI_PLUGINS/$module ]] &&
            MSIG+=$(cat $SCBI_PLUGINS/$module)
    done

    local PLANMD5=$(echo $PLANMD5 $OSMD5 $SCBI_TARGET $SCBI_OS_ID \
                         $SCBI_OS_NAME $SCBI_OS_VERSION $SCBI_OS_MAJOR_VERSION \
                         ${SCBI_OS_DISCRIMINANTS[*]} $MSIG | get-md5)

    mkdir -p $SCBI_BDIR/.cache

    local PLAN_CACHED=no
    local CACHED_PLAN=$SCBI_BDIR/.cache/plan-$PLANMD5

    #  Load build plan if any

    if [[ -f $CACHED_PLAN ]]; then
        local PLAN_CACHED=yes
        source $CACHED_PLAN

    elif [[ -n $SCBI_PLAN ]]; then
        load-module-plan $SCBI_PLAN
        [[ $? -ne 0 ]] &&
            echo "error: cannot load module plan $SCBI_PLAN" &&
            exit 1
    fi

    [[ $DO_SUBCMD == no ]] &&
        {
            [[ -z ${SCBI_MODULES[*]} ]] &&
                [[ $DO_STAT == no ]] &&
                usage && exit 0

            [[ $DO_HELP == yes ]] && usage && exit 0
        }

    [[ $DO_STAT != no ]] &&
        display-stat

    [[ $DO_SUBCMD == no ]] &&
        {
            [[ -z ${SCBI_MODULES[*]} ]] && [[ $DO_STAT != short ]] &&
                display-modules && display-plans

            if [[ $DO_STAT == full ]]; then
                display-log-stat
            elif [[ -z ${SCBI_MODULES[*]} ]] && [[ $DO_STAT == yes ]]; then
                echo
            fi
        }

    #  We still need to set the module's ref passed on the command line
    #  for proper handling of the :keep special ref.

    for module in ${SCBI_MODULES[*]}; do
        set-module-ref $module
    done

    if [[ $PLAN_CACHED == yes ]]; then
        if [[ $DO_SUBCMD == no ]] || [[ $DO_STAT != no ]]; then
            [[ ${#SCBI_MODVER[*]} > 0 ]] &&
                {
                    ilog build "Using cached module plan (${PLANMD5:0:20})"
                    line-sep
                }
        fi

    else
        #  Setup module reference specified on the command line. The module
        #  reference on the command line must overwrite the actual build plan.

        local res=0

        if [[ $DO_SUBCMD == no ]] || [[ $DO_STAT != no ]]; then
            rewrite-module-plan
            res=$?
            line-sep
        else
            rewrite-module-plan > /dev/null
            res=$?
        fi
        [[ $res == 1 ]] && exit 1

        store-cached-plan $CACHED_PLAN
    fi
}

############################## body

#  Check for common options shared with sub-commands
#  And check for --enable-*, --run* and --tests* options

#  We also handle specific parameters:
#    --enable-*
#    --run:"some command"

declare SCBIOPTS=()
declare SCBIARGS=()
declare -A CMDLINE_OPTS=()

#  Load ini file
ini-load-files
#  Apply default global values
ini-apply-values ""

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            CMDLINE_OPTS+=([DO_HELP]=yes)
            break
            ;;
        -v|--version)
            CMDLINE_OPTS+=([DO_VERSION]=yes)
            break
            ;;
        -f|--force)
            CMDLINE_OPTS+=([DO_FORCE]=yes)
            ;;
        --clear-cache)
            CMDLINE_OPTS+=([DO_CLEAR_CACHE]=yes)
            ;;
        -q|--quiet)
            CMDLINE_OPTS+=([DO_QUIET]=yes)
            ;;
        --color:dark)
            CMDLINE_OPTS+=([DO_COLOR]=dark)
            ;;
        --color:light)
            CMDLINE_OPTS+=([DO_COLOR]=light)
            ;;
        --color:no)
            CMDLINE_OPTS+=([DO_COLOR]=no)
            ;;
        -e)
            CMDLINE_OPTS+=([ENV_NAME]="${2}")
            shift
            ;;
        --env*)
            CMDLINE_OPTS+=([ENV_NAME]="${1#*=}")
            ;;
        -t)
            CMDLINE_OPTS+=([SCBI_TARGET]="$2")
            shift
            CMDLINE_OPTS+=([SCBI_TARGET_SPECIFIED]=yes)
            ;;
        --target=*)
            CMDLINE_OPTS+=([SCBI_TARGET]="${1#*=}")
            CMDLINE_OPTS+=([SCBI_TARGET_SPECIFIED]=yes)
            ;;
        --plan*)
            CMDLINE_OPTS+=([SCBI_PLAN]="${1#*=}")
            ;;
        --stat:full)
            CMDLINE_OPTS+=([DO_STAT]=full)
            ;;
        --stat:short)
            CMDLINE_OPTS+=([DO_STAT]=short)
            ;;
        --stat)
            CMDLINE_OPTS+=([DO_STAT]=yes)
            ;;
        --flat)
            CMDLINE_OPTS+=([DO_FLAT]=yes)
            ;;
        --build-dir*)
            CMDLINE_OPTS+=([SCBI_BDIR]="${1#*=}")
            ;;
        --plugins*)
            VAL=${1#*=}
            CMDLINE_OPTS+=([SCBI_PLUGINS]="$VAL")
            if [[ ! -d "$VAL" ]] || \
                   [[ -z "$(ls $VAL/[0-9]* 2> /dev/null)" ]];
            then
                echo "$0: no plugins found in $VAL"
                exit 1
            fi
            ;;
        --enable-*)
            VAR=${1/--enable-/}
            export SCBI_${VAR//-/_}_SET=true
            ;;
        --tests:only*)
            do-clear-steps
            CMDLINE_OPTS+=([DO_TEST]=yes-only)
            OPTS=( ${1/=/ } )
            CMDLINE_OPTS+=([SCBI_TESTS_OPTIONS]="${OPTS[*]:1}")
            ;;
        --tests*)
            CMDLINE_OPTS+=([DO_TEST]=yes)
            OPTS=( ${1/=/ } )
            CMDLINE_OPTS+=([SCBI_TESTS_OPTIONS]="${OPTS[*]:1}")
            ;;
        --ini*)
            ini-apply-values ${1#*=}
            ;;
        (-*)
            SCBIOPTS+=( "$1" )
            ;;
        (*)
            SCBI_MODULES+=( "$1" )
            ;;
    esac
    shift
done

#  Add modules from ini file at the end, needed to get
#  the sub-command below.
SCBI_MODULES+=( ${SCBI_INI_MODULES} )

############################## sub-commands

#  Check if first argument is a sub-command
SCBI_SUBCMD=${SCBI_INI_SUBCMD:-${SCBI_MODULES[0]}}

if [[ -n "$(which scbi-$SCBI_SUBCMD 2> /dev/null)" ]]; then
    export DO_SUBCMD=yes

    [[ -z $SCBI_INI_SUBCMD ]] &&
        unset SCBI_MODULES[0]

    ini-apply-values scbi-$SCBI_SUBCMD
fi

#  Apply now command line options, this must be done after
#  ini-apply-values above as a command line option must take
#  precedence.

for O in "${!CMDLINE_OPTS[@]}"; do
    eval $O=\"${CMDLINE_OPTS[$O]}\"
done

if [[ -n "$(which scbi-$SCBI_SUBCMD 2> /dev/null)" ]]; then
    #  Setup the generic SCBI environment for the sub-command
    setup-generic-tool-env

    source $(dirname $SCBI_BINARY)/scbi-$SCBI_SUBCMD \
           subcommand "${SCBIOPTS[@]}" "${SCBI_MODULES[@]}"

    exit $?
fi

SCBIOPTS+=( ${SCBI_INI_OPTIONS[*]} ${SCBI_MODULES[*]} )

OPTFILE=$(mktemp)

ALLOPTS=$(getopt -u -o j:adefSIuscbilnpqvwWh \
                 -l no-setup,no-install,update,setup,config \
                 -l build,build-target:,install,clean-install,create-archive \
                 -l log,log:yes,log:no,log:on-failure,purge,purge:only \
                 -l prefix:,deps,deps:warning,archive,force,env:,no-patch \
                 -l no-wrapup,wrapup,safe,standalone \
                 -l dry-run,jobs:,list-plan: \
                 -- ${SCBIOPTS[*]} 2> $OPTFILE)

if [[ $? != 0 ]]; then
    cat $OPTFILE
    echo try \"scbi --help\" for more information.
    rm -f $OPTFILE
    exit 1
fi

rm -f $OPTFILE

set -- $ALLOPTS

SCBI_MODULES=()

while [[ $# -gt 0 ]]; do
    case $1 in
        -a|--create-archive)
            DO_ARCHIVE=yes
            ;;
        --archive)
            ARCHIVE_CACHE=no
            ;;
        -S|--no-setup)
            DO_SETUP=no
            ;;
        -W|--no-wrapup)
            DO_WRAPUP=no
            ;;
        -w|--wrapup)
            do-clear-steps
            DO_WRAPUP=forced
            ;;
        -I|--no-install)
            DO_INSTALL=no
            ;;
        -u|--update)
            DO_UPDATE=yes
            ;;
        -s|--setup)
            do-clear-steps
            DO_SETUP=forced
            ;;
        -c|--config)
            do-clear-steps
            DO_CONFIG=forced
            ;;
        -b|--build)
            do-clear-steps
            DO_BUILD=forced
            ;;
        --build-target)
            BUILD_SCBI_TARGET=$2
            shift
            ;;
        -d|--deps)
            DEPS=yes
            ;;
        --deps:warning)
            DEPS=yes
            DO_WARNING_EXTERNAL=yes
            ;;
        -i|--install)
            do-clear-steps
            DO_INSTALL=forced
            ;;
        -l|--log|--log:yes)
            SCBI_DLOG=yes
            ;;
        --log:no)
            SCBI_DLOG=no
            ;;
        --log:on-failure)
            SCBI_DLOG=on-failure
            ;;
        -p|--purge)
            DO_PURGE=yes
            ;;
        --purge:only)
            DO_PURGE=only
            ;;
        -n|--no-patch)
            DO_PATCH=no
            ;;
        --prefix)
            SCBI_DEFAULT_PREFIX=no
            SCBI_PREFIX=$2
            shift
            ;;
        -j|--jobs)
            SCBI_JOBS=$2
            shift
            SCBI_HALF_JOBS=$SCBI_JOBS
            ;;
        --dry-run)
            DRY_RUN=yes
            ;;
        --safe)
            SAFE_MODE=yes
            ;;
        --standalone)
            DO_STANDALONE=yes
            ;;
        --clean-install)
            DO_CLEAN_INSTALL=yes
            ;;
        (--)
            ;;
        (*)
            SCBI_MODULES+=( $1 )
            ;;
        (-*)
            echo "$0: error - unrecognized option $1" 1>&2; exit 1
            ;;
    esac
    shift
done

trap clean-up EXIT

#  Build the steps to be conducted

[[ $DO_SETUP   != no ]] && STEPS="$STEPS setup"
[[ $DO_CONFIG  != no ]] && STEPS="$STEPS config"
[[ $DO_BUILD   != no ]] && STEPS="$STEPS build"
[[ $DO_INSTALL != no ]] && STEPS="$STEPS install"
[[ $DO_TEST    != no ]] && STEPS="$STEPS tests"
[[ $DO_WRAPUP  != no ]] && STEPS="$STEPS wrapup"

setup-generic-tool-env

#  Prepare log dir and archive dir

mkdir -p $SCBI_LOGS/$TODAY
mkdir -p $SCBI_ARCHIVES

if [[ $DRY_RUN == yes ]]; then
    DO_PURGE=no
    DO_INSTALL=no
    DO_ARCHIVE=no
    DO_UPDATE=no
    DO_FORCE=no
    DO_CLEAN_INSTALL=no
    STEPS=""
fi

#  Copy the runtime for replay with {config,build,install}.cmd scripts

cp $SCBI_PLUGINS/0_runtime $SCBI_BDIR/.scbi.runtime

#  Some more helpers that cannot be put in 0_runtime as needed in scbi
#  script very early (before plug-in dir is set).
{
    echo
    echo "###### helpers"
    echo
    for fct in check-tool check-tools check-tools-abort; do
        echo "function $(declare -f $fct)"
        echo
    done
} >> $SCBI_BDIR/.scbi.runtime

#  Run script for all modules

for module in ${SCBI_MODULES[*]}; do
    handle-module "@root" $module || exit 1
done

if [[ $DO_STANDALONE == yes ]]; then
    create-standalone-package
fi
